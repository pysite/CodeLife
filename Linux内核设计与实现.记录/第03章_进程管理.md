## 3.2 进程描述符及任务结构

### 3.2.1

内核把进程存放在叫任务队列(task list)的双向循环链表中。每个进程用task_struct表示。

task_struct通过slab分配器进行分配，在每个进程的内核栈的尾端（这样是为了通过栈指针就可以计算出位置）分配的是thread_info，thread_info中有指向task_struct的指针。

### 3.2.2

进程标识值pid就是个int，默认pid最大值为32768，管理员可以修改/proc/sys/kernel/pid_max来提高上限。

``current_thread_info()``返回当前线程的thread_info结构体。

### 3.2.3

进程的状态有TASK_RUNNING，TASK_INTERRUPTIBLE（睡眠中，等待被中断唤醒），TASK_UNINTERRUPTIBLE（睡眠中，不可被唤醒，很少用），TASK_TRACED（被其它进程追踪），TASK_STOPPED（进程停止运行，也不能被调度运行，在调试过程中收到任何信号也会进入这种状态）。

### 3.2.6

每个task_struct中有parent指向父进程的task_struct，有children指向子进程组成的list。

初始进程init_task是个静态变量，pid为1，任何进程都是init_task的子进程（树的根）。

task_struct中也有prev和next指针，因为任务队列本身也是个双向的循环队列。



## 3.3 进程创建

Unix通过fork()和exec()来创建新进程，其中exec()指所有exec()一族的函数，例如内核实现了execve()，execlp()，execle()，execv()，execvp()函数。

### 3.3.1 写时拷贝

由于copy on write，fork()创建进程时不会立马创建并复制父进程的内存页。fork()的实际开销就是创建子进程的task_struct以及复制父进程的页表。

### 3.3.2 fork()

fork()，vfork()，__clone()这些都是通过各自需要的参数标志调用clone()，clone()又去调用do_fork()。

``do_fork()``完成了创建的大部分工作。该函数调用copy_progress()进行复制task_struct、分配pid、根据传入的参数复制一些数据等工作。

``do_fork()``结束后会让新创建的子进程唤醒并投入运行，因为一般子进程会马上调用exec函数，如果父进程首先执行的话可能会开始向地址空间写入。

### 3.3.3 vfork()

vfork()不拷贝父进程的页表，其余功能和fork()相同。具体实现大概就是vfork创建的子进程task_struct中有个vfork_done指针，当子进程开始在新的地址空间中运行时会通过这个vfork_done向父进程发送信号，此时父进程才从阻塞状态中恢复过来。



## 3.4 线程在Linux中的实现

Linux并没有专门的线程结构体，线程就被看做是一个与其它进程共享某些资源的进程，每个线程都有自己的task_struct。

### 3.4.2 内核线程

内核线程没有独立的地址空间（task_struct的mm指针为NULL），只在内核空间运行。

kthreadd内核进程衍生出所有新的内核线程。（和init_task类似）

``kthread_create``创建内核线程，``wake_up_process``运行内核线程，``do_exit()``或``kthread_stop(task)``结束内核线程。



## 3.5 进程终结

C语言会在main()返回点后面加调用exit()的代码。回收工作实际上由``do_exit()``负责。

在调用完``do_exit()``后进程处于EXIT_ZOMBIE状态。此时占用内存就是内核栈、thread_info结构和task_struct结构，此时进程存在的唯一目的就是向它的父进程提供信息。

### 3.5.1

wait()一族函数都是调用wait4()函数，wait()会阻塞直到其中一个子进程退出。并且会回收此ZOMBIE子进程的剩余占用的资源。

### 3.5.2

在do_exit()中会为子进程寻找新的父进程，如果进程所在的进程组（or 线程组）中没有其他进程，则新父进程就是init进程。

init进程会定期例行调用wait()来检查并回收其子进程。
