# 《Linux内核设计与实现》

## 第1章

- 通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。

- 许多操作系统的中断服务程序，包括Linux的，都不在进程上下文中执行，它们在一个==与所有进程都无关==的、专门的中断上下文运行。

- 当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。
- CPU总处于三种状态：1.用户空间；2.内核空间；3.内核空间，但处于中断上下文，与任何进程无关。

- 书上说内核分为两大阵营：单内核和微内核（实际就是宏内核和微内核之分），Winodows这种就是微内核，微内核功能被划分为多个独立过程，每个过程叫一个服务，许多服务都运行于用户空间，所有服务都保持独立并运行在各自的地址空间上，因此就不可能像单内核那样直接调用函数，而是通过消息传递处理微内核通信——采用进程间通信（IPC）机制。

  Linux就是宏内核，运行在单独的内核地址空间上，采用了模块化设计、抢占式内核、支持内核线程以及动态装载内核模块。

- Linux可以抢占，即==Linux内核具有允许在内核运行的任务优先执行的能力==。

- Linux版本号的含义：Linux版本号2.6.26.1，其中2是主版本号，6是从版本号（副版本号），26是修订版本号，1是稳定号。==其中从版本号如果是偶数就是稳定版，奇数就是开发版==。



## 第2章

- 内核源码一般安装在/usr/src/linux目录下，不要把这个源码树用于开发，因为编译你的C库所用的内核版本就链接到这棵树。不要以root身份对内核进行修改。

重要的内核目录含义：

| 目录          | 含义                                |
| ------------- | ----------------------------------- |
| arch          | 特定体系结构的源码                  |
| crypto        | 加密API                             |
| Documentation | 内核源码文档                        |
| drivers       | 设备驱动程序                        |
| firmware      | 使用某些驱动程序而需要的设备固件    |
| init          | 内核引导和初始化                    |
| ipc           | 进程间通信代码                      |
| kernel        | 像调度程序这样的核心子系统          |
| mm            | 内存管理子系统和VM                  |
| net           | 网络子系统                          |
| samples       | 示例、示范代码                      |
| scripts       | 编译内核所用的脚本                  |
| usr           | 早期用户空间代码（所谓的initramfs） |
| tools         | 在Linux开发中有用的工具             |
| virt          | 虚拟化基础结构                      |

P29



## 第13章

每个注册的文件系统由file_system_type结构体来表示，它描述了文件系统及其性能；

每一个安装点也都用vfsmount结构体表示，它包含的是安装点的相关信息；

各个文件系统都必须实现超级块对象，对于并非基于磁盘的文件系统（比如基于内存的文件系统，比如sysfs），它们会在使用现场创建超级块并将其保存到内存中。

由于在C语言中无法直接得到操作函数的父对象，所以必须将父对象以参数形式传给函数。

超级块自身的锁是s_lock。



inode->i_op中的create函数是为新建的dentry对象创建一个新的索引节点。

inode->i_op中的truncate函数由VFS调用，修改文件的大小，在调用前索引节点的i_size项必须设置为预期的大小；

inode->i_op中的setattr函数用于修改inode后通知系统发生了改变，getattr函数用于通知索引节点需要从磁盘中更新。

inode有扩展属性（key/value），由i_op中setxattr和getxattr函数操控。



==VFS中说目录项对象dentry没有对应的磁盘数据结构==，VFS根据字符串形式的路径名现场创建它。所以目录项结构体没有是否被修改的标志（是否为脏）

VFS目录项有三种状态：被使用，d_inode指向有效的inode，d_count大于0；未被使用，d_inode指向有效的inode，d_count等于0；负状态，d_inode为NULL。（即使是负状态的dentry缓存起来也是有用的，可以加快一些无效的路径查找）

VFS将目录项缓存在目录项缓存中（dcache）。

VFS中inode的i_dentry是个dentry的链表，因为一个inode可能被多个dentry所链接，因此用链表。

dcache主要由三个部分组成：

- ”被使用“的目录项链表，就是inode中的i_dentry链表；

- ”最近被使用的“双向链表，就是最近被使用的dentry都会记录到这个链表上；

- 散列表和相应的散列函数用来==快速解析路径==；

  散列表是dentry_hashtable，每个元素也是个dentry的链表（因为可能哈希冲突），计算哈希值用d_hash()，查找用d_lookup()；

  （在查找一个路径对应的文件时，VFS会先在目录项缓存中搜索路径名，找不到才会去对应文件系统去解析路径，同时将新解析出的dentry放入dcache）

dcache也使得其中的dentry对应的inode被缓存，因为和目录项对象相关的索引节点对象不会被释放，因为目录项会使相关索引节点的使用计数为正。