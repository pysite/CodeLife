## 6.1 链表

```c
// Linux中的list_head
struct list_head{
    struct list_head *next;
    struct list_head *prev;
};

// 用户自定义结构体A, 使用了Linux的链表
struct A{
    int val;
    struct list_head list;
}

// list_entry和container_of就是完全相同的
#define list_entry(ptr, type, member) \
		container_of(ptr, type, member)

// 初始化一个A
struct A *pA;
pA = kmalloc(sizeof(*pA), GFP_KERNEL);
INIT_LIST_HEAD(&pA->list);	// 这步很关键
// 或者
pA->list = INIT_LIST_HEAD(&pA->list);

// 创建链表头
LIST_HEAD(A_list);

// 添加节点
list_add(&pA->list, &A_list);
list_add_tail(&pA->list, &A_list);

// 删除节点
list_del(&pA->list);
list_del_init(&pA->list);	// 移除一个节点, 并对其清0

// 将一个节点从当前链表中删除, 再移动到新的链表
list_move(&pA->list, &B_list);
list_move_tail(&pA->list, &B_list);

// 判断链表是否为空
list_empty(&A_list);

// 将两个未连接的链表合并
list_splice(&A_list, &B_list);		// A插到B后面
list_splice_init(&A_list, &B_list);	// A会被初始化，然后插到B后面

// 遍历的方法1
struct list_head *temp_ptr;
struct A *temp_pA;
list_for_each(temp_ptr, &A_list){
    temp_pA = list_entry(temp_ptr, struct A, list);	// 后面两个是 结构体名 成员变量名
}

// 遍历的方法2
struct A *temp_pA;
list_for_each_entry(temp_pA, &A_list, list){
    // temp_pA便指向每个A
}
// 反向遍历
list_for_each_entry_reverse(...){
}

// 遍历中同时可以删除该节点, 只需要多提供个next指针即可
struct A *temp_now;
struct A *temp_next;
list_for_each_entry_safe(temp_now, temp_next, &A_list, list){
    // 在这里可以使用temp_now, 也可以删除list_del(&temp_now->list)
}
// 反向遍历
list_for_each_entry_safe_reverse(...){	
}
```

需要说明的是，以上所有操作不保证并发安全性，如果有并发可能，需要对这个链表进行**加锁**。



## 6.2 队列

Linux内核使用的队列是kfifo。kfifo内部维持了两个变量，入口偏移和出口偏移，分别代表下一次入队和出队的数据位置。



创建队列：

```c
struct kfifo fifo;
int ret = kfifo_alloc(&fifo, PAGE_SIZE, GFP_KERNEL);	//PAGE_SIZE是指队列的总大小为一个物理页

//PS: 还可以用kfifo_init传入自己已申请的内存来创建
```

入队：

```c
int input_len = kfifo_in(&fifo, ptr, size);	//将ptr指向的大小为size的数据入队, 返回值是成功入队的长度
```

出队：

```c
int output_len = kfifo_out(&fifo, ptr, size);	//从队列中输出size大小的数据到ptr指向的缓冲区

//PS: 还可以用kfifo_out_peek函数来"偷窥"数据且仍然保留在队列中
```

获取队列信息：

```c
kfifo_size(&fifo);	//总大小
kfifo_len(&fifo);	//已用大小
kfifo_avail(&fifo);	//空闲大小
kfifo_is_empty(&fifo);
kfifo_is_full(&fifo);
```

删除队列：

```c
kfifo_reset(&fifo);	//重置队列中的内容
kfifo_free(&fifo);	//彻底删除队列
```



## 6.3 映射

内核使用idr来将一个唯一的标识数（UID）映射到一个指针。idr数据结构用于映射用户空间的UID。

创建映射：

```c
struct idr idr1;
idr_init(&idr1);
```

添加数据：

```c
idr_pre_get(&idr1, GFP_KERNEL);	//提前准备分配新的UID

int id;
idr_get_new(&idr1, ptr, &id);	//将ptr指向的数据加入到映射中, 其分配的UID存储在id中

idr_get_new_above(&idr1, ptr, start_id, &id);	//也是将数据加入到映射, 但要求分配的UID大于等于start_id
```

查找数据：

```c
ptr = idr_find(&idr1, id);
```

删除数据（只是从映射中删除）：

```c
idr_remove(&idr1, id);
```

删除映射：

```c
idr_remove_all(&idr1);	//先删除idr中所有映射关系
idr_destroy(&idr1);		//再删除映射
```



## 6.4 二叉树

Linux实现的红黑树为rbtree。根节点为``struct rb_root``，其它节点为``struct rb_node``。

``rb_entry(...)``和之前的``container_of(...)``一样，从``rb_node``成员获取到外面数据结构的指针。

Linux没有提供rbtree的搜索和插入函数，希望由用户自定义。

创建红黑树根节点：

```c
struct rb_root root = RB_ROOT;
```

页高速缓存中使用红黑树的例子——搜索函数：

```c
rb_search_page_cache(...);
```

页高速缓存中使用红黑树的例子——插入函数：

```c
rb_insert_page_cache(...);
```

