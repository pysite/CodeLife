## 第4章 进程调度

- CFS用红黑树管理所有可运行进程队列。根据vruntime作为键值。

- Linux中不止一个调度器，CFS只是普通进程的调度器，系统运行的大多数进程都是普通进程。在选择下一个要运行的进程时，会选择优先级最高的调度器的优先级最高的进程。

- **用户抢占**：

  在从内核空间返回用户空间时，如果need_resched标志被设置就可以被抢占；

- **内核抢占**：

  只要没有持有锁，内核就可以进行抢占，锁是非抢占区域的标志；preempt_count；

  内核态进程显式调用schedule()或被阻塞，此时也是可以被抢占的；

- **SCHED_RR**和**SCHED_FIFO**都代表进程是实时进程，用优先级来区分优先。RR的进程在同优先级的进程中时间片轮转，而FIFO的进程必须等前一个进程执行完毕才可执行下一个进程。
- 实时进程的优先级分为1~99；
- 实时进程不会过期，调用yield只会被放入到优先级队列的末尾；

## 第5章 系统调用

- 系统调用在出现错误时会把错误码写入errno全局变量。调用perror可以把该变量翻译成用户可以理解的字符串；

- 系统调用有个表，将系统调用号映射到对应的系统调用函数；

  ```assembly
  MOV EAX, 8
  INT 80	
  ```

  INT80就是触发软中断，中断处理程序是system_call，EAX中的值存的就是系统调用号

- 对于普通进程来说TGID和PID相同；

## 第6章 内核数据结构

- Linux中的标准链表就是环形双向链表；

P108