## 7.1 中断

中断是由硬件产生的异步中断，异常是处理器本身产生的同步中断。

每个中断请求IRQ都关联到一个值，又称**中断请求线**（中断线），例如IRQ 0是时钟中断，IRQ 1是键盘中断。



## 7.2 中断处理程序

中断处理程序运行在**中断上下文**。第128号中断"INT 0X80"的处理程序就是system_call()。

最起码的，中端处理程序要负责通知硬件设备中断已被接收。



## 7.3 上半部与下半部的对比

因为想中断处理程序运行得快，又想中断处理程序完成的工作量多。因此把**中断处理**分为两个部分。**中断处理程序**是**上半部**，接收到一个中断，立即开始执行，但是只做例如进行应答或复位硬件的简单工作。能够被允许稍后完成的工作会推迟到**下半部**去。（第7章主要关注上半部）



## 7.4 注册中断服务程序

```c
int request_irq(unsigned int irq,
               irq_handler_t handler,
               unsigned long flags,
               const char *name,
               void *dev);
```

其中：

- irq是中断号（中断线）
- handler是处理函数
- flags有如下几种：
  - IRQF_DISABLED：该标准代表在此中断处理程序期间，禁止所有的其它中断；
  - IRQF_SAMPLE_RANDOM：代表此中断源可以为“熵池”贡献；
  - IRQF_TIMER：代表此中断是系统定时器的中断；
  - IRQF_SHARED：代表是共享中断处理程序；（共享中断程序一般是由于一根中断线上连接了多个设备，共用一个中断号）
- name一般就是设备名，例如“keyboard”

- dev用于共享中断程序，代表这是给那个中断线上哪台设备注册的中断服务程序；



释放中断处理程序：

```c
void free_irq(unsigned int irq, void *dev);
```

- irq是中断号；
- dev是在共享中断号的情况下，指明注销的是哪个设备的中断服务程序；

当一个中断号对应的所有中断服务程序都被释放掉后，该中断线也被禁用。



## 7.5 编写中断处理程序

```c
static irqreturn_t intr_handler(int irq, void *dev);
```

dev是引发中断的那个设备，如果该设备并不是此handler注册时的那个设备，则会返回IRQ_NONE，否则代表该中断服务程序被正确调用，返回IRQ_HANDLED。

如果一个中断线上所有设备的中断服务程序都返回IRQ_NONE，那内核就可以检测到出了问题。



中断处理程序无需是可重入的，因为在执行此中断程序时，**同一中断线上**的其它中断将被暂时屏蔽掉，因此不会出现嵌套中断。



内核接收一个中断后，将依次调用在该中断线上注册的每一个处理程序。



## 7.6 中断上下文

中断上下文与current宏不相干，但current仍然指向被中断的进程。

中断上下文不可以睡眠，因此中断处理函数中不能调用可能睡眠的函数。

中断处理程序打断了其他代码，因此需要尽可能地快。把繁重任务交给下半部来执行。

早期中断处理程序使用的栈是被中断进程的内核栈，2.6版本之后使用的是每个CPU一个的中断栈。



## 7.7 中断处理机制的实现

有个中断控制器，相关中断信号都发给这个中断控制器，控制器会对中断信号进行检查，如果中断信号没被屏蔽，则控制器会向CPU的特定管脚发送一个信号，在下次中断周期时就会发生中断。

发生中断后，中断号保存在栈中，内核调用``do_IRQ()``，该函数提取出中断号，然后再获取到对应的``handler()``进行处理。



## 7.8 /proc/interrupts

就是说/proc/interrupts保存了当前主机上的各个中断的中断号、中断次数等信息。



## 7.9 中断控制

禁止和激活当前CPU的中断（不推荐使用）：

```c
local_irq_disable();
local_irq_enable();
```

禁止和恢复中断：

```c
unsigned long flags;
local_irq_save(flags);
local_irq_restore(flags);	//这俩函数必须在同一个函数中进行
```

禁止指定中断线（共享中断线不应该用这套函数）：

```c
disable_irq(irq);			//等待当前正在执行的所有处理程序完成后才返回
disable_irq_nosync(irq);	//立即返回
```

恢复中断线：

```c
enable_irq(irq);
```

注意调用了n次disable_irq或disable_irq_nosync，就要相应地调用n次enable_irq才行，最后一次才重新激活了。



等待某个中断线上的处理程序完成：

```c
synchronize_irq(irq);
```



中断系统的状态：

```c
irqs_disable();	//本地CPU中断系统是否被禁止
in_interrupt();	//如果在中断处理程序，或者在中断处理的下半部，则返回非0
in_irq();		//如果在中断处理程序，则返回非0
```

