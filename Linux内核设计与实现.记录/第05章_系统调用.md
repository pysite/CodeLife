## 5.1 与内核通信

在Linux中，系统调用是用户空间访问内核的唯一手段。

**设备文件**或者**/proc**之类的方式，最终也还是要通过系统调用进行访问。

## 5.2 API、POSIX、C库

用户程序使用API，API基于系统调用实现。

POSIX是一套API。

C库包含API和系统调用。



## 5.3 系统调用

系统调用get_pid()在内核中被定义为sys_getpid()，这是一种规则。

每个系统调用都有个系统调用号。



## 5.4 系统调用处理程序

用户程序通过软中断告诉内核需要执行一个系统调用（``int $0x80``）。导致系统指向第128号异常处理程序``system_call()``。系统调用号需要先存到eax中。函数参数通过寄存器传递。

## 5.5 系统调用的实现

Linux使用``SYSCALL_DEFINE3(...)``来定义一个具有3个参数的系统调用，``SYSCALL_DEFINE0``就定义的是一个具有0个参数的系统调用。

系统调用函数中用例如``capable(CAP_SYS_REBOOT)``来检测用户是否具有某种权限。



## 5.6 系统调用上下文

系统调用在执行时，current指针指向的是原来那个引发系统调用的进程。

进程在内核态时如果可以被抢占，要注意系统调用的可重入性。



假设我们自己新建了个系统调用``long sys_foo(int a)``，则想要在用户C代码中直接调用的话需要如下：

```c
#define __NR_foo 283 //这个283是系统分配的调用号
__syscall1(long, foo, int, a) //一个宏，分别传入类型和名称（返回值第一个）
    
//之后就可以直接调用foo
int sss = foo(666);
```



通常情况下不要自己创建系统调用，因为没人会用你写的系统调用。替代方法是实现一个设备节点，并对此实现read()和write()，使用ioctl()对特定的设置进行操作或者针对特定的信息进行检索。