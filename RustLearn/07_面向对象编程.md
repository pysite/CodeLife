# 面向对象编程

- Rust其实不算是完整的OOP语言，没有继承关系

- 方法的封装

  Rust支持对象的概念，即可以为一些结构体设计专门的"类函数"

  1. 这种"类函数"只在``impl``关键字的实现块中定义

  2. 每个"类函数"第一个参数必然是self

     ``&self`` —— 对实例的不可变引用

     ``&mut self`` —— 对实例的可变引用

  ```rust
  struct SeaCreature{
      noise:String
  }
  // 定义SeaCreature的方法
  impl SeaCreature{
      // 第一个参数毕是self
      fn get_sound(&self) -> &str {
          &self.noise
      }
  }
  
  fn main(){
      let creature = SeaCreature{
          noise:String::from("blub"),
      };
      // 用.调用类方法
      println!("{}",creature.get_sound());
  }
  ```

- 抽象与选择性隐藏

  默认情况下，字段和方法只有它们所属的模块才可访问。

  ``pub``关键字可以将字段和方法暴露给模块外的访问者。

  PS：一个Rust文件就是一个模块，因此上面的代码中没有加pub关键字也能调用函数，因为在同一个模块里。

- 使用Trait实现多态

  Trait就是一套抽象接口，可以为不同的类实现各自的trait。

  ```rust
  // SeaCreature还是上面那样
  
  // 定义接口
  trait NoiseMaker{
      fn make_noise(&self);
  }
  // 为一个类实现一套接口，之后这个类的对象就可以调用这套接口中的函数了
  impl NoiseMaker for SeaCreature{
      fn make_noise(&self){
          println!("{}",&self.get_sound());
      }
  }
  
  fn main(){
      let creature = SeaCreature{
          noise: String::from("blub")
      };
      creature.make_noise();	// 调用接口里的函数
  }
  ```

-  Trait自带方法

  Trait可以有已经实现的方法，但这些函数不能直接访问结构体的内部字段。

  ```rust
  // SeaCreature还是上面那样
  
  // 定义接口
  trait NoiseMaker {
      fn make_noise(&self);
      
      // 接口自带已实现函数
      fn make_alot_of_noise(&self){
          self.make_noise();
          self.make_noise();
          self.make_noise();
      }
  }
  
  impl NoiseMaker for SeaCreature {
      fn make_noise(&self) {
          println!("{}", &self.get_sound());
      }
  }
  
  fn main() {
      let creature = SeaCreature {
          noise: String::from("blub"),
      };
      creature.make_alot_of_noise();
  }
  ```

- Trait继承

  ```rust
  // SeaCreature还是上面那样
  
  // 父接口
  trait NoiseMaker{
      fn make_noise(&self);
  }
  
  // 子接口
  trait LoudNoiseMaker:NoiseMaker{
      fn make_alot_of_noise(&self){
          self.make_noise();
          self.make_noise();
          self.make_noise();
      }
  }
  
  impl NoiseMaker for SeaCreature {
      fn make_noise(&self) {
          println!("{}", &self.get_sound());
      }
  }
  
  impl LoudNoiseMaker for SeaCreature {}
  
  // 貌似要实现子接口，必须先实现父接口，且不能直接在子接口里实现父接口的函数（必须分开实现，我测试过）
  fn main() {
      let creature = SeaCreature {
          noise: String::from("blub"),
      };
      creature.make_alot_of_noise();
  }
  ```

- 动态调度和静态调度

  静态调度就是类对象直接调用其函数。

  动态调度就是trait对象调用其函数。动态调度肯定比静态调度更慢。

  ```rust
  // SeaCreature还是上面那样
  
  // 简单的接口
  trait NoiseMaker{
      fn make_noise(&self);
  }
  
  impl NoiseMaker for SeaCreature{
      fn make_noise(&self){
          println!("{}",&self.get_sound);
      }
  }
  
  fn static_make_noise(creature:&SeaCreature){
      creature.make_noise();	// 静态调度，因为知道真实类型
  }
  
  fn dynamic_make_noise(creature:&dyn NoiseMaker){
      creature.make_noise();	// 动态调度，因为是个抽象类型
  }
  ```

- Trait对象

  上面代码中 ``&dyn NoiseMaker`` 这种 ``&dyn Trait名`` 格式的对象就是Trait对象。

- 处理未知大小的数据

  方法1. （泛型）将数据类型也作为参数传进来，因此大小变成已知的

  方法2.  将数据放在堆上，因此不必担心实际类型的大小，只需存储一个指向它的指针。

- 泛型函数

  ```rust
  // SeaCreature以及NoiseMaker同上
  
  // 创建泛型函数<T>，其中用where语句来限制哪些类型可以传进来
  fn generic_make_noise<T>(creature: &T)
  where
  	T:NoiseMaker,
  {
      creature.make_noise();
  }
  
  fn main(){
      let creature = SeaCreature{
          noise:String::from("abc")
      };
      generic_make_noise(&creature);
  }
  ```

  泛型函数的简写

  ```rust
  // 下面这个和上面的generic_make_noise效果完全相同
  fn generic_make_noise(creature:&impl NoiseMaker){
      creature.make_noise();
  }
  ```

- Box

  Box就是智能指针，持有指向我们在堆上得数据的指针。

  Box可以将数据从栈上移到堆上。Box是一个已知大小的结构体。

  ```rust
  fn main(){
      // 先在栈上创建对象
      let ferris = SeaCreature{
          noise:String::from("aaa")
      };
      
      // 将栈上的对象移动到堆上
      let box_ferris = Box::new(ferris);
  }
  ```

  ```rust
  // 使用Box的结构体的是示例
  struct Ocean{
      animals:Vec<Box<dyn NoiseMaker>>,	// 注意这里不是引用&，因为Box就是要更改原来对象的拥有者
  }
  
  let ferris = SeaCreature {...};
  let sarah = SeaCreature {...};
  let ocean = Ocean{
      animals:Vec![Box::new(ferris), Box::new(sarah)],
  };
  ```

- 泛型结构体（重温）

  ```rust
  // 之前讲泛型结构体，没有涉及到where和impl块，这里再深入一下
  struct MyStruct<T>
  where
  	T:MyTrait	// 加where对传入进来的T进行限制
  {
      foo:T
      ...
  }
  
  // impl也要加<T>
  impl<T> MyStruct<T>{
      ...
  }
  ```

  