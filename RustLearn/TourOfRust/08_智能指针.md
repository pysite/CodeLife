# 智能指针

- Raw Pointer原始指针

  Rust中的引用&可以转为Raw指针，Raw指针可以看做是一种整型数据（可以转为整型也可以从整型转为Raw指针，和C中的指针非常类似）

  Raw指针要访问数据只能在Unsafe块中。

  ```rust
  // *const T 指向不可改数据的Raw指针
  // *mut T 指向可改数据的Raw指针
  let a = 42;
  let memory_location = &a as *const i32 as usize;	// 最后转为了整型数据
  println!("{}", memory_location);
  ```

- 解引用

  通过引用获取或改动数据被叫做解引用，

- The * Operator

  使用*来解一层的引用

  ```rust
  let a: i32 = 42;
  let ref_ref_ref_a: &&&i32 = &&&a;
  let ref_a: &i32 = **ref_ref_ref_a;
  let b: i32 = *ref_a;
  ```

- The . Operator

  使用.会自动解多层的引用

  ```rust
  let f = Foo{value : 42};
  let ref_ref_ref_f = &&&f;
  println!("{}", ref_ref_ref_f.value);
  ```

- 自定义解引用操作（重点）[参考网站](https://www.baidu.com/link?url=HGAUPiX-f1iVE4ymqcgI0VhKCxYqe3qrg3WpCzW48lQ1E13qgyqop9lZdrpn9T3Scl1m6CJFQ4TjcthD3s9LEgMiNs-Ftaqt6umgsvssXCdea6A36EC_3O8crwmLC_0u&wd=&eqid=91859eeb0003d8d200000003613431b0)

  我们可以为一个类自定义解引用的操作，实现标准库中的std::ops::Deref和std::ops::DerefMut这两个 trait。

  Deref的定义如下所示，DerefMut的唯一区别是返回的是&mut型引用，都是类似的，因此不过多做介绍了。

  ```rust
  pub trait Deref{
      type Target: ?Sized;
      fn deref(&self) -> &Self::Target;
  }
  
  pub trait DerefMut:Deref{
      fn deref_mut(&mut self) -> &mut Self::Target;
  }
  ```

  `Deref` 神奇的地方并不在本身 `解引` 这个意义上，Rust 的设计者在它之上附加了一个特性：`强制隐式转换`，这才是它神奇之处。

  这种隐式转换的规则为：

  - 一个类型为 `T` 的对象 `foo`，如果 `T: Deref<Target=U>`，那么，相关 `foo` 的某个智能指针或引用（比如 `&foo`）在应用的时候会自动转换成 `&U`。

  - Rust 编译器会在做 `*v` 操作的时候，自动先把 `v` 做引用归一化操作，即转换成内部通用引用的形式 `&v`，整个表达式就变成 `*&v`。

  我们再来看下面的代码做实际讲解：

  ```rust
  use std::ops::Deref;
  struct TattleTell<T> {
      value: T,
  }
  impl<T> Deref for TattleTell<T> {
      type Target = T;
      fn deref(&self) -> &T {
          println!("{} was used!", std::any::type_name::<T>());
          &self.value
      }
  }
  fn main() {
      let foo = TattleTell {
          value: "secret message",
      };
      // dereference occurs here immediately 
      // after foo is auto-referenced for the
      // function `len`
      println!("{}", foo.len());	
      // 上面句子发生了什么？
      // 1.foo.len()首先会统一变为(*&foo).len()
      // 2.而由于Foo的Deref的target是str，因此这里就是(*&str).len()，因此可以调用
  }
  ```

- Smart Unsafe Code

  就是说在解引用一个Raw指针时要在Unsafe块中

  ```rust
  fn main() {
      let a: [u8; 4] = [86, 14, 73, 64];
      // this is a raw pointer. Getting the memory address
      // of something as a number is totally safe
      let pointer_a = &a as *const u8 as usize;
      println!("Data memory location: {}", pointer_a);
      // Turning our number into a raw pointer to a f32 is
      // also safe to do.
      let pointer_b = pointer_a as *const f32;	// 将Raw指针转换回指针
      let b = unsafe {
          // This is unsafe because we are telling the compiler
          // to assume our pointer is a valid f32 and
          // dereference it's value into the variable b.
          // Rust has no way to verify this assumption is true.
          *pointer_b
      };
      println!("I swear this is a pie! {}", b);	// 3.1415
  }
  ```

- Layout和Alloc

  Rust中要申请一片内存，首先要创建好内存布局Layout，Layout需要两个参数size和alignment，alignment必须是2的幂（代表怎么对齐）。创建好Layout后再调用alloc函数真正申请内存。

  ```rust
  use std::alloc::{alloc, Layout};
  use std::ops::Deref;
  
  struct Pie {
      secret_recipe: usize,
  }
  
  impl Pie {
      fn new() -> Self {
          // 先创建内存布局，4字节大小，按1字节对齐
          let layout = Layout::from_size_align(4, 1).unwrap();
  
          unsafe {
              // 再申请内存并转换为u8的可变指针
              let ptr = alloc(layout) as *mut u8;
              // 一字节一字节地赋值
              ptr.write(86);
              ptr.add(1).write(14);
              ptr.add(2).write(73);
              ptr.add(3).write(64);
  
              Pie { secret_recipe: ptr as usize }
          }
      }
  }
  impl Deref for Pie {
      type Target = f32;
      fn deref(&self) -> &f32 {
          // 将里面的usize数据转换为一个raw指针，指向的数据类型为f32
          let pointer = self.secret_recipe as *const f32;
          // 将raw指针指向的数据取出
          unsafe { &*pointer }
      }
  }
  fn main() {
      let p = Pie::new();
      println!("{:?}", *p);
  }
  ```

- Box

  Box也是一种智能指针，指向存放在堆上的数据

  ```rust
  struct Pie;
  
  impl Pie {
      fn eat(&self) {
          println!("tastes better on the heap!")
      }
  }
  
  fn main() {
      let heap_pie = Box::new(Pie);	// 自动推断得到Box<Pie>类型
      heap_pie.eat();
  }
  ```

- Error

  对于可能出现Error的函数，我们都应返回Result结构体作为返回值（回顾：Result里有Ok和Err两种）

  Rust中为错误有一个统一的(trait)接口``std::error::Error``，如果用Box将其包装就更吊。

  ```rust
  use core::fmt::Display;	// 这个不太重要，实现了这个trait的对象貌似就可以通过prinln!("{}")打印出来
  use std::error::Error;
  
  struct Pie;
  
  #[derive(Debug)]
  struct NotFreshError;
  
  impl Display for NotFreshError {
      fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
          write!(f, "This pie is not fresh!")
      }
  }
  // 这个必须要实现，让我们自定义的结构体成为真正的Error类型
  impl Error for NotFreshError {}
  
  impl Pie {
      fn eat(&self) -> Result<(), Box<dyn Error>> {
          Err(Box::new(NotFreshError))
      }
  }
  
  fn main() -> Result<(), Box<dyn Error>> {
      let heap_pie = Box::new(Pie);
      heap_pie.eat()?;
      Ok(())
  }
  ```

- Referencing Counting

  Rc指针应该就是C++中智能指针的共享指针，就是指针内部有一个计数器，只有最后一个指针被释放掉，里面的数据才真正地被释放掉

  ```rust
  use std::rc::Rc;
  
  struct Pie;
  
  impl Pie {
      fn eat(&self) {
          println!("tastes better on the heap!")
      }
  }
  
  fn main() {
      let heap_pie = Rc::new(Pie);
      let heap_pie2 = heap_pie.clone();
      let heap_pie3 = heap_pie2.clone();
  
      heap_pie3.eat();
      heap_pie2.eat();
      heap_pie.eat();
  
      // all reference count smart pointers are dropped now
      // the heap data Pie finally deallocates
  }
  ```

  经过实际测试每个Rc对象``Rc<Pie>``可以独立将所有权让出去（传参进函数），即可以把每个``Rc<Pie>``看做独立的Pie（当然肯定是不可以修改内部值的）

- RefCell

  RefCell的对象可以变换为mutable也可以是immutable的。但是只能同时是一种状态：

  **Only one mutable reference OR multiple immutable references, but not both!**

  ```rust
  use std::cell::RefCell;
  
  struct Pie {
      slices: u8
  }
  
  impl Pie {
      // 像这种类函数会修改类属性的，也必须是在对象是mut的情况下才可以调用
      fn eat(&mut self) {
          println!("tastes better on the heap!");
          self.slices -= 1;
      }
  }
  
  fn main() {
      // RefCell validates memory safety at runtime
      // notice: pie_cell is not mut!
      let pie_cell = RefCell::new(Pie{slices:8});
      
      {
          // but we can borrow mutable references!
          let mut mut_ref_pie = pie_cell.borrow_mut();
          mut_ref_pie.eat();
          mut_ref_pie.eat();
          
          // mut_ref_pie is dropped at end of scope
      }
      
      // now we can borrow immutably once our mutable reference drops
       let ref_pie = pie_cell.borrow();
       println!("{} slices left",ref_pie.slices);
  }
  ```

- ### Box, Rc, RefCell作用和区别：

  **作用**：

  Box<T>：通过Box<T>指针可以在堆上分配数据。

  Rc<T>： 通过Rc<T>指针可以共享数据。Rust语言因为有所有权的概念，所以，数据失去了所有权之后，后面就无法使用该数据，而Rc<T>就是解决此类问题的。而Rc<T>指针指向的值是只读性质的，不能够修改。

  RefCell<T>：通过RefCell<T>指针可以改变**不可变**的值。Rust一般变量定义为immutable的时候，是不能修改其值的，但是，RefCell<T>指针能做到。

  **区别**：

  1. Rc<T> 同样的数据有多个拥有者，Box<T> 和 RefCell<T> 同样的数据只有唯一的拥有者；

  2. Box<T>数据的可变或者不可变的借用的检查发生在编译阶段，Rc<T>不可变的借用的检查发生在编译阶段，RefCell<T>不可变或者可变的借用发生在运行阶段
  
  3. 由于RefCell<T>可变借用的检查发生在运行阶段,，即使RefCell<T>定义的是不可变的，你也可以改变RefCell<T>里面定义的值。

- Mutex

  Mutex也算是个智能指针，某一时刻只允许一个线程访问某一数据。访问前必须锁定数据，访问后必须释放数据。

  ```rust
  use std::sync::Mutex;
  
  // deadlock example
  fn main() {
      let a=Mutex::new(0);
      let b=a.lock().unwrap();
      let c=a.lock().unwrap();	// 在这里卡死，因为b还未释放
      println!("{}",*b);
  }
  ```

- Arc

  > Arc就是Rc的线程安全版，里面引用计数操作是改用了原子操作进行记数的。

  如何线程间的安全使用同一对象，Arc<T> 提供了一个不错的方案。

  Arc<T>共享T的所有权，同一堆空间。调用clone后，产生一个新指针指向这个堆空间中的同一个值。

  当给定值最后一个Arc指针销毁后，这堆内存也将被回收。

  默认情况下共享引用是不允许mut的，如何想mut可以考虑使用Mutex,RwLock。

- 智能指针的联合使用

  > Rc<T>或者Arc<T>里面的T只可读；
  >
  > 但Rc<RefCell<T>>里面的T就可读可写；
  >
  > Arc<Mutex<T>>常用于多线程之间的同步数据；
  >
  > PS：像类似Rc<Mutex<T>>这种，T想调用Mutex的lock还是T想调用Rc的clone，都只需要用.直接调用即可。

