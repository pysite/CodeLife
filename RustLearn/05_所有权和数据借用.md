# 所有权和数据借用

> 很多语言默许我们写出“内存不安全”的代码，这也就会更容易产生bug。比如像下面这些：
>
> - **悬垂指针(Dangling pointers)**: 指向无效数据的指针（当我们了解数据在内存中如何存储之后，这个就很有意义）。
> - **重复释放(Double frees)**: 试图对同一块内存地址释放两次，这会导致“未定义行为”。 
>
> 如果你想知道当你在用像JavaScript或者Python这样的语言编写程序时是怎么解决这个问题的，那是因为这些语言都有垃圾回收机制。这意味这些语言会在运行时带着一个程序，这个程序会遍历内存然后释放所有不会再用到的东西。这样的程序叫做垃圾回收器（Garbage Collector）。虽然有垃圾回收器听起来很美好，但是想想也知道这也要付出一定的代价。因为垃圾回收器是在你的程序运行时工作的，所以这一定会影响程序的整体性能。
>
> Rust没有垃圾回收器，取而代之的是，它使用所有权和借用来解决保证内存安全的问题。当我们说Rust是内存安全的，我们是指，在默认情况下，Rust的编译器根本不允许我们写出内存不安全的代码。这是多么酷！

Rust的关键特色就是所有权，关键在于保证一个值只被一个变量拥有。

Rust在进行类似赋值或者给函数传值的行为时，Rust把值移动给了新的拥有者。

借用不会改变值的拥有者。借用就是&引用，引用可以看做传统语言中的指针变量。

函数参数不加&就是改变原变量的拥有者。

- 所有权

  ```rust
  struct Foo{
      x:i32,
  }
  // 实例化一个类型将其绑定到具体变量上，来创建内存资源，foo就是所有者
  let foo = Foo {x:42};
  ```

- 基于域的资源管理

  ```rust
  // 资源在最后被使用的位置或者一个函数域的结束来作为资源被析构和释放的地方
  // 此处析构和释放的概念被称之为drop(丢弃)
  let foo = Foo{x:42};
  println!("{}",foo.x);
  // foo将在这里被dropped，因为其在这之后再也没有被使用
  ```

- 释放是分级进行的

  ```rust
  // 删除一个结构体时，结构体本身会先释放，然后才是释放相应的子结构体并以此类推
  // Rust通过自动释放内存来帮助减少内存泄漏
  // 每个内存资源仅被释放一次
  ```

- 移交所有权（难点）

  ```rust
  // 将所有者作为参数传递给函数时，其所有权将移交至该函数的参数。
  // 在一次移动后，原函数中的变量将无法再被使用。
  
  // 内存细节：在移动期间，所有者的堆栈值将会被复制到函数调用的参数堆栈中
  fn func(v:Foo){
      println!("{}",v.x);
      // v在这里被dropped释放
  }
  
  fn main(){
      let v = Foo{x:42};
      func(v);
      // 此后v便无法再被使用
  }
  ```

- 归还所有权

  ```rust
  fn func() -> Foo{
      Foo{x:42}
  }
  
  fn main(){
      let v = func();
      // v成为了所有者
      // v在函数末尾被dropped释放
  }
  ```

- 使用引用借用所有权

  引用允许我们通过&操作符来借用对一个资源的访问权限，引用也会如同其他资源一样被释放。

  ```rust
  fn main(){
      let foo = Foo{x:42};
      let f = &foo;
      println!("{}", f.x);
      // f在这里被释放
      // foo在这里被释放
  }
  ```

- 通过引用借用可变所有权

  可以用``&mut``借用对一个资源的可变访问权限，在发生了可变借用后，一个资源的所有者便不可以再次被**借用**或者**修改**。

  内存细节：

  Rust之所以要避免同时存在两种可以改变所拥有变量值的方式，是因为此举可能会导致潜在的数据争用。

  ```rust
  fn func(f:Foo){
      println!("{}",f.x);
  }
  
  fn main(){
      let mut foo = Foo{x:42};
      let f = &mut foo;
      // 在f被dropped之前都不可以再去用foo了，包括直接打印foo.x也不行
      
     	// func(foo); 会报错
      
      f.x = 13;	// f在这之后被释放，因此下面又可以再用foo了
      
      foo.x = 24;
  }
  ```

  **注意**：&符号只是借用权限，并不是更改所有者，上述f的类型是&mut Foo，不可以直接当参数调用func，因此下面句子是会报错的（无论位置），传参必须是所有者才能拿来传参。

  ```rust
  func(f);	// 会报错
  ```

- 解引用

  用*解引用

  ```rust
  // 这个怎么理解呢，可以把解引用当作找到替身背后的真正主人
  let mut foo = 42;
  let f = &mut foo;	// f是foo的替身
  let bar = *f;		// 获得所有者值的拷贝
  *f = 13;			// 设置引用所有者的值
  println!("{}", bar);	// 42
  println!("{}", foo);	// 13
  ```

  **注意**：这里不可以 f = 13（必须 *f = 13），Rust中的引用& 感觉还是可以理解成C++中的取地址；

- 传递借用的数据

  1. Rust只允许同时存在一个可变引用或者多个不可变引用，不允许可变引用和不可变引用同时存在。
  2. 一个引用永远也不会比它的所有者存活得更久。

  ```rust
  fn do_something(f:&mut Foo){
      f.x+=1;
      // f在这里释放
  }
  
  fn main(){
      let mut foo = Foo{x:42};
      do_something(&mut foo);
      // 这里将可变引用传入do_something后又在里面被删除了
      // 因此下面我们可以再创建一个
      do_something(&mut foo);
      // foo在这里被释放
  }
  ```

- 引用的引用

  ```rust
  fn do_something(v: &Foo) -> &i32{
      return &v.x;
  }
  
  fn main(){
      let mut foo = Foo {x:32};
      let x = &mut foo.x;
      *x = 13;
      // x在这里被释放因此我们可以再创建一个不可变引用
      let y = do_something(&foo);
      println!("{}", y);
      // y在这里被释放
      // foo在这里被释放(foo才是拥有者)
  }
  ```

- 显示生命周期（说实话没怎么搞明白，略懂）

  大概意思就是给参数打一些注解以表明哪些参数和返回值共享同一周期（方便编译器进行生命周期推断）

  拓展：

  生命周期只是为了帮助编译器的，不会对变量的生命周期造成任何实质影响（？存疑，'staic 貌似会有点影响）。仍然是为了内存安全，例如两个变量a和b，其中b的作用域比a小（a更长寿），一个函数func返回两个变量中的某个值，此时如果不加生命周期注解就会报错，因为Rust担心函数的返回值作用域比传入进来的某个参数的作用域更大了（这就会导致出错，即原来的那个地方在堆或者栈中离开域的时候就被释放，而函数的返回值还引用着它就会内存出错）。

  加个生命周期注解只是告诉编译器，要求检查标签相同的变量的lifetime是否相同（作用域大小）。

  ```rust
  // 生命周期注解总是以'开头，例如'a, 'b, 'c
  // 函数名后面的<'a>是声明lifttime name，是必须的
  fn do_something<'a>(foo:&'a Foo) -> &'a i32{
      return &foo.x;
  }
  
  fn main(){
      let mut foo = Foo{x:42};
  	let y = do_something(&foo);
      // y在这里被释放
      // foo在这里被释放
  }
  ```

- 多个生命周期（lifetime name）

  多个生命周期注解可以通过区分函数签名中不同部分的生命周期，来允许我们显式地明确某些编译器无法解决的场景。

  ```rust
  // 注意：生命周期注解只是告诉编译器进行相应的检查，并不对变量的周期产生实际的效果
  // foo_b和返回值一个周期
  // foo_a则随便周期
  fn do_something<'a, 'b>(foo_a:&'a Foo, foo_b:&'b Foo) -> &'b i32{
      return &foo_b.x;
  }
  
  fn main(){
      let foo_a = Foo{x:1};
      let foo_b = Foo{x:2};
      let x = do_something(&foo_a, &foo_b);
      // foo_a在这里就GG了, 因为后面没用到foo_a相关的
      println!("{}", x);
      // x被释放
      // foo_b被释放
  }
  ```

- 静态生命周期

  静态生命周期标签就是告诉编译器说后面的那个值是一直存活的（一个静态生命周期是指一段内存资源）

  PS：'static 可以由编译器自动推断，在这里只是明确告诉编译器让它帮忙检查一下是否真的是'static

  ```rust
  static PI:f64 = 3.14159;
  fn main(){
      // 静态变量的范围也可以被限制在一个函数内
      static mut SECRET:&'static str = "abc";
      
      // 字符串字面值拥有 'static 生命周期
      let msg:&'static str = "hello";
      let p:&'static f64 = &PI;
      
      // 你可以打破一些规则，但是必须是显式地
      unsafe {
          // 我们可以修改 SECRET 到一个字符串字面值因为其同样是 'static 的
          SECRET = "abracadabra";
          println!("{}", SECRET);
      }
      
  }
  ```

  

- 数据类型中的生命周期

  在数据类型中加生命周期标签，方便编译器进行生命周期的推断。

  作用：Rust验证整个结构体的生命周期一定不比里面的成员获得更长。否则里面的数据都释放了，这个结构体还没释放就会有问题。

  下面的代码是表示Foo和成员i的周期相同。

  ```rust
  // 用<>声明有哪些生命周期
  struct Foo<'a>{
      i:&'a i32
  }
  
  fn main(){
      let x = 42;
      let foo = Foo{
          i:&x;
      }
      println!("{}", foo.i);
  }
  ```

  
