## Const

- 常对象只能调用其常成员函数

- this是个右值，不能&this

## inline内联函数

- **函数定义时，在返回类型的前面加上关键字inline**即把函数指定为内联，函数声明时可加也可不加inline关键字。但是，建议在函数声明的时候也加上inline
- inline就是C++中函数专属的宏
- inline相当于宏，却比宏多了类型检查，真正具有函数特性
- 类声明中的函数，除了virtual，其它都是inline
- 内联函数在运行时可调试，而宏定义不可以（**不确定**）
- 如果f函数采用内联方式编译，那么调用者就会把函数实体复制到调用处，一旦函数库发生了改变，就需要重新编译
- inline只是个建议，编译器可能不采用

## virtual与inline

- inline可以修饰virtual，但是只有当编译器知道对象是哪种类型时才可，比如如果是个指针或引用就不行。

- 有虚析构函数，在调用某个基类指针时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数。
- volatile的变量每次是从内存而非寄存器中取值。

## assert

- 断言，是宏而非函数。定义``#define NDEBUG``会使assert不可用。

- sizeof 对数组，得到整个数组所占空间大小。sizeof 对指针，得到指针本身所占空间大小。
- `extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理
- \#pragma pack(push)  // 保存对齐状态
- \#pragma pack(pop)   // 恢复对齐状态
- C++中，struct Student后就可以直接用Student了，不用像C中非要用struct Student，而且C++中此时如果定义一个名叫Student的函数，则才必须使用struct Student。
- C++中类是默认Private的

## union

- union就也是一种类，比较特殊而已
- 可以用构造函数和析构函数，不能含有引用成员
- 不能参与继承，因此也不能含virtual
- 匿名union所在作用域内可直接访问成员，不需要“类名.xxx”
- 匿名union必须全是public
- 全局匿名union必须是static
- 加了::这个符号就是优先访问全局静态匿名union中的成员

## 转换函数

- 转换函数就是``operator 类型()const{...}``的函数，可以让该类自动转换为这种“类型”

## explicit

- 一个类的构造函数如果**只有一个参数**或**只有一个参数没有默认值**，那么就可以有这种直接赋值的隐式转换操作：

  ```c++
  class A{
      A(int v){...}
  }
  A a = 10;	//有效
  ```

  但是加了explicit可以使这种隐式转换被关闭。

- ``(int)a``和``static_cast<int>(a)``这种都是显式转换

- 如果给转换函数加了explicit也是不能隐式转换了，比如

  ```c++
  if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
  bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
  ```

- 像``A a = 1``和``A a = {1}``就属于隐式转换的；但``A a{1}``这种列表初始化和``A a(1)``的就属于显式。

- ```c++
  class A:public B{
      using B::B;	//可以直接using父类的构造函数
  }
  //编译器会生成如下构造函数
  A(parms):B(parms)
  ```

- ``::name``表示的是全局变量

## enum

```c++
enum A{a,b,c,d};
A aa;
aa = a;
aa = 0;				//不可以，C语言可以
if(aa == 0){...}	//可以
```

- 如果是enum class这种，则enum里面的变量名的作用域就变成了class里面。单独enum，里面的变量名的作用域和enum相同。
- enum class的变量不能直接用int赋值，比较也不可以。
- C++中enum和int是两种类型。
- enum类型可以隐式转换成int（可以直接给int赋值），但不可逆转过来。
- typename 指出下面紧跟着的名称是一个类型（不仅用在模板的<>中）
- template<typename T>后面调用时也可以不显式地为T赋值，可以隐式推导。



看到decltype

