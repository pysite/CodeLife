### shazam算法

> 选自[CSDN](https://blog.csdn.net/yutianzuijin/article/details/21547573)

首先采用FFT快速傅里叶变换。这个地方有一个可调参数是每一帧的位移是多少，一般会选择10~40毫秒之间。变换之后会得到一个频谱图，如图二所示。频谱图是一个三维图，X坐标是时间，Y坐标是频率，Z坐标是能量。算法的第二步是从频谱图中提取一系列的landmark。Landmark就是频谱图中的一些能量峰值，如图2(a)中的黑点所示。选取landmark的规则不固定，根据不同的方法和参数选定的landmark也不同。但是可以通过控制参数调节每秒选取的landmark点数。第三步就是利用选定的landmark构造一系列指纹。构造指纹的方法很简单，根据shazam算法中描述，就是将两个landmark组合在一起。最后利用提取的指纹从指纹库中检索得到结果。


![img](./images/image00)

![img](.\images\image01)

Landmark是频谱图中的一系列能量极大值点。根据shazam论文，能量极大值点的抗噪能力很强。求法多种多样，目的就是在二维平面中寻找峰值。通过调节参数可以控制每秒选取的landmark个数。一般情况下每秒保留20~30个点即可。

指纹的构造方法和shazam算法一样。首先针对每一个landmark都有一个target zone。事实上，这个target  zone就是一个landmark构造指纹的范围，这个也是人为指定的。然后，将landmark和target  zone中的所有landmark两两组合，构成一个指纹。指纹由三部分构成：两个landmark的频率(频率不求差)和时间差。同时每个指纹都有一个对应的时间，也即landmark的时间，表示这个指纹出现的时刻。

如果我们是从原始音乐库构造指纹库，提取的指纹就放入指纹库。指纹库可以用散列表实现，每个表项表示相同指纹对应的音乐id和time。如果我们是检索音乐，则利用提取的指纹访问指纹库。 

![img](.\images\image02)

检索是算法的核心，生成的指纹通过检索指纹库即可返回要检索的歌曲。根据前面的描述，生成的指纹可以放入散列表中，每一个表项都是相同指纹对应的音乐数据。音乐数据包括：音乐的id和该指纹在该音乐中出现的时间。

有了指纹库，当从用户传递的音乐片段到达服务器之后，首先对该片段提取指纹，然后将所有的指纹与散列表中的指纹进行匹配。当找到匹配的指纹后，获得该指纹对应的音乐的id和该指纹在该音乐中出现的时刻time。然后将提取的指纹对应的time减去从指纹库中获得的time得到一个时间差。最后将这些id和时间差进行排序：id放在long型数据的高位，时间差放在long型的低位，排序后的结果就是针对每个id都有一系列的时间差。
    
Shazam算法然后依据这样一个假设选择结果：要检索的片段肯定来自于某一首完整音乐从某个时刻开始的片段，而它们的生成的指纹应该相同，则对应的时间差也应该相同。所以排序完了之后就寻找含有最多相同时间差的音乐id即可。
    
算法的整体流程如上面所述，但是具体实现可以有不同的方案，不同的参数也会导致指纹数目和检索准确率的不同，而这些都需要不停地调试。





### DTW算法

- 一种衡量两个长度不同的时间序列的相似度的方法

![img](.\images\image03)

- 采用动态规划的思想，

为了对齐这两个序列，我们需要构造一个n x m的矩阵网格，矩阵元素(i, j)表示qi和cj两个点的距离d(qi, cj)（也就是序列Q的每一个点和C的每一个点之间的相似度，距离越小则相似度越高。这里先不管顺序），一般采用欧式距离，d(qi,cj)=(qi−cj)2d(qi,cj)=(qi−cj)2（也可以理解为失真度）。每一个矩阵元素(i, j)表示点qi和cj的对齐。DP算法可以归结为寻找一条通过此网格中若干格点的路径，路径通过的格点即为两个序列进行计算的对齐的点。
![img](.\images\image04)

每一个格点的路径只有三个方向。起点是左下角，终点是右上角。

![img](.\images\image05)

我们定义一个累加距离cumulative distances。从(0, 0)点开始匹配这两个序列Q和C，每到一个点，之前所有的点计算的距离都会累加。到达终点(n, m)后，这个累积距离就是我们上面说的最后的总的距离，也就是序列Q和C的相似度。

累积距离γ(i,j)可以按下面的方式表示，累积距离γ(i,j)为当前格点距离d(i,j)，也就是点qi和cj的欧式距离（相似性）与可以到达该点的最小的邻近元素的累积距离之和：

![img](.\images\image06)

最佳路径是使得沿路径的积累距离达到最小值这条路径。这条路径可以通过动态规划算法得到。



### 电音制造中的DTW

即将.wav文件提取mfcc，以及mfcc的一阶差分和二阶差分数据，每一帧的mfcc、一阶差分（一阶差分就是当前帧的mfcc减去前一帧的mfcc）、二阶差分（二阶差分就是一阶差分的差分）拼接成一个特征向量代表该帧，然后两帧对应的特征向量之间的距离就用点之间的欧几里和距离表示。

