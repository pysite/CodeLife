> reliable分布式系统必须要考虑组件出故障时可能给不同的部件下发conflicting消息的情况。
>
> 拜占庭问题的场景：一群将领带领军队包围了一座城市，将领之间的通信只能靠小兵传递消息，然而在这群将领之中有叛徒，问题就是该如何设计算法使得所有忠诚的将领最后达成的计划是一致的。

## 1 Introduction

在拜占庭问题中，我们希望：

A. 所有余下的忠诚的将领能达成一致。

B. 小部分的叛徒不能影响忠诚的将领达成一致的最后结果。（不能让将领们达成bad plan的一致，就是说叛徒的决定是什么不影响最终的结果）



假设将领$$i$$发出的消息为$$v(i)$$，则每个将领得到的消息就是$$v(1),\dots,v(n)$$，如果这些消息对每个将领来说都一样，则只要每个将领采用相同的策略即可达成一致的决定。但由于叛徒的存在，每个将领得到的消息可能不同。为了满足条件A，需要满足：

1. 每个忠诚的将领所获取到的消息$$v(1),\dots,v(n)$$都应相同

因为叛徒可能给不同的将领发送不同的消息，因此我们不能直接认为从第$$i$$个将领获取到的消息就是$$v(i)$$。为了满足条件B，需要满足：

2. 如果第$$i$$个将领是忠诚的，那么他发送的消息就应该被用作最后的$$v(i)$$。

而条件1可以重新写成：

1. 任何两个忠诚的将领获得的消息$$v(i)$$是相同的。

因此接下来就可以将问题缩小至如何在单个将领的决定上（1个commanding general，其余是lieutenant general 副官），满足条件1和2。条件1和2也被称为interactive consistency。



## 2 Impossibility Results

就是说拜占庭问题要有解，必须是忠诚的将领超过3分之2（大于，而非大于等于），否则问题无解（作者在这里举了3个将领中有1个叛徒的例子来说明此问题无解，并且说如果读者想要这种无解理论的严格证明请查阅其它参考资料）。（当前只考虑oral message，也就是发送的数据完全由发送者决定的message，暂时不考虑那种带有signature的签名）

也可以推测出，小于3m+1个将领中如果有m个叛徒则无解。

也可以推测出，3个将领中有1个叛徒的条件下，即使是不达成精确的agreement，只希望达成模糊的agreement，也是不能的。同理，小于3m+1个将领中如果有m个叛徒，想要达成模糊的agreement也是不行的。

PS：模糊的agreement中的agreement是指"进攻的时间"和"撤退"，需要满足：（作者通过假设有一种方法能达成模糊agreement的话则通过一定的规则将进攻时间转换为attack or retreat，则这个方法也能用于精确的agreement，因为达成精确agreement的方法不存在，因此达成模糊agreement的方法也不存在）

1. 所有忠诚的将领发起进攻的时间都是在10分钟以内。
2. 如果发布指令的将领是忠诚的，则其它忠诚的将领在收到他的指令后进攻的时间也在10分钟以内。



## 3 A Solution With Oral Message

> 在3m+1个将领中最多m个叛徒的条件下，作者在这提出了自己的算法

首先oral message的定义如下：

1. 每个message都被正确地发送
2. message的接收者知道是谁发送的
3. message的丢失将被检测到

> 接下来的算法是假设每个将领可以直接给其它将领发送消息
>
> 一个叛徒commanding将领如果选择不发送任何消息的话，则其它lieutenant将领将会执行默认动作，在这里就是retreat

OM(m)算法（3m+1个将领中最多m个叛徒）：

假如0个叛徒，OM(0)：

1. commander发送消息给其它每个lieutenant；
2. 每个lieutenant如果收到commander的消息则使用这个消息，否则使用默认消息retreat；

假如m个叛徒（m>0），OM(m)：

1. commander发送消息给其它每个lieutenant；
2. 对于每个$$i$$，设$$v_i$$为第i个lieutenant收到的commander消息（如果没收到则是默认消息retreat）。有了消息后，这第i个lieutenant则变为commander采用OM(m-1)算法向其它n-2个lieutenant发送自己的这条消息（不向自己的commander再发消息）。
3. 于是乎，每个lieutenant都将会收到1个commander的消息，n-2个来自其它lieutenant的消息，$$v_1,\dots,v_{n-1}$$，lieutenant最终采用$$majority(v_1,\dots,v_{n-1})$$作为自己的消息。

> n个将领m个叛徒，则OM(m)会调用n-1次OM(m-1)算法，每个OM(m-1)算法会调用n-2次OM(m-2)算法，...



> 回顾那两个IC条件（interactive consistency）(满足这两个条件就算解决了拜占庭问题）：
>
> 1. All loyal lieutenants obey the same order.
> 2. If the commanding general is loyal, then every loyal lieutenant obeys the order he sends.
>
> 回顾message满足的那三个A条件：
>
> 1. Every message that is sent is delivered correctly.
> 2. The receiver of a message knows who sent it.
> 3. The absence of a message can be detected.

OM(m)算法正确性的证明（就是证明那两个条件被满足）：

引理1：对于任意的m和k，如果最多k个叛徒，共有超过2k+m个将领，OM(m)将满足条件IC2。

证明1：（对m进行归纳推理）

首先如果m=0，OM(0)在commander是忠诚的时候是满足IC2的（因为**A1**，且总人数n>2k+m=2k，即忠诚的超过50%）。接下来假设m-1时OM(m-1)已经满足**IC2**，当m时，总人数n>2k+m，则n-1>2k+m-1，因为m>0，则n-1>=2k，因此这剩下的n-1个将领中有超过50%的是忠诚的，因此对于每个人最后在统计majority的时候便拿到的是准确的commander的消息，因此满足**IC2**。

> 接下来证明OM算法可以解决拜占庭问题

定理1：对于任意m，OM(m)满足IC1和IC2，如果这里总将领数超过3m，且最多m个叛徒。

证明1：（也是对m进行归纳推理）

首先如果m=0，没有叛徒，则显然满足IC1和IC2。假设m-1时满足IC1和IC2，接下来证明当m时。首先如果commander是忠诚的，则由引理1（将k=m）可以知道满足IC2，同时也可以进一步得出满足IC1。而如果commander是叛徒，则外面还有n-1>3m-1个将领，其中m-1个叛徒。而3m-1>3(m-1)，因此可以说在外面这n-1个将领中满足OM(m-1)，因此在这n-1个将领中满足IC1和IC2。而在这n-1个将领中各自发出的消息在各个忠诚的将领那里都是相同的（因为满足IC1），即$$v_1,\dots,v_{n-1}$$都相同，因此在n时也满足IC1。（最后这点没看懂的话就去看一下论文中前面的n=4&m=1的例子就懂了）



## 4 A Solution With Signed Messages

如果将Oral Message改变为Signed Message，即叛徒无法再伪造消息。即我们在之前的Message的3个限制条件中增加第4条（A4）：

4. (a) commander的签名无法被伪造，任何对commander消息的修改都可以被检测到。(2) 接收者可以验证签名的正确性。

如果commander是叛徒的话，则允许其签名被其它叛徒伪造，意思就是允许叛徒互相勾结。（论文原话）

> 有了签名后，接下来介绍的算法便可以在m个叛徒，任意n(n>m)个将领的情况下满足IC1和IC2

首先介绍choice函数：（每个将领有自己的一个set $$V_i$$，里面是order，注意收到的message格式为$$order:0:i:\dots:j$$，其中假设0是commander。后面的i、j之类的是代表这条message被签名的顺序（最早是被commander签名）。如果commander是忠诚的话，照理来说$$V_i$$中只会有1个order，因为**忠诚commander的签名无法伪造，消息中的order无法更改**，如果$$V_i$$中有多个order的话反而说明commander是叛徒）

1. 如果set V只有一个元素v，则choice(V) = v
2. 如果set V为空集，则choice(V) = retreat

> 接下来介绍SM(m)算法，m是指有m个叛徒。
>
> 初始时每个将领自己的$$V_i$$为空集。

1. commander签名并发送消息给所有lieutenant
2. 对每个lieutenant（假设是第$$i$$个）：
   - 如果从commander收到$$v:0$$的消息，且**它还未收到任何消息**，则：
     - 使得$$V_i$$为$${v}$$；
     - 将$$v:0:i$$发送给其它lieutenant；
   - 如果从其它lieutenant收到$$v:0:j_1:\dots:j_{k}$$（这里的k只是代表被签名的次数而非将领的id），且v不在$$V_i$$中，则：
     - 往$$V_i$$中加入$$v$$；
     - 如果k<m（也就是一个消息中包含commander最多有m+1个签名，则将$$v:0:j_1:\dots:j_{k}:i$$发送给其他lieutenant（除开$$j_1:\dots:j_k$$）
3. 如果不再会收到任何消息（可以自己设计规则判断，例如超时机制），则choice($$V_i$$)将会是该将领服从的指令；



> 证明SM(m)算法的正确性

定理2：SM(m)可以解决最多m个叛徒的拜占庭问题

证明2：

首先假如commander是忠诚的，那么由于叛徒无法伪造其签名，自然就无法更改其中的指令，因此所有人最后的$$V_i$$中只会有一个$$v$$。自然满足IC2和IC1。

如果commander是叛徒，那么就需要证明任意两个忠诚lieutenant的最后的$$V_i$$和$$V_j$$是相同的，这样就能保证最后的choice($$V_i$$)结果相同。当$$i$$打算收到的消息$$v:0:j_1:\dots:j_k$$中的v存入自己的$$V_i$$时，

1. 如果$$j$$已经在$$j_1:\dots:j_k$$中，则j的$$V_j$$肯定已经有本条指令$$v$$了，因此$$V_i$$和$$V_j$$相同；

2. 如果$$j$$不在$$j_1:\dots:j_k$$中，则：
   - 如果k<m，则$$i$$此次操作完后会将这个消息转发给其它不在$$j_1:\dots:j_k$$中的lieutenant，因为$$i$$是忠诚的所以不会更改消息，因此最后$$j$$也有本条消息；
   - 如果k=m，则$$i$$此次操作完后不会再转发此条消息，但因为一共只有m个叛徒，除开commander还有m-1个叛徒，因此已经签名的$$j_1:\dots:j_k$$之中肯定有一个忠诚的，而有忠诚的人的签名则后面的叛徒就不能更改签名的消息了，因此$$j$$也会收到此次消息中的$$v$$；（论证完毕）

## 5 Missing Communication Paths

> 之前的假设中，都是认为每个将领可以直接给其它将领发送消息的，接下来将每个将领看作是node，能互发消息的两个将领就用一条边将这两个node相连，形成无向图。

节点$$i$$的集合$$\{i_1,\dots,i_p\}$$被称作节点$$i$$的p-regular集合，如果满足：

1. 每个$$i_j$$是$$i$$的邻居；
2. 对于每个不同于$$i$$的节点$$k$$，都能从这个邻居集合中找到一个$$i_j$$，存在不需要经过$$i$$的路径$$\gamma_{j,k}$$（这里的$$j$$其实就是$$i_j$$，且如果邻居集合不止这么一条路径到节点$$k$$，则不同路径之间只有一个公共节点$$k$$.

> 接下来介绍针对oral message的算法OM(m, p)，m是指m个叛徒，p是指令p-regular的图。这个算法可以解决m个叛徒，3m-regular情况下的拜占庭问题。

0. 设N为commander的邻居节点组成的集合（p个）
1. commander发送其指令给N中的每个lieutenant
2. 对于集合N中的每个lieutenant $$i$$，$$v_i$$是其收到的消息（如果没收到就是默认的retreat），
   - 如果m=1，则$$i$$会将这个消息转发给其它lieutenant $$k$$（除开commander），通过路径$$\gamma_{i, k}$$；
   - 如果m>1，则$$i$$会像自己变成commander那样，通过算法OM(m-1, p-1)在除去commander的图中发送消息；
3. 对于每个$$k$$，以及每个在集合N中的$$i$$（$$i\neq k$$），设$$v_i$$是$$k$$从$$i$$在第2步中收到的消息（如果没收到就是默认的retreat），采用$$majority(v_{i_1},\dots,v_{i_p})$$作为$$k$$最后服从的指令。其中$$N=\{ v_{i_1},\dots,v_{i_p} \}$$。（如果k是$$N$$中的一员，则其中自己那份消息就是自己从commander那里直接获得的消息。）（**相当于就是说每个lieutenant最后的执行的指令，就是commander的邻居集合所发送的消息的majority**）



> 接下来证明OM满足IC2的引理

引理2：对于任意m>0，任意$$p\ge 2k+m$$，如果最多k个叛徒，则OM(m, p)满足IC2条件。（回顾IC2：如果commander忠诚，则所有忠诚的部下其执行的指令和自己发出的相同）

证明2：

假如m=1，则$$p\ge 2k+1$$，所以在commander的邻居中$$N=\{ v_{i_1},\dots,v_{i_p} \}$$中有超过一半的是忠诚的，且每个接受到的消息都是通过互斥的路径传递过来的，因此在commander忠诚的条件下，最后的$$majority$$是正确的，故满足IC2。

假如m>1，且对于m-1已经满足IC2，现在证明对于m也满足IC2。因为$$p>2k$$，所以$$N$$中有超一半的忠诚将领，每个忠诚将领都采用OM(m-1, p-1)算法将自己的$$v_{i_j}$$消息传播出去，根据已有的假设m-1情况满足IC2，故这超一半的忠诚将领的消息都能成功传播，故m的情况也能满足IC2。



> 接下来证明OM(m, 3m)可以解决m个叛徒、3m-regular条件下的拜占庭问题
>
> （貌似regular大于等于3m都可以被解决，毕竟OM(m)算法就可以看作是全连接情况下的OM(m, n-1)算法）

定理3：对于任意m>0，任意$$p\ge 3m$$，OM(m, p)在最多m个叛徒的条件下满足IC1和IC2。（解决拜占庭问题）

证明3：

已经证明了引理2，因此在commander是忠诚的情况下是满足IC2的，因此也是满足IC1的。如果commander是叛徒，只需证明IC1：

假如m=1，则除了commander其余全是忠诚，因此满足IC1。

假如m>1，且m-1时已经满足了IC1，则当m时，由于$$p\ge 3m$$，则$$p-1\ge 3(m-1)$$，因此在commander邻居将领集合$$N$$中的每个将领的消息在传播时采用的OM(m-1, p-1)算法都能在忠诚将领那相同，因此最后的majority也相同，满足IC1。



> 在将OM(m)算法拓展成非全连接图中的OM(m, 3m)时，要求正则邻居集的数量至少为3m。但在将SM(m)拓展成非全连接的SM(m, x)时就不需要这么严格的要求了。

对于signed message，非全连接图的情况下拜占庭问题要有解的最低要求是：**所有忠诚将领节点组成的子图要是连通图，这样就可以通过原来的SM(n-2)算法解决该拜占庭问题**（其中n是将领总数，而无论叛徒的数量）。

> 设图的直径为d（该图中路径长度最长为d）

定理4：SM(m+d-1)算法可以解决**最多m个叛徒，所有忠诚将领组成的子图直径为d**条件下的拜占庭问题。（非连通图貌似没有直径这个概念）

证明4：

如果commander是忠诚的，因为子图直径为d-1，且$$m+d-1\ge d-1$$，故忠诚commander的消息可以传达到每个忠诚部下那里，又因为signed无法被篡改，故满足IC2，也因此满足IC1。

而如果commander是叛徒，只需要证明每个忠诚部下最后集合$$V_i$$都相同即可。假设忠诚部下$$i$$收到了一条消息$$v:0:j_1:\dots:j_k$$，且正要将这个v插入到自己的集合$$V_i$$中，对于另一个任意的忠诚部下$$j$$来说：

- 如果$$j$$在$$j_1,\dots,j_k$$中，则很显然j已经有$$v$$了。
- 如果j不在其中，则：
  - 如果k<m，则说明此条消息被$$i$$转发后还会传播至少d-1次，且因为忠诚的$$i$$已经在这上面签名了因此也无法被后来的人更改，故最终$$j$$也会收到$$v$$。
  - 如果$$k\ge m$$，则说明已经签名的前m个人当中肯定也有忠诚的人，这个人在转发时消息还至少能传播d-1次，因此$$j$$也会收到$$v$$。

因此在commander是叛徒的条件下，也满足IC1。证明完毕。



推论：如果忠诚将领组成的子图是连通的，将领总数为n，则SM(n-2)算法可以解决拜占庭问题。

证明：

假设忠诚将领子图的直径为d，则忠诚将领数量至少为d+1（直径是指边个数），因此叛徒的数量至多为n-d-1，令m=n-d-1，则利用定理4则可以推出本推论。

> 从上述定理4的证明中我们还可以推出在忠诚将领子图不是连通图时SM(m+d-1)算法也能保证的两点属性：
>
> 1. 任何两个连通的，且之间**只由忠诚将领组成的路径**长度至多为d的忠诚将领，其将会得到相同的消息；
> 2. 如果commander是忠诚的，则任何离他**只由忠诚将领组成的路径**长度最多m+d的忠诚将领将会得到正确的commander消息。



## 6 Reliable Systems

> 如何将之前的拜占庭算法和现实服务器系统联系起来

一个可靠的系统基本上就是靠redundant计算，然后voting出结果来实现的。

为了让voting可以维持一个可靠的系统，必须满足以下两条件：

1. 所有没故障的处理器必须使用相同的input；
2. 如果input单元没故障（提供数据的单元），则所有没故障的处理器可以用它提供的数据；

上面两个条件就类似拜占庭问题中的IC1和IC2，commander就是input单元，lieutenant就是processor。

即使是简单的让所有processors都从同一根wire上面接受input单元的信号，故障的input单元产生的也可能是某种"边缘信号"，例如一部分processors将其识别为0，另一部分将其识别为1。



> 回顾oral message满足的三个条件(A1-A3)，以及signed message额外满足的第四条件A4
>
> 1. Every message that is sent is delivered correctly.
> 2. The receiver of a message knows who sent it.
> 3. The absence of a message can be detected.
> 4. (a) commander的签名无法被伪造，任何对commander消息的修改都可以被检测到。(2) 接收者可以验证签名的正确性。

- A1条件

在现实中如果连接两个节点的线路出现故障，则消息就不能够被correctly deliver。线路出现故障和某个节点宕机效果相同。对于OM(m)算法来说，可以最多容忍m个线路故障或者m个节点宕机（连接同一个节点的多条线路故障等同于这个节点宕机）。对于SM(m)算法，我们规定宕机的节点不能够伪造消息，则SM(m)算法对线路故障、节点宕机容忍度是较高的，影响只不过是忠诚节点子图中的连接性而已。

- A2条件

A2条件在现实生活中就是说一个叛徒节点不能伪装成另一个正常工作节点。现实系统中如果采用专线连接每两个节点则可以很轻松地保证这一条件，而如果采用的是中心路由器（星型分布）就有可能出现这种问题。如果发送的是signed message，则满足A4条件可以自然满足A2条件。

- A3条件

现实生活中要想侦测到消息的丢失（丢包），可以通过time-out机制，有以下两点要求：

1. 有一个最大等待时间；
2. send-recv双方有同步的时钟；（非常必要）

> 在这里作者说：事实上，如果允许消息发送以一种随意的速度进行，即使消息发送的时间有上限，拜占庭问题也是无解的，即使叛徒所能做的行为被限制成"发送不了消息"。（这条结论的证明不在此paper的范围）

但是再同步的两个时钟之间频率也是有细微不同的，在多个时钟之间保持同步的问题就和解决拜占庭问题一样困难（会在下一篇paper中介绍）。

- A4条件

A4条件在现实生活主要就是设计一种非对称加密算法（公钥、私钥）来满足以下两点要求：

1. 叛徒节点无法伪造正常节点的签名；
2. 给出message M和第$$i$$个节点的签名X，其它节点可以计算X是否是节点$$i$$计算出来的签名；（验证签名的有效性）

事实上**要求1**是不可能被完全保证的，不过我们可以放宽一点来使得我们的算法尽量正确（还是在说用公钥、私钥加密算法来尽量降低被人伪造签名的可能性）。
