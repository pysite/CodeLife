### 1.makefile的规则
```shell
target ... : prerequisites ...
    command
    ...
    ...
```

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:

```shell
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
```

注意：在Makefile中的命令，必须要以 `Tab` 键开始。



### 2.入门例子

假设有3个头文件和8个c文件

```makefile
edit : main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o

main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h buffer.h
    cc -c display.c
insert.o : insert.c defs.h buffer.h
    cc -c insert.c
search.o : search.c defs.h buffer.h
    cc -c search.c
files.o : files.c defs.h buffer.h command.h
    cc -c files.c
utils.o : utils.c defs.h
    cc -c utils.c
clean :
    rm edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
```



### 3.使用变量

```makefile
objects = main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)
```



### 4.自动推导xxx.o

意思就是xxx.o会自动包含xxx.c，因此就可以改成下面这样，连cc -c都可以省略

```makefile
main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
...
```



### 5.只需写一个.h的写法

```makefile
$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

把每个.h文件会对应到的.o文件写在一起，这样就不用像``4.``中那样写很多遍defs.h了。



### 6.make clean的写法

```makefile
.PHONY : clean
clean :
    -rm edit $(objects)
```

`.PHONY` 表示 `clean` 是一个“伪目标”。而在 `rm` 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， `clean` 的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。



### 7.引用其他Makefile

```makefile
include <filename>
```

`filename` 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。



### 8.最终目标

第一条规则的target就是Makefile的最终目标。



### 9.分号;

```makefile
targets : prerequisites ; command
    command
    ...
```

command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 `Tab` 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）



### 10.Makefile中的通配符

- 规则中的通配符

``~``就代表当前用户的目录。没啥好说的。

``*``代表everthing，例如``*.c``。

```makefile
clean:
    rm -f *.o
```

- 变量中的通配符

```makefile
objects = *.o
```

这个并不是说objects就是所有.o文件的集合。此时objects就单纯是字符串``*.o``。

```makefile
objects := $(wildcard *.c)
```

这个才是所有.c结尾的文件集合。关于这种wildcard之类的关键字后面再讲。



### 11.文件搜寻

- VPATH

定义了VPATH，make就会在当前目录找不到文件的时候去指定的目录中去找寻文件。

```makefile
VPATH = src:../headers
```

上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）

- vpath

全小写的vpath是make的一个关键字，可以为不同的文件指定不同的搜索目录。

```
vpath <pattern> <directories>
```

为符合模式<pattern>的文件指定搜索目录<directories>。

```
vpath <pattern>
```

清除符合模式<pattern>的文件的搜索目录。

```
vpath
```

清除所有已被设置好了的文件搜索目录。

pattern中使用``%``表示匹配零或若干字符。

```makefile
vpath %.h ../headers
# 多个vpath则会按顺序搜索，例如下面会先在foo中，找不到再去blish,bar中查找。
vpath %.c foo
vpath %   blish
vpath %.c bar

# 下面表示先在foo再在bar，最后在blish中查找
vpath %.c foo:bar
vpath %   blish
```



### 12.伪目标

类似clean这种，不需要生存目标，只需要执行一套动作的，就是伪目标。

```makefile
.PHONY : clean
clean :
    -rm *.o temp
```

伪目标可以用来一下生成多个目标，例如下面：

```makefile
all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
    cc -o prog1 prog1.o utils.o

prog2 : prog2.o
    cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o
```

伪目标也可以成为依赖，有点类似子程序的感觉：

```makefile
.PHONY : cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
    rm program

cleanobj :
    rm *.o

cleandiff :
    rm *.diff
```



### 13.多目标$@

```makefile
bigoutput littleoutput : text.g
    generate text.g -$(subst output,,$@) > $@
```

上述规则等价于：

```makefile
bigoutput : text.g
    generate text.g -big > bigoutput
littleoutput : text.g
    generate text.g -little > littleoutput
```

其中的subst是一个函数，这部分后面再讲。



### 14.多目标的静态模式

```makefile
<targets ...> : <target-pattern> : <prereq-patterns ...>
    <commands>
    ...
```

其中target-pattern相当于就是对targets进行了一次描述而已。

还是通过例子来看。

```makefile
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
```

上面的规则展开后等价于下面的规则：

```makefile
foo.o : foo.c
    $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o : bar.c
    $(CC) -c $(CFLAGS) bar.c -o bar.o
```

`$<` 表示第一个依赖文件集， `$@` 表示目标集（也就是“foo.o bar.o”）。



另一个例子如下：

```makefile
files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
$(filter %.elc,$(files)): %.elc: %.el
    emacs -f batch-byte-compile $<
```

``$(filter %.o,$(files))``表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。



### 15.自动生成文件所依赖的文件

gcc -M main.c的输出是:

```makefile
main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \
    /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \
    /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \
    /usr/include/bits/sched.h /usr/include/libio.h \
    /usr/include/_G_config.h /usr/include/wchar.h \
    /usr/include/bits/wchar.h /usr/include/gconv.h \
    /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \
    /usr/include/bits/stdio_lim.h
```

gcc -MM main.c的输出则是:

```makefile
main.o: main.c defs.h
```



GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 `name.c` 的文件都生成一个 `name.d` 的Makefile文件， `.d` 文件中就存放对应`.c` 文件的依赖关系。



这里，我们给出了一个模式规则来产生 `.d` 文件：

```makefile
%.d: %.c
    @set -e; rm -f $@; \
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
```

这个规则的意思是，所有的 `.d` 文件依赖于 `.c` 文件， `rm -f $@` 的意思是删除所有的目标，也就是 `.d` 文件，第二行的意思是，为每个依赖文件 `$<` ，也就是 `.c` 文件生成依赖文件， `$@` 表示模式 `%.d` 文件，如果有一个C文件是name.c，那么 `%` 就是 `name` ， `$$$$` 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。

总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 `.d` 文件的依赖，即把依赖关系：

```makefile
main.o : main.c defs.h
```

转成：

```makefile
main.o main.d : main.c defs.h
```

于是，我们的 `.d` 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 `.d` 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 `.d` 文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：

```makefile
sources = foo.c bar.c

include $(sources:.c=.d)
```

上述语句中的 `$(sources:.c=.d)` 中的 `.c=.d` 的意思是做一个替换，把变量 `$(sources)` 所有 `.c` 的字串都替换成 `.d` ，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次序来载入文件，最先载入的 `.d` 文件中的目标会成为默认目标。



> 第二部分 书写规则完毕
