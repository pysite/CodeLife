### 16.显示命令

``make -n``只显示make命令而不运行。

``make -s``只执行命令而不显示命令到终端。



### 17.命令执行

要想第二条指令在第一条指令执行后的环境中执行，需要将这两条指令写到一行上，并用分号分开。

```makefile
exec:
    cd /home/hchen; pwd
```

``make -k``这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。



### 18.嵌套执行make

到子目录中执行make

```makefile
# 第一种方式
subsystem:
    $(MAKE) -C subdir

# 第二种方式
subsystem:
    cd subdir && $(MAKE)
    
# 第三种情况，子make的参数MAKEFLAGS被清空（默认是会传递给子make）
subsystem:
    cd subdir && $(MAKE) MAKEFLAGS=
```



将一些变量传递给子make

```makefile
export variable = value
# 其等价于
variable = value
export variable
```



### 19.命令包

首先定义一个命令包

```makefile
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```

然后就可以在合适的地方调用它

```makefile
foo.c : foo.y
    $(run-yacc)
```

此时``$^``就是``foo.y``， 而``$@``就是``foo.c``

PS：有关``$``开头的特殊变量后面会讲。

> 第三部分"书写命令"到此结束



### 20.使用变量

变量最好是大小写混合的，避免和系统变量冲突。

 `$<` 、 `$@` 等，这些是自动化变量，后面介绍。

需要给在变量名前加上 `$` 符号，但最好用小括号 `()`或是大括号 `{}` 把变量给包括起来。如果你要使用真实的 `$` 字符，那么你需要用 `$$` 来表示。



### 21.变量的基础

变量就是个替代的原理。

变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：

```
foo = c
prog.o : prog.$(foo)
    $(foo)$(foo) -$(foo) prog.$(foo)
```

展开后得到：

```
prog.o : prog.c
    cc -c prog.c
```



### 22. 变量中的变量

变量可以用``=``获取其他变量的值，且右侧的变量可以是后面才定义的变量。

```makefile
foo = $(bar)
bar = $(ugh)
ugh = Huh?
```



### 23.``:=``

用``:=``则右侧的变量就必须是已经定义好了的才行了。




### 24.定义空格变量

```makefile
nullstring :=
space := $(nullstring) # end of the line
```

先用一个空的变量nullstring来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止。而``$(nullstring) #``中间#前面的空格就被存入到了space变量中了。

``dir := /foo/bar    # directory to put the frobs in``这里dir变量后面还跟着4个空格！



### 25.``?=``

```makefile
FOO ?= bar
```

其含义是，如果FOO没被定义过，那么FOO的值就是bar。否则啥也不会发生。



### 26.变量高级用法

- 变量值的部分替换

``$(var:a=b)``把以a结尾的全换成以b结尾。

例子：

```makefile
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```

PS：前面静态模式中有如下例子

```makefile
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
```

这个效果和上面一样，但是%貌似要求foo中的字串都有相同的模式？



- 变量的嵌套

例子：

```makefile
x = y
y = z
z = u
a := $($($(x)))
```

最后``$(a)``的值就是``u``。

```makefile
first_second = Hello
a = first
b = second
all = $($a_$b)
```

最后``$(all)``的值就是``Hello``。



### 27.``+=``

```makefile
a = 1
# 意思在后面追加` 23`
a += 23
# 等价于
a = $(a) 23
```

``$(a)``的值就是``1 23``

``+=``会重复上一个符号，例如上一个如果是``:=``，则这次就是``:=``。



### 28.override

如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。

```makefile
override <variable>; = <value>;
```



### 29.多行变量

多行变量其实格式就已经在前面的"命令包中见识到了"

下面的这个示例展示了define的用法:

```
define two-lines
echo foo
echo $(bar)
endef
```



### 30.环境变量

总体说来，Makefile中可以使用系统环境变量，但如果Makefile中又定义了一个同名的，则会覆盖这个变量。（类似全局变量和局部变量的关系）

当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。



### 31.目标的局部变量

就是说我们可以针对特定target定义一些只作用于这个target的局部变量。

其语法是：

```
<target ...> : <variable-assignment>;

<target ...> : overide <variable-assignment>
```

``<variable-assignment>``;可以是前面讲过的各种赋值表达式，如 `=` 、 `:=` 、 `+= `` 或是 ``?=` 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。



举例：

```
prog : CFLAGS = -g
prog : prog.o foo.o bar.o
    $(CC) $(CFLAGS) prog.o foo.o bar.o

prog.o : prog.c
    $(CC) $(CFLAGS) prog.c

foo.o : foo.c
    $(CC) $(CFLAGS) foo.c

bar.o : bar.c
    $(CC) $(CFLAGS) bar.c
```

在这个示例中，不管全局的 `$(CFLAGS)` 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， `$(CFLAGS)` 的值都是 `-g`



### 32.模式的局部变量

和``31.``中的一样，可以为符合一些模式的变量统一定义一些局部变量。

们知道，make的“模式”一般是至少含有一个 `%` 的，所以，我们可以以如下方式给所有以 `.o` 结尾的目标定义目标变量：

```makefile
%.o : CFLAGS = -O
```



> 第四部分"使用变量"到此结束



### 33.条件表达式

```makefile
ifeq ($(A),a)
    ...
else
    ...
endif
```

还有``ifneq``、``ifdef``、``ifndef``。



注意， `ifdef` 只是测试一个变量是否有值，**其并不会把变量扩展到当前位置**。如下例子：

```makefile
bar =
foo = $(bar)
ifdef foo
    frobozz = yes
else
    frobozz = no
endif
# frobozz为yes

foo =
ifdef foo
    frobozz = yes
else
    frobozz = no
endif
# frobozz为no
```

> 第五部分"使用条件判断"到此结束

