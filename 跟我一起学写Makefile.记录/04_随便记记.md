### 59.指定目标

在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。

- all:这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
- clean:这个伪目标功能是删除所有被make创建的文件。
- install:这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
- print:这个伪目标的功能是例出改变过的源文件。
- tar:这个伪目标功能是把源程序打包备份。也就是一个tar文件。
- dist:这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。
- TAGS:这个伪目标功能是更新所有的目标，以备完整地重编译使用。
- check和test:这两个伪目标一般用来测试makefile的流程。



有一个make的环境变量叫 `MAKECMDGOALS` ，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。



### 60.make的参数

``make -n``只打印命令，不执行。

``make -t``只更新目标文件的时间。

``make -q``目标存在则什么也不打印，否则会打印出一条出错信息。

更多信息自己用时search。



> 第七部分"make的运行"结束



### 61.使用隐含规则

```
foo : foo.o bar.o
    cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```

其中.o文件怎么生成其实就不需要我们写，因此下面两条规则都是可以不写的。

```
foo.o : foo.c
    cc –c foo.c $(CFLAGS)
bar.o : bar.c
    cc –c bar.c $(CFLAGS)
```



在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的

果我们为 `.o` 文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。



可通过``make -r``来取消隐含规则，但是某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有 “后缀列表”（也就一系统定义在目标 `.SUFFIXES` 的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。（具体后面再讲）



### 62.常用的隐含规则

只写了关于C的一些规则，关于其它语言也有很多隐含规则，在此不列出。

1. 编译C程序的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.c` ，并且其生成命令是 `$(CC) –c $(CPPFLAGS) $(CFLAGS)`

2. 编译C++程序的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.cc` 或是 `<n>.C` ，并且其生成命令是 `$(CXX) –c $(CPPFLAGS) $(CFLAGS)` 。（建议使用 `.cc` 作为C++源文件的后缀，而不是 `.C` ）

3. 汇编和汇编预处理的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.s` ，默认使用编译器 `as` ，并且其生成命令是： `$ (AS) $(ASFLAGS)` 。 `<n>.s` 的目标的依赖目标会自动推导为 `<n>.S` ，默认使用C预编译器 `cpp` ，并且其生成命令是： `$(AS) $(ASFLAGS)` 。

4. 链接Object文件的隐含规则。

   `<n>` 目标依赖于 `<n>.o` ，通过运行C的编译器来运行链接程序生成（一般是 `ld` ），其生成命令是： `$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)` 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:

   ```
   x : y.o z.o
   ```

   并且 `x.c` 、 `y.c` 和 `z.c` 都存在时，隐含规则将执行如下命令:

   ```
   cc -c x.c -o x.o
   cc -c y.c -o y.o
   cc -c z.c -o z.o
   cc x.o y.o z.o -o x
   rm -f x.o
   rm -f y.o
   rm -f z.o
   ```

   如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。



### 63.隐含规则常用的命令变量

只列出部分。

- `AR` : 函数库打包程序。默认命令是 `ar`
- `AS` : 汇编语言编译程序。默认命令是 `as`
- `CC` : C语言编译程序。默认命令是 `cc`
- `CXX` : C++语言编译程序。默认命令是 `g++`
- `CO` : 从 RCS文件中扩展文件程序。默认命令是 `co`
- `CPP` : C程序的预处理器（输出是标准输出设备）。默认命令是 `$(CC) –E`

- `RM` : 删除文件命令。默认命令是 `rm –f`



### 64.隐含规则常用的命令参数变量

只列出部分。

- `ARFLAGS` : 函数库打包程序AR命令的参数。默认值是 `rv`
- `ASFLAGS` : 汇编语言编译器参数。（当明显地调用 `.s` 或 `.S` 文件时）
- `CFLAGS` : C语言编译器参数。
- `CXXFLAGS` : C++语言编译器参数。
- `COFLAGS` : RCS命令参数。
- `CPPFLAGS` : C预处理器参数。（ C 和 Fortran 编译器也会用到）。

- `LDFLAGS` : 链接器参数。（如： `ld` ）



### 65.隐含规则链

如果文件 `.c` 存在，那么就直接调用C的编译器的隐含规则，如果没有 `.c` 文件，但有一个 `.y` 文件，那么Yacc的隐含规则会被调用，生成 `.c` 文件，然后，再调用C编译的隐含规则最终由 `.c` 生成 `.o` 文件，达到目标。

我们把这种 `.c` 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标。

默认情况，中间目标都会在目标成功产生后被``rm -f``删除。

通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 `.INTERMEDIATE` 来强制声明。（如： `.INTERMEDIATE : mid` ）

你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 `.SECONDARY` 来强制声明（如： `.SECONDARY : sec` ）。

Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 `foo.c` 生成目标程序 `foo` ，按道理，make会编译生成中间文件 `foo.o` ，然后链接成 `foo` ，但在实际情况下，这一动作可以被一条 `cc` 的命令完成（ `cc –o foo foo.c` ），于是优化过的规则就不会生成中间文件。



### 66.模式规则介绍

模式规则中，至少在规则的目标定义中要包含 `%` ，否则，就是一般的规则。

目标中的 `%` 定义表示对文件名的匹配， `%` 表示长度任意的**非空字符串**。

如果 `%` 定义在目标中，那么，目标中的 `%` 的值决定了依赖目标中的 `%` 的值。即依赖目标中的%和目标中的%相同。



下面这个例子表示了,把所有的 `.c` 文件都编译成 `.o` 文件.

```
%.o : %.c
    $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```

其中， `$@` 表示所有的目标的挨个值， `$<` 表示了所有依赖目标的挨个值。



### 67.自动化变量

- `$@` : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， `$@` 就是匹配于目标中模式定义的集合。
- `$%` : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 `foo.a(bar.o)` ，那么， `$%` 就是 `bar.o` ， `$@` 就是 `foo.a` 。如果目标不是函数库文件（Unix下是 `.a` ，Windows下是 `.lib` ），那么，其值为空。
- `$<` : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 `%` ）定义的，那么 `$<` 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
- `$?` : 所有比目标新的依赖目标的集合。以空格分隔。
- `$^` : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。
- `$+` : 这个变量很像 `$^` ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
- `$*` : 这个变量表示目标模式中 `%` 及其之前的部分。如果目标是 `dir/a.foo.b` ，并且目标的模式是 `a.%.b` ，那么， `$*` 的值就是 `dir/a.foo` 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 `$*` 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 `$*` 就是除了后缀的那一部分。例如：如果目标是 `foo.c` ，因为 `.c` 是make所能识别的后缀名，所以， `$*` 的值就是 `foo` 。

加上D代表取目录Dir，加上F代表取文件File。例如：

```
$(@D)
```

表示 `$@` 的目录部分（不以斜杠作为结尾），如果 `$@` 值是 `dir/foo.o` ，那么 `$(@D)` 就是 `dir` ，而如果 `$@` 中没有包含斜杠的话，其值就是 `.` （当前目录）。

```
$(@F)
```

表示 `$@` 的文件部分，如果 `$@` 值是 `dir/foo.o` ，那么 `$(@F)` 就是 `foo.o` ， `$(@F)` 相当于函数 `$(notdir $@)` 。



### 68.模式匹配关于目录和%

> 关键点：在进行模式匹配时，目录部分会首先被移开，然后进行匹配。

一般来说，一个目标的模式有一个有前缀或是后缀的 `%` ，或是没有前后缀，直接就是一个 `%` 。因为 `%` 代表一个或多个字符，所以在定义好了的模式中，我们把 `%` **所匹配的内容**叫做“茎”，例如 `%.c` 所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有 `%` 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。

当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么**在进行模式匹配时，目录部分会首先被移开，然后进行匹配**，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式 `e%t` ，文件 `src/eat` 匹配于该模式，**于是 `src/a` 就是其“茎”**，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 `c%r` ，那么，目标就是 `src/car` 。（“茎”被传递）



### 69.重载内建隐含规则

你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：

```
%.o : %.c
    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)
```

你可以取消内建的隐含规则，只要不在后面写命令就行。如：

```
%.o : %.s
```

同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。



### 70.后缀规则

后缀规则比模式规则老旧，但make仍然支持。后缀规则就是只需要写出后缀的一种规则，**不能含有依赖文件**。

``.c.o``意思是把``.c``文件变为``.o``文件的一种隐含规则。

如 `.c.o` 相当于 `%o : %c` 。单后缀规则只定义一个后缀，也就是源文件的后缀。如 `.c` 相当于 `% : %.c` 。

```
.c.o:
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```



后缀规则中所定义的后缀应该是make所认识的，而要让make知道一些特定的后缀，我们可以使用伪目标 `.SUFFIXES` 来定义或是删除，如：

```
.SUFFIXES: .hack .win
```

把后缀 `.hack` 和 `.win` 加入后缀列表中的末尾。



```
.SUFFIXES:              # 删除默认的后缀
.SUFFIXES: .c .o .h   # 定义自己的后缀
```



make的参数 `-r`会使用得默认的后缀列表为空。而变量 `SUFFIXE` 被用来定义默认的后缀列表，你可以用 `.SUFFIXES` 来改变后缀列表，但请不要改变变量 `SUFFIXE` 的值。



### 71.隐含规则的搜索算法（了解即可）

比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 `archive(member)` 的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 `member` 当作T来搜索。

1. 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 `src/foo.o` ，那么，D就是 `src/` ，N就是 `foo.o` ）
2. 创建所有匹配于T或是N的模式规则列表。
3. 如果在模式规则列表中有匹配所有文件的模式，如 `%` ，那么从列表中移除其它的模式。
4. 移除列表中没有命令的规则。
5. 对于第一个在列表中的模式规则：
   1. 推导其“茎”S，S应该是T或是N匹配于模式中 `%` 非空的部分。
   2. 计算依赖文件。把依赖文件中的 `%` 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。
   3. 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）
   4. 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。
6. 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
   1. 如果规则是终止规则，那就忽略它，继续下一条模式规则。
   2. 计算依赖文件。（同第5步）
   3. 测试所有的依赖文件是否存在或是理当存在。
   4. 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
   5. 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。
   6. 如果没有隐含规则可以使用，查看 `.DEFAULT` 规则，如果有，采用，把 `.DEFAULT` 的命令给T使用。

一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。

> 第八部分"隐含规则"结束



### 72.函数库

函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令 `ar` 来完成打包工作。

```
foolib(hack.o kludge.o)
```

其等价于:

```
foolib(hack.o) foolib(kludge.o)
```



当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 `a(m)` 形式的，其会把目标变成 `(m)` 。于是，如果我们的成员是 `%.o` 的模式定义，并且如果我们使用 `make foo.a(bar.o)` 的形式调用Makefile时，隐含规则会去找 `bar.o` 的规则，如果没有定义 `bar.o` 的规则，那么内建隐含规则生效，make会去找 `bar.c` 文件来生成 `bar.o` ，如果找得到的话，make执行的命令大致如下:

```
cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
```



你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如：

```
.c.a:
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
    $(AR) r $@ $*.o
    $(RM) $*.o
```

其等效于：

```
(%.o) : %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
    $(AR) r $@ $*.o
    $(RM) $*.o
```



注意：在进行函数库打包文件生成时，请小心使用make的并行机制（ `-j` 参数）。如果多个 `ar` 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。

PS：``make -j``是指并行化执行make。

> 第九部分结束