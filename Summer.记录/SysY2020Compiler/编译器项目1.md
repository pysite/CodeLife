- 比赛使用的汇编的语言是armv7-A，armv7分为armv7-A、armv7-R、armv7-M
- GNU Flex和GNU Bison



### 词法分析：（涉及正则表达式和有限状态自动机）

一个正则表达式由特定字符串构成，或者由其它正则表达式通过以下三种运算得到：(正则表达式不止这下面三种)

- 并运算：r|s，表示r或s都可以接受；
- 连接运算：r和s的连接记作rs；
- Kleene闭包：正则表达式r的Kleene闭包记作r*，表示ε|r|rr|rrr|...

GNU Flex可以将一个正则表达式自动地转化为一个NFA，然后再将这个NFA转化为一个DFA；

Flex中的F是Fast，意思比之前的Lex快得多；



#### Flex使用流程

写好Flex的代码xxx.l后，调用``flex xxx.l``即可生成``lex.yy.c``文件，其中有用的函数只有一个叫``yylex()``。

同时要注意的是``lex.yy.c``中有全局变量``FILE* yyin``，在我们使用``lex.yy.c``之前需要``extern FILE* yyin``引用到我们自身的``main.c``文件中，在``main.c``中fopen一个文件并将返回的文件流FILE赋值给yyin，否则yyin默认是stdin。然后``main.c``中``while(yylex()!=0);``即可。

 编写完``main.c``后调用``gcc main.c lex.yy.c -lfl -o xxx``即可生成可执行程序xxx。

然后调用``./xxx yyy``即可去分析目标程序。



#### 编写Flex需要的代码

整体上分为三部分**定义definition**、**规则rules**、**用户自定义user subroutines**；不同部分的代码用%%分隔；

**定义部分**实际就是宏定义，``name definition``，例如定义数字``digit [0-9]``，definition一般是正则表达式；



**规则部分**由 正则表达式 + 相应的响应函数 组成``pattern {action}``，其中action可以用一段C代码表示。Flex在进行匹配时按照规则部分依次尝试每一个规则，尽可能匹配最长的输入串，如果有些内容不匹配任何规则，Flex默认只将其拷贝到标准输出，要改变这一规则只需要写个``. {xxx}``规则替换即可（其中xxx是你想要的默认动作）

例子如下：

``{digit}+ {printf("Integer value %d\n", atoi(yytext))}``

其中{digit}表示使用宏定义，加号表示匹配1或多次，yytext是Flex提供的一个变量，表示当前词法单元对应的词素（char*），函数atoi()的作用是把一个字符串表示的整数转化为int类型；



**用户自定义部分**会被原封不动地拷贝到lex.yy.c中，方便用户自定义需要执行的函数。注意在第一部分**定义部分**可以用``%{``和``%}`括起来用户自定义代码的定义、声明、include部分等，这部分代码将生成在lex.yy.c最前面。

yyrestart(f)是Flex提供的库函数，可以让Flex将其输入文件的文件指针yyin设为f并重新初始化该文件指针（使其指向文件开头）



#### 正则表达式：

1. "."匹配除"\n"之外的任何一个字符

2. "["与"]"共同匹配一个字符类，例如"[abcABC]"匹配一个abcABC中的任一个字符，中间可以用"-"表示范围，例如"[a-cA-c]"

   如果"[]"中第一个字符是"^"则表示堆这个字符类取补，例如"[ ^0-9 ]"表示所有非数字的字符；

3. "^"在方括号之外匹配一行开头，"$"匹配一行结尾，"<<EOF>>"匹配文件结尾

4. "{}"如果中间是1个或2个数字则代表次数范围，例如"A{5}"匹配AAAAA，"A{1,2}"匹配A,AA，如果中间是一个Flex中的宏定义则表示那个名字对应的正则表达式；

5. "*"就是Kleene闭包

6. "+"就是正闭包

7. "?"代表前面的字符是可选的；

8. "|"代表或

9. "\\"代表各种转义字符，和C中的"\\"类似；

10. 用引号括起来的代表就匹配其中的内容，例如``"xx"``就是匹配xx

11. 任何不属于上述介绍的字符在正则表达式中都仅匹配该字符本身；



#### Flex高级

**yylineno**就是Flex中自带的记录行数的变量；使用的话需要在定义部分加"%option yylineno"；

**yy_create_buffer**(FILE* f, YY_BUF_SIZE)可以为输入的文件开辟一块输入缓冲区；

**input**()可以从输入文件读取下一个字符；

**unput**()可以放回一个字符到输入缓冲区；

**yyless**(n)把刚读取的yyleng-n个字符放回到输入缓冲区，**yymore**告诉Flex保留当前词素，在下一个词法单元识别出来之后将下一个词素连接到当前词素后面；

**REJECT**宏相当于告诉将当前yytext完全放回去，然后去试图匹配当前规则之后的那些规则；



### 语法分析

语法分析程序主要任务是读入词法单元流、判断输入程序是否匹配程序设计语言的语法规范，并在匹配规范的情况下构建起输入程序的静态结构；

很多在程序中常见的结构无法用正则表达式表达，因此人们发明了上下文无关文法CFG，但是判断某个输入串是否属于特定CFG的问题上最好的算法也要O(N^3)过慢，因此现代程序设计语言的语法大多属于一般CFG的一个足够大的子集，比较常见的子集有LL(k)文法以及LR(k)文法，判断一个输入是否属于这两种文法都只需要线性时间。

上下文无关文法在形式上是一个四元组<终结符T、非终结符NT、初始符S、产生式P>。通过产生式可以从初始符号推导除一串符号语法规约的词法单元，这个替换和推导过程可以用树形结构表示，称为**语法树**。

语法分析的过程就是把词法单元流变成语法树的过程。

GNU Bison所生成的语法分析程序采用了**自底向上的LALR(1)**分析技术。

Bison前身为Yacc。



#### Bison使用流程

编写好Bison需要的代码xxx.y后，调用``bison xxx.y``即可得到syntax.yy.c文件，其中有用的函数只有一个**yyparse**()。yyparse中需要用户为它提供另外一个专门返回词法单元的函数，函数名称就是yylex()；

在xxx.y中添加山``#include "lex.yy.c"``后调用``bison -d syntax.y``，不再得到syntax.yy.c而是syntax.tab.c和syntax.tab.h两个文件，然后修改Flex代码xxx.l中添加``#include "syntax.tab.h"``，同时注意Flex中每个规则都要返回对应的词法单元，而**词法单元就是Bison源代码中定义部分**的宏。然后就是在main函数中调用**yyrestart**和**yyparse**即可。

最后调用``gcc main.c syntax.tab.c -lfl -ly -o xxx``即可生成可执行文件xxx，然后``xxx ccc``即可对ccc进行语法分析。



#### 编写Bison需要的代码

结构也分为**定义部分**、**规则部分**、**用户函数**部分。

定义部分中，用%token INT来声明词法单元INT。所有未被定义为%token的符号都会被看作非终结符，这些非终结符要求必须在任意产生式左边至少出现一次；

例如我们想构建一个加法的：

```
Calc:INT ADD INT {$$ = $1 + $2;};
```

其中INT需要在Flex中写

```
{digit}* {
	yylval = atoi(yytext);	//yylval是Flex的内部变量，表示当前词法单元对应的属性值
	return INT;
}
```

在用户函数部分，我们还可以定义yyerror函数，该函数会在语法分析程序每发现一个语法错误时调用。



Bison里会默认所有属性值的类型以及变量yylval的类型都是int，如果需要修改类型的话，则如下：

```
//定义INT和FLOAT终结符的类型
%token <int> INT IIII
%token <float> FLOAT FFFF

//定义非终结符的类型
%type <double> Exp Factor Term
```



yyloc是Flex中内置的位置信息变量，Bison不会自动维护，要用的话需要自己动手。



在定义部分定义%left、%right可以设计终结符的结合性，例如

```
%left ADD SUM
%left MUL DIV
```

则遇到1-2+3时，由于左结合，因此先计算1-2再计算+3;

同时Bison规定任何排在后面的算法优先级高于排在前面的算符，因此MUL DIV比ADD和SUM优先；

Bison中``IF LP EXP RP Stmt %prec ABC``可以使产生式IF LP EXP RP Stmt的优先级等于ABC；

虽然我们可以借助优先级和结合性消除语法中的二义性，但不建议使用它们解决除了表达式和ifelse之外的任何其它冲突，因为很可能是语法设计得就有问题。



bison -d选项可以生成.output报告文件，-t选项可以进入调试模式；
