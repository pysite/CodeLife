> 参考南京大学编译原理课第4章PPT

- 自顶向下语法分析器（用于处理LL文法）

  从语法分析树的根部开始构造语法分析树；

- 自底向上语法分析器（用于处理LR文法）

  从语法分析树的叶子开始构造语法分析树；



### 基础知识

> 学的都是上下文无关文法CFG

- CFG包含4个部分：终结符号、非终结符号、开始符号、产生式

- 构造分析树：

  ![image-20210704110706772](.\images\image7)

- 上下文无关文法比正则表达式能表示的范围更广；

  上下文无关文法也有缺陷，还得之后借助语义分析来剔除一些符合文法、但不合法的程序；

- **二义性**就是一个文法可以为某个句子（句子就是多个终结符构成的句子）生成多棵语法分析树；
- **左递归**就是文法中一个非终结符号A使得对某个串α，存在一个推导 A->Aα，则称这个文法是左递归的；

>  二义性方法的消除

例如想消除if a1 then if a2 then b1 else b2，则这个else就不知道对应的是哪个if；

- 消除方法：规定else和最近的if匹配，或者在产生式中引入新的非终结符（略），二义性消除方法没有规律可循；

> 左递归的消除

- 自顶向下的语法分析技术不能处理左递归，但自底向上的技术可以处理左递归；

- 一般来说靠将产生式改变为没有左递归的等价的产生式来消除；

![image-20210704112749714](.\images\image8.png)



> 递归下降分析回溯法

- 就是从起始符号开始，依次选择可以匹配的产生式匹配后进入下一层继续匹配，如果某一层匹配失败，则换这一层的下一个产生式继续尝试。

> First集合

- First集合一个非终结符A的First集合就是由A可以推导得到的首符号的集合；

> Follow集合

- Follow集合就是在某些句型中紧跟在A右边的终结符号的集合；

- FOLLOW(S)就是结束符$



### LL(1)文法

>  对于LL(1)文法，可以在自顶向下分析过程中，根据当前输入符号来确定使用的产生式

- LL(1)文法要构造的是**预测分析表**M，构造步骤如下（假设每个符号的FIRST和FOLLOW集合都已算出）

  - 对于文法G的每个产生式A -> α
    - 对于FIRST(α)中的每个终结符号a，将A → α加入到M[A, a]中

    - 如果ε在FIRST(α)，那么对于FOLLOW(A)中的每个符号b，将 A → α也加入到M[A, b]中

  - 最后在所有的空白条目中填入error

- 构造好分析表就可以用来进行语法分析：
  - 栈用来存放当前待匹配的部分，初始时栈中只有"S$"；
  - 假设当前栈顶元素是X，当前输入元素是a，
    - 如果X是终结符，则如果X==a，则匹配，将X出栈，读取下一个元素
    - 如果X是非终结符，且M[X, a]是产生式X->Y1 Y2 Y3，则按Y3 Y2 Y1的顺序压入栈，即下一个栈顶元素是Y1，表示下一个待匹配的符号是Y1；
    - 否则则报错；
  - 当栈为空，则代表匹配成功；



> 自底向上语法分析

- 自底向上的通用框架：移入-规约

- 句柄：

  - 最右句型中和某个产生式体相匹配的子串，对它的归约代表了该最右句型的最右推导的最后一步；
  - 正式定义：如果S -> αAw -> αβw，那么紧跟α之后的β是 A → β 的一个句柄；
  - **句柄右边只有终结符号**，如果文法是无二义性的，那么每个句型有且只有一个句柄；

  **句柄代表了至下而上、从左到右的分析过程中应当要马上、直接规约的短语**

![image-20210704133735895](.\images\image9.png)

> 规范规约

- 规范规约就是最左规约，即每次将最左边的句柄进行规约，其逆过程就是最右推导
- 最右推导也叫规范推导，由规范推导推出的句型称为规范句型；

> 移入归约分析

- 使用一个栈来保存归约/扫描移入的文法符号 

- 栈中符号 (从底向上) 和待扫描的符号组成了一个最右句型 

- 开始时刻：栈中只包含$，而输入为w$ 

- 结束时刻：栈中为S$，而输入为$ 

- 在分析过程中，不断移入符号，并在识别到句柄 时进行归约 

- 句柄被识别时总是出现在栈的顶部
- **句柄总是在栈顶**，因此LR分析就是发现栈顶可归约就会立马规约，然后再使用下面的要介绍的GOTO函数进行状态转换

**PS：两个横线表示推导，而单个横线的箭头表示产生式**





### LR(k)文法

> 对于几乎所有的程序设计语言，只要写出上下文无关文法，就能够构造出识别该语言的LR语法分析器

- L表示从左开始扫描，R表示反向构造出最右推导（最右推导的样子就是左边全是非终结符，右边全是终结符）
- k表示最多向前看k个符号；

- k=2时语法分析器的规模非常庞大，k=0、1时已经可以解决很多语法分析问题，因此具有实践意义；

- LR文法是无二义文法的子集；

> 活前缀

- 活前缀就是规范句型的一个前缀，这个前缀不含句柄之后的任何符号
- 分析栈中的符号串总是活前缀



### LR(0)文法

- 项：项就是产生式中某处加一个一点，表示我们在分析过程看到了产生式多大部分
  - 项A → α·β表示已经扫描/归约到了α，并期望在接下来的输入中经过扫描/归约得到β，然后把αβ归约到A
  - A -> α·aβ 称为**移进项目**
  - A -> α·Bβ 称为**待约项目**
  - 如果β为空，表示我们可以把α归约为A
  - 项在代码中可以用一对整数表示：(i, j)表示第i条产生式，点位于右边第j个位置

- 增广文法：
  - G的增广文法G'是在G中增加新开始符号S'，并加入产生式S' → S而得到的
  - S'-> α· 称为**接受项目**

- 项集闭包(CLOSURE)：

  - 就是DFA中的那些一个矩形方框中的各个产生式的集合；

  - 如果A → α·Bβ在CLOSURE(I)中，而B → γ是一个产生式，且项B → ·γ不在CLOSURE(I)中，就将该项加入其 中，不断应用该规则直到没有新项可加入

- GO函数
  - GO函数就是CLOSURE之间的关系
  - I是一个项集，X是一个文法符号（X可以是终结符也可以是非终结符），则GOTO(I, X)定义 为I中所有形如的项[A → α·Xβ]所对应的项[A → αX·β] 的集合的闭包

- 构造识别活前缀的NFA
  - 先为每个产生式在不同的地方打点构成所有可能的项，称为一个状态
  - 如果状态i为X -> X1·X2 X3，而状态j为X -> X1 X2·X3，则在状态i到j之间画一条标志为X2的有向边；
  - 如果状态i为X -> α·Aβ，则从状态i画一条ε边到所有状态A -> ·y

![image-20210704171704338](.\images\image11.png)

>  可以看到上图中状态1在收到ε(NULL)后有两个后继状态，即接受一个字后转入到某个状态集合的子集，因此是NFA不确定的

- 将NFA转换成DFA

  NFA转换成DFA就是，把各个状态属于同一个CLOSURE合并起来，DFA中的一个状态就是一个CLOSURE

![image-20210704172314138](.\images\image12.png)

- 根据DFA构造ACTION表和GOTO表

  ![image-20210704173505378](.\images\image13.png)

![image-20210704173833016](.\images\image14.png)

### 

> 相当于ACTION表和GOTO表，ACTION表负责告诉移入和规约，而GOTO表则是在进行规约后，在不同的CLOSURE之间的转换

> 非LR(0)文法都有移进-归约冲突，即一个矩形框内既有移进项目，也有规约项目，这时就必须要向后面再多看一位才知道做哪种操作。

> 当然必需不会出现冲突，即移进项目中的终结符未出现在归约项目末尾的非终结符的FOLLOW集合。

### SLR(1)文法

SLR(1)文法就是一个矩形框内如果有规约-移进冲突，但是FOLLOW集合不会和移进项目的终结符重合的简单Simple LR(1)文法。

SLR(1)和LR(0)构造分析表的唯一区别就是对于规约项目，SLR(1)只会把"rj"填到FOLLOW(A)中的格子；

![image-20210704185812294](.\images\image15.png)





### 

上述SLR(1)仍然会有可能出现问题，因为一般的FOLLOW(A)集合是某种特定情况A后面可能出现的元素的一个超集。

> 例如只有"aBc"为前缀的规范句型，没有"Bc"为前缀的规范句型，则B的FOLLOW集合有c，这样当"X->Y·cR"和“B->Y·”在同一个矩形时，后面的符号就是c，则此时SLR(1)就不知道到底该移进还是规约了，但是实际上B后面要出现c必须B前面是a，因此很显然这时我们需要执行的操作是移进。（但SLR(1)不知道）



### LR(1)文法

LR(K)项目：

- LR(K)项目就是原来的每个项目附带有k个终结符，代表展望，例如[A -> α·, a1a2a3]就代表必须后续三个终结符为a1a2a3时才可以规约为A；

- 对于移进项目 or 待约项目，其后续的k个终结符没有作用；（**即只对规约项目有用**）



LR(K)的有效项目：

> 有效项目就是DFA中识别完活前缀后所到达的项目集中就都是对于该活前缀的有效项目

![image-20210704192424575](.\images\image16.png)



LR(1)的CLOSURE：

![image-20210704192946567](.\images\image17.png)

LR(1)的GO：

![image-20210704193024242](.\images\image18.png)

LR(1)的构造方法：

![image-20210704193306252](.\images\image19.png)

