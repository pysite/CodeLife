- 小端法：低位在低地址；大端法：高位在低地址；
- a&(b|c) = (a&b)|(a&c)
- a|(b&c) = (a|b)&(a|c)
- int b = a << 32; 这种移动k>>sizeof(int)会导致实际只移动k mod sizeof(int)位 - 已验证
- c库中的文件<limits.h>定义了一组常量INT_MAX, INT_MIN等来限定编译器运行的这台机器的不同整型数据类型的取值范围。
- 文件<stdint.h>中引入了uint16_t, int32_t等，对应也有INT16_MAX之类。
- C预处理器遇到仅用空格（或其他空白字符）分隔的一个字符串常量序列时，就把它们串联起来。

- 创建一个无符号常量 必须加上后缀符U或u；
- C语言在执行一个同时涉及有符号数和无符号数的运算时，会隐式地将有符号数看作是无符号数；即-1<0u是False
- 判断加法s=x+y是否溢出的方法：如果s小于x或s小于y则溢出；
- x<0 and y>0 则x/y是向上取整（整数是向下取整）反正都是向0靠近；
- 负数x进行算术右移k位得到的是x/(1<<k)向下取整，为了得到向上取整的结果需要先(x+(1<<k)-1)再右移k位



- IEEE 浮点数：和计组的区别比较大

  - 32位：1位符号s，8(k)位阶码E，23位尾数M

    其中8位的阶码表示的无符号数为e（e是移码）则E = e-Bias，而这个Bias=2^(k-1)-1；k就是阶码位数

  - 当阶码无符号数e为全0时则代表是非规格化数，否则是规格化数
  - 非规格化数的阶码E = 1 - Bias，且尾数M不会自带1，相当于尾数在0<<M<1之间；
  - 规格化数的阶码E = e-Bias，且尾数M自带1，相当于尾数在1<<M<2之间；

- 之所以浮点数这么设计是为了非规格化数和规格化数的边界处过度平滑，即最小的间隔不变；

  同时浮点数的大小就和表示浮点数的无符号数大小顺序相同，即000000一直到011111是升序的。



- 向偶数舍入：把一个数优先向更靠近的整数舍入，例如1.4变为1，1.6变为2；而把中间的.5这类值变为一个偶数，例如1.5和2.5变为2，3.5和4.5变为4；
- 向偶数舍入可以在大多数现实情况中避免统计偏差，即不总是往大了约，也不总是往小了约；
- 浮点乘法不具备结合性，(1e20x1e20)x1e-20=+无穷，而1e20x(1e20x1e-20) = 1e20

- 浮点乘法不具备分配性，1e20x(1e20 - 1e20)求值为0，而1e20x1e20 - 1e20x1e20 = NaN(两个正无穷相减得NaN)



- float或double转int，值会向0舍入。（值也可能溢出）
- Intel处理器中C语言中用[1000...00]代表整数不确定值，即当把一个值强转为int而又找不到一个合理的近似值就会变成-2147483648(经过测试，貌似不起作用，应该是7fffffff和800000分别代表超出上界和下界的值)

