- 虚拟地址VA经过MMU(Memory Management Unit)翻译成PA；

  MMU将VA中的VPN虚拟页号获取到对应PTE（可能直接从TLB得到PTE，也可能是从Cache/内存中得到的），然后再把PTE中的 "PPN物理页号 + VPO虚拟页偏移" 组成最终的PA物理地址；

  VA中的VPN可分为TLBT+TLBI，其中TLBT是tag，TLBI则是索引，根据索引可以去TLB中查询；

- DRAM的结构完全是由巨大的不命中开销驱动的；因为DRAM不命中就得去访问磁盘；

  所以DRAM一般是虚拟页很大，全相联，且替换策略采用的是更复杂精密的策略；

- 当缺页异常处理程序返回时，它会重新启动导致缺页的指令；

- 每个进程一个页表；

- 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件，通过mmap调用使得.text和.data加载到新创建的内存中，这其中从不从磁盘到内存实际复制任何数据，在这些页被使用到时才按需调页；

- 多个虚拟页映射同一个物理页的情况一般是“动态链接库”的情况，例如多个printf.o映射到不同进程；

- 缓存可以根据物理地址或者虚拟地址寻址，但一般都是根据物理地址进行缓存的；

- 优化地址翻译：L1 缓存的中“组索引+块偏移”的位数刚好等于VPO，因此在MMU查找PPN时，L1缓存已经可以根据VPO去取出对应一组的所有缓存了，因此在找到PPN后即可立马进行判断tag是否命中；

- Linux将每个进程的虚拟内存组织成一个个区域，每个区域都是由一个vm_area_structs描述，这个结构体中vm_next指向下一个（是个链表）；

  每个进程有个task_struct，里面的mm是个mm_struct描述了虚拟内存状态，mm_struct中pgd是第一级页表的基址，mmap就是vm_area_structs组成的链表；（书上后面说Linux将vm_area_structs组织成了一棵树）



- 内存映射：Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容；
- **内存中的页实际都映射着一个文件**，文件中的内容用来初始化内存的值；
  - 一般我们函数执行时用的那些内存空间（即没有映射文件系统中的文件的那些页）都算是映射到**匿名文件**；匿名文件全部是0，因此映射到匿名文件区域的页面有时也叫做**请求二进制零**的页；

- 内存中的页都是在一个由内核维护的专门的**交换文件**之间换来换去，交换文件也叫**交换空间**（磁盘上存放内存页的空间）

  交换空间限制着当前进程能分配的虚拟页面总数；

- cow写时复制

- fork时会直接延用父进程的页表等结构，只不过里面的每个页都被标记为了COW，写时再复制；

- execve时会先删除原进程中虚拟地址的用户部分中的已存在的区域结构；

  然后再建立新的虚拟内存映射，.data和.text来自于文件，而.bss和栈、堆则是来自于**请求二进制零**；

- mmap内存映射函数就是负责分配一个新的虚拟内存区域，其既可以是来自于某个文件的(文件描述符fd)也可以是请求二进制零的（请求匿名页）；函数返回值就是个指针，其值为新分配区域的地址；
- munmap就是删除指定虚拟内存的区域；



- 动态内存分配器就是堆Heap区域的管理；（比mmap方便，但都是用来创建虚拟内存的）

  堆是紧挨着.bss段并向上增长的，栈是在用户空间的顶端并向下增长的；

- 对于每个进程，内核维护着一个变量brk指向堆的顶部；
- 分配器（全称：动态内存分配器）将堆视为一组不同大小的**块**；
  - 显式分配器：就是C中的malloc和free，C++中的new和delete；
  - 隐式分配器：就是垃圾收集器，隐式分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块；
- 我们通过malloc分配得到的就是一个**块**；
- 在32位模式malloc返回的块地址总是8的倍数，在64位模式该地址总是16的倍数；
- malloc不初始化，calloc(int num, int size)会初始化，realloc改变大小；

- **malloc对于小范围的内存分配是sbrk函数实现，sbrk将进程brk指针增大size，而malloc对于大内存分配则是通过mmap和munmap实现的**；

- 分配器应当：

  - 最大化吞吐率：即一秒钟内完成的分配和释放请求尽量多；
  - 最大化内存利用率

- **隐式空闲链表**：

  每个块的前面有个头部，头部中有块的大小以及块是否空闲的标志；这个链表的指针就是每个块的头部（即头部的地址+头部中指示的块大小即可得到下一块的地址，可能还要考虑对齐）

- 对于隐式空闲链表，在其上各种操作都必须扫描整个隐式空闲链表；
  - 首次适配：每次都从头开始，找到第一个合适的
  - 下一次适配：每次从上一次扫描到的位置开始扫描，找到第一个合适；
  - 最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块；
- 隐式空闲链表中一个块很容易得到下一个块的指针，但是想得到它上一块的指针就很难，因此我们可以在每个块的末尾再添加一个块头部，称为**脚部**（也叫**边界标记**技术）；这样每个块的头部的上面就是上一块的脚部，很容易得到上一块的指针；

- 当堆空闲空间不足时，分配器就会调用sbrk请求一个较大的chunk(内存片)，这个chunk一开始都是free的可供使用；
- 内存管理器可以通过这种隐式空闲链表实现，malloc就是一种内存管理器，**书中实现的简单的malloc就是采用的sbrk申请内存，然后建立隐式空闲链表来管理各个块**；

- **显式空闲链表**：

  就是在空闲块中的空闲数据中存放前一个空闲块和后一个空闲块的地址，使首次适配的分配时间从块总数的线性时间减少到空闲块数量的线性时间；

- **分离的空闲链表**：

  1. 简单分离存储：

     就是说按照2的幂对空闲块按照大小分类，比如第k类的空闲块大小就是2^k字节；

     每种类型的空闲块成一个链表，插入和删除都在该类空闲链表的头部进行操作；

     请求分配的大小size假如2^(k-1)<size<=2^k，那么就去分配一个类型k的空闲块，且不会分割（因此有内部碎片）；如果对应的空闲链表上没有该类的空闲块了，则分配器会向操作系统请求一个固定大小的内存片Chunk，将这个片分成大小为2^k的块再插入到k的空闲链表中；

  2. 分离适配

     这种方法中每个空闲链表中的空闲块大小就不一定相同了，但是每个空闲链表中的空闲块大小一定是在一个范围的，例如第k个链表上面的块可能就是2^(k-1)+1到2^k字节；

     这种链表下如果要分配一个块则只需要到对应范围的链表中查找（首次适配），并且要**分割**，将剩下的空闲块再插回到对应的链表中；

     这种链表下我们要释放一个块还要进行合并，将结果放置到相应的空闲链表中；

  3. 伙伴系统



- 垃圾收集：自动回收堆存储的过程叫做垃圾收集；

- Mark&Sweep方法：

  这个方法就是假设堆中所有块，块头部中有标志位标志这个块**是否已被标记**和**是否已被分配**；

  每次要检查是否有垃圾块时，就从根节点开始，递归去找子节点（每个节点就是一个块，因为在实际程序中可能有些变量、指针指向向分配的内存，因此我们就不断地假设块中每4字节的数据是个指针，先调用isPtr函数判断4字节数据是否是个指向已分配块中某个字的指针），把遍历到的每个节点都标记下。最后那些未被标记的已被分配的块就是孤儿块，可以回收掉；

- Mark&Sweep方法的问题：

  1. C语言没有类似isPtr函数能判断一个4字节数据是否是指针；
  2. 且即使知道了是指针也无法知道其指向是否安全、正确；

  对于上述问题2我们可以将所有已分配的块按照其物理地址构建二叉平衡树，因此每次拿到一个4字节数据我们就可以去这个平衡树上找看是否这个4字节数据落在了一个块的内存范围，否则4字节数据就不能是个指针；

  但是对于问题1则只能保守的解决，因为C语言的强制转换，我们往往把指针也可以当成int类型存储，因此可能一个int只是恰好和某个变量的地址相同，但这种情况下我们的垃圾回收器就不能回收对应的内存空间，即使实际上这两者并不是指针关系；（所以说这种垃圾回收器是**保守的**）



- C语言中常见的内存错误：
  - scanf("%d", val); 忘加&
  - malloc不初始化0；
  - gets溢出；
  - for循环下标溢出；
  - *size--会先执行--；
  - int *p += k是使指针p移动了k * sizeof(int)大小
  - 局部变量不可返回&
  - free(x)，后面不可再用x[0]
  - 申请了一个内存，不释放就直接return了函数，造成泄露

