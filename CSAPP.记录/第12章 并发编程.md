- 现代操作系统提供三种基本的构造并发程序的方法：
  - 进程；
  - IO多路复用；
  - 线程；

### IO多路复用

- IO多路复用：基本思路是使用select函数，要求内核挂起进程，只有在一个或多个IO事件发生后才将控制返回给应用程序；
- Select就是构建一个”要监听的描述符集合“位向量，例如向量v中v[0] = 1则代表我们要监听stdin；

### 基于线程

- 进程中不同线程基本上是平等的，只是最开始的线程被称为主线程稍微有点特殊；

Posix标准

- pthread_t就是线程id的类型(unsigned long)
- int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);

终止线程：

- 线程return时会隐式地终止；
- 通过调用pthread_exit函数，线程显式地终止；主线程调用pthread_exit会等待其他对等线程终止后再终止主线程和整个进程；
- 如果一个线程调用了exit函数，该函数终止进程以及所有与该进程相关的线程；
- 一个线程可以调用pthread_cancel(pthread_t tid)来杀死另一个平等线程；

线程回收

- pthread_join；

分离线程

- 线程要么是可结合的(joinable)要么是分离的(detached)；

- 可结合的线程可以被其他线程回收和杀死，但是弊端就是必须要被其他线程回收；

  分离的线程不可以被其他线程回收或杀死，好处是它的内存资源在它终止时由系统自动释放；

- 线程的寄存器不可能被其他线程读取，但线程的进程栈中的内容则可以通过类似全局指针的方式被其他线程给访问到；

共享变量

- 全局变量、静态变量这些在多个线程间只有一个；

- 说一个变量v是共享的，当且仅当它的一个实例被一个以上的线程引用；

pthread_once

```
在多线程环境中，有些事仅需要执行一次。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始化（pthread_once）会比较容易些。
```



### 信号量

类型sem_t

- int sem_init(sem_t *sem, 0, unsigned int value);
- sem_wait P操作
- sem_post V操作



### 预线程化

预线程化就是提前创建好工作线程池，每当取到一个connfd后就交给其中一个线程（生产者-消费者模型）；



### 测量并行程序的性能

加速比Sp = T1/Tp；

- 其中Ti是程序在k个核上运行时间

- 如果T1是程序顺序执行版本的执行时间，则S称为绝对加速比
- 如果T1是程序并行版本在一个核上的执行时间，则称S为相对加速比；

效率Ep = S/p，即每个核的效率



### 并发的问题

1. 线程安全

   以下四种都是线程不安全的：

   - 不用semaphore保护全局变量的函数
   - 保持跨越多个调用的状态的函数，例如rand函数中next_seed = next_seed * 11035 + 12543;（依赖上一次的next_seed）
   - 返回指向静态变量的指针的函数
   - 调用了线程不安全的函数（不一定就不安全了）

   解决办法：1.重写代码，例如将函数中保持状态的static变量改为每次调用函数时传参；2.加锁；

2. 可重入性（注意可重入性和线程安全不是完全的同义词，但很相似）（可重入性是线程安全的真子集）

   可重入的函数一般是只用了局部变量，且传入的参数是值传递（这种叫**显式可重入**），或者传入的参数是指针(引用)但也是非共享变量的指针（**隐式可重入**）；





