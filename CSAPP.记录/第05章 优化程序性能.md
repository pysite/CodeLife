- C语言中的指针运算和强制类型转换会使编译器很难对代码进行优化。

- 内存别名使用：两个指针可能指向同一个内存位置；（编译器在进行优化时必须假设不同的指针可能指向同一个位置的情况）

- 函数调用不能随便的优化，例如f()+f()不一定等于2*f()，因为f函数里可能改变了一些其他状态（不能只看返回值）；

  将函数转换成内联函数则可以对上面情况进行优化，GCC最近版本就是在尝试这种形式的优化，但GCC只尝试在单个文件中定义的函数的内联。（函数内联后则对这个函数打的断点，想进行debug都会失败）



- 表示程序性能：CPE(Cycles Per Element)，例如算法A运行时间为368+9.0n，算法B运行时间为368+6.0n,则可以说算法A的CPE为9.0，算法B的CPE为6.0；
- 1G=10^9，4GHz的时钟周期0.25ns，250ps；



- 简单for循环加速的method：
  - for循环判断条件如果涉及到调用函数，但这个函数的结果不变，则把函数提到循环外；
  - 用临时变量temp累积多次计算结果，再最后一次赋值到数组元素，而非每次都把中间结果累加到数组元素；

- 当一系列操作必须按照严格顺序执行时，就会遇到延迟界限，因为在下一条指令开始之前，这条指令必须结束；
- 吞吐量界限刻画了处理器功能单元的原始计算能力；这个界限是程序性能的终极限制；



- 乱序处理器分为指令控制单元ICU、执行单元EU；

- 控制单元（包含）：指令高速缓存、取指控制、指令译码、退役单元（内含寄存器文件）；

  在取指控制单元进行分支预测；

  指令译码单元将一条指令译码成多条微指令；

  退役单元记录正在进行的处理，并确保它遵守机器级程序的顺序语义；

- 投机执行技术：就是分支预测失败后再去将状态重置为分支点的状态，并开始取出和执行另一个方向上的指令；

- 退役单元控制着寄存器的更新。指令译码时，关于指令的信息被放置在一个先进先出的队列中，这个信息会一直保持在队列中，直到指令执行完毕且所有引起该指令的分支点也都被确认为预测正确则这条指令可以退役 or 指令的某个分支点预测错误则该条指令被清空且丢弃所有计算结果。

  任何寄存器的更新必须在指令退役时才会发生。

- 乱序处理器中某个执行单元的计算结果可以发送给另一个执行单元（类似于转发）

- 寄存器重命名：

  一个操作t对寄存器r写入，则把(r,t)加入到一张表中；

  当某个执行单元完成第一个操作时，生成一个结果(v, t)，指明标记为t的操作产生了值v；

  通过这种机制值可以从一个操作直接转发到另一个操作；

- 功能单元的性能：
  - 延迟：完成运算所需要的总时间
  - 发射时间：两个连续的同类型的运算之间需要的最小时钟周期数；
  - 容量：能够执行该运算的功能单元的数量；（一个单元可以是一个流水线）

- **对于容量为C，发射时间为I的操作来说，处理器可能获得的吞吐量为每时钟周期C/I个操作**；（所以按照吞吐率来说CPE极限是吞吐量的倒数，是I/C）

- 加载单元从另一方面限制了吞吐量极限，例如有4个加法单元，加法指令发射间隔为1周期，则理论上CPU每周期可以执行4条加法指令；但假设加载单元只有2个，则每周期最多也就2条加法指令；

- 由于数据相关，一般CPE的极限是延迟；（例如for循环执行acc = acc * v[i]，由于每次acc都要用到上一次的acc，因此有数据相关，因此CPE极限是延迟）

- 书上的例子，加法的延迟是1，发射时间是1，而单元数量是2，因此吞吐量极限是2，但实际的for循环由于数据相关，CPE是1.27，将循环展开（减少了一些其它非必要的计算时间后），CPE就变为了1.01；

  

- 如果将acc = acc * v[i]的操作改成 acc0 = acc0 * v[i] 与 acc1 = acc1 * v[i+1]，最后再把acc0 和 acc1乘起来，那么就可以突破之前”CPE极限是延迟“的说法；（现在的CPE极限是延迟的一半了，因为关键路径上面的乘法减半）

- 上面的拆成两个acc0和acc1的做法叫做2x2循环展开，**一般有k*k循环展开，当k足够大时，CPE的极限就逐渐接近于吞吐量极限了**。但是k太大了反而会降低CPE，因为要对这些中间变量进行存储；

  书上说编译器不大可能采用这种kxk的变换；

  kx1是指循环展开k个计算，但是只有1个不相关的指令，即这个k个全是顺序相关的；

  kxk则是指展开的k个计算中有k个可并行的指令；

- 注意浮点数的结合律（即axbxc与ax(bxc)的结果）会有一点不同。（这也是为什么一般编译器不会随便从浮点数的运算顺序这个角度去优化）

  但结合律带来的速度影响也十分明显，在书中acc = acc * v[i] * v[i+1]比acc = acc * (v[i] * v[i-1])慢了一倍！因为v[i] * v[i-1]运算与其他值无关，可以并行化（并不在关键路径上）

- 如果采用向量指令（SSE或AVX等），例如vmulps 一下子可以进行8个32位的乘法或4个64位的乘法，则吞吐量极限可以进一步除以8或除以4；



- 在有2个加载单元的机器上，每个被计算元素必须加载k个值的应用，不可能获得低于k/2的CPE；（假设1个加载单元1个周期加载1个元素）

- 对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些操作；

  对于内存操作，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他的哪些指令。

  在处理机中的存储单元中有存储缓冲区，写操作只需要写好addr和data就可以，后面的读操作会优先在存储缓冲区找对应addr的数据，如果命中则不需要读内存，直接返回存储缓冲区中的data值就可。

  读内存被翻译成微指令load，而写内存则翻译成s_addr和s_data。

  - 在相邻的两条读写内存指令，如果地址不相同，则load和上一条指令的s_addr、s_data也就不相关，那么CPE就会很低；
  - 如果地址相同，则load必须等待上一条指令的s_data完成（s_data肯定要等s_addr完成否则不知道写到哪），那么CPE就会很高。



总结：性能提高的技术

- 高级设计：选择合适的算法和数据结构
- 基本编码原则：
  - 消除连续反复的函数调用
  - 消除不必要的内存引用
- 低级优化。结构化代码以利用硬件功能
  - 展开循环，降低开销，使得进一步的优化成为可能；
  - 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行；
  - 用功能性的风格重写条件操作，使得编译采用条件数据传送；



- 代码剖析工具可用来知道应该优化什么地方。Amdahl定律