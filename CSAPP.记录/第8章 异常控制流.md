- ECF是异常控制流

- 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号；

  系统启动时，操作系统分配和初始化一张称为**异常表**的跳转表，使得表目k包含异常k的处理程序；

  异常表的起始地址放在一个叫做**异常表基址寄存器**的特殊CPU寄存器中；

- 如果控制从用户程序转移到内核，所有这些项目（返回地址，寄存器那些）都被压到内核栈；
- 异常处理程序运行在内核模式下，意味着它们对所有的系统资源都有完全的访问权限；
- 异常类别：

| 类别 | 原因             | 异步/同步 | 返回行为             |
| ---- | ---------------- | --------- | -------------------- |
| 中断 | 来自IO设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | 有意的异常       | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误 | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误   | 同步      | 不会返回             |

异步是指来自外部，同步异常是执行一条指令的产物；

故障会转移到故障处理程序，如果处理程序能修正这个错误情况则可以将控制返回到引起故障的指令，否则返回到abort例程；

（缺页算是故障）

终止就一定会转到abort例程；



- 在x86中，Linux系统调用都是：%rax保存系统调用号，%rdi、%rsi、%rdx、%r10、%r8和%r9包含最多6个参数；

- 处理器通常是用某个控制寄存器中的一个**模式位**表明在用户模式还是内核模式，没设置模式位，就是用户模式，否则是内核模式；

- Linux中/proc文件系统允许用户模式进程访问内核数据结构的内容；/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构；

- 进程上下文：通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构；

- getpid得到自己进程id，getppid得到父进程的进程id

- 从程序员角度看进程的三种状态：

  - 运行：在CPU上正被执行 or 未被执行但可以被调度

  - 停止：进程被挂起，不会被调度，收到SIGCONT信号才会进入运行态；
  - 终止：进程永远地停止；

- 回收子进程：进程终止了会进入终止状态，称为“僵死进程”，仍然消耗系统的内存资源；必须由它们的父进程回收（子进程的退出状态传给父进程，然后抛弃已终止子进程）；

  如果子进程还好好的，父进程终止了，则内核会安排init进程成为其养父；同样地，如果一个进程终止的时候还未去回收其僵死子进程，则会由init进程去回收这些僵死子进程；

  waitpid函数可以等待其子进程终止或停止，返回值是一个导致waitpid返回的已终止子进程的pid；

  waitpid的参数options，如果是WNOHANG则waitpid会立即返回，返回为0则代表没有已终止的子进程，WUNTRACED是阻塞直到一个子进程终止或停止，WCONTINUED是阻塞直到一个子进程终止或一个被停止的进程收到SIGCONT信号重新开始执行；

  waitpid的参数*statup得到的是子进程终止/停止的原因；

  waitpid的参数pid是要等待的子进程的id，如果为-1则是等待任意一个子进程；

- execve函数接收一个可执行目标文件名filename，argv，envp，其中argv[0]一般就是文件名，envp中全是"name=value"形式的字符串；

  可通过Linux中的getenv，setenv，unsetenv来获取参数；

- 信号是一种通信的东西，之前我们看到的低层的硬件异常是由内核异常处理程序处理的，正常情况下我们的程序都看不见；而信号则是一种通知我们进程发生了这种硬件异常的通讯信号；

- 转储内存（dumping core）是一个历史术语，意思是把代码和数据内存段的映像写到磁盘上；

- 信号术语：

  - 发送信号的方式：
    - 内核检测到一个系统事件，例如除零错误
    - 一个进程调用了**kill函数**；一个进程可以发送信号给它自己；

  - 接收信号，当一个进程被内核强迫以某种方式对信号的发送做出一种反应，就算接受了信号
    - 一个发出而没被接受的信号叫待处理信号，在任何时刻一种类型至多只会有一个待处理信号；
    - 内核中，一个进程有位向量pending，上面的第k位代表是否有一个类型为k的信号，而进程中还有个位向量blocked，上面的第k位代表是否阻塞类型为k的信号；

- Unix中的信号机制是基于进程组这个概念，每个进程都属于一个进程组，进程组有进程组id（其实进程组id就是其中一个进程的id）

  - setpgid(pid_t pid, pid_t pgid)函数将设置进程pid的进程组id为pgid，如果pid=0则就是当前进程，如果pgid=0则就是pid指定进程id的pid作为组id；
  - 因此setpgid(0,0)将创建一个新进程组，其组id就是当前进程id；

- 通过kill程序发送信号：kill -sig pid，向pid的进程组发送sig信号，例如"kill -9 123"

- Linux中kill函数如果pid>0则给指定pid的进程发送信号，如果pid=0则是给调用进程所在的进程组中每个进程发送信号，如果pid<0则是给|pid|的进程组所有进程发信号；

- Linux中alarm(unsigned int secs)函数，在secs秒后给自己的进程发送一个SIGALARM信号，alarm返回的是上一个未触发的alarm距离触发还剩多少秒的秒数；（如果没有待触发的上一个alarm则返回0）

- ctrl+c发送SIGINT信号，ctrl+z发送SIGSTOP信号；子进程终止或停止向父进程发送SIGCHLD信号；

- unix shell采用作业job来表示为一条命令行求值创建的进程，在任何时候至多只有一个前台作业和0个或多个后台作业，例如键入"ls | sort"则创建三个进程，一个前台进程，两个后台进程ls和sort，中间用管道连接它们的通信，这三个进程的pgid都相等（相当于三个进程是一个进程组），且pgid都是前台进程的pid；

- 信号有如下4种默认行为：

  - 进程终止
  - 进程终止并转储内存
  - 进程停止直到被SIGCONT信号重启
  - 进程忽略该信号

- signal(int signum，sighandler_t handler)将signum信号的信号处理程序设置为handler

  - 如果handler为SIG_IGN则将忽略signum
  - 如果handler为SIG_DFL，那么类型为signum的信号行为恢复为默认行为；
  - 否则handler就是哥函数地址；

- Linux提供隐式阻塞信号和显式阻塞信号的机制：

  - 隐式就是说在正在处理信号s时又来了个信号s，则信号s会被阻塞（不被接收）直到处理完毕
  - 显式就是说可以通过sigpromask等函数明确阻塞和解除阻塞选定的信号；

- 编写异步信号安全的函数：

  - 处理程序尽可能简单

  - 处理程序只调用异步信号安全的函数，

    - 异步信号安全的函数要么是可重入的（例如只访问局部变量），要么处理程序是不可中断的

      常见的printf，sprintf，exit都是不安全的，但_exit、write等就是安全的；

  - 保存和恢复errno

  - 阻塞所有信号

  - 用volatile声明全局变量

  - 用sig_atomic_t声明标志，sig_atomic_t可以保证变量的单个读和写是原子的，不代表++操作等是原子的；

- sigsuspend(const sigset_t* mask)等价于

  ```c++
  sigprocmask(SIG_SETMASK, &mask, &prev);
  pause();
  sigprocmask(SIG_SETMASK, &prev, NULL);
  ```



- 非本地跳转

  int setjmp(jmp_buf env)函数相当于在此刻设置了传送点（将此时系统状态的快照存储到env中）；第一次调用后会继续执行后面的代码；

  void longjmp(jmp_buf env，int retval)相当于就是传送到之前已经设置好的传送点，retval参数就是setjmp函数的返回值（相当于传送门的入口是longjmp，出口是setjmp）

  - sigsetjmp和siglongjmp是setjmp和longjmp可以被信号处理程序使用的版本；

- C++和Java中的Catch或Throw语句就分别类似setjmp和longjmp；