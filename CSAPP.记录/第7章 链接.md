- 链接可以执行于编译时、加载时、运行时；

- 现代系统中，链接是由链接器自动执行；

- 链接器可以使一个大型程序模块化，即修改其中一个模块时，只需简单地编译模块，再链接应用，不必重新编译其它文件；

- 大多数编译系统提供编译器驱动程序，代表用户在需要时调用语言预处理器、编译器、汇编器、链接器；

- 在shell中输入"./xxx"则shell调用OS中叫加载器的函数，将可执行文件xxx中的代码和数据复制到内存，然后将控制转移到这个程序的开头；(shell进程创建子进程，子进程调用execve函数启动加载器，加载器删除子进程现有的虚拟内存段，再创建新的——将要执行的可执行目标文件映射到对应内存页，注意是用时才从磁盘复制到内存中)

  Linux程序可通过调用execve函数来调用加载器；

- Linux LD程序是一种静态链接器；

- 链接器的两个主要任务：
  - 符号解析：就是分析出各种符号定义和符号引用，把每个符号引用和对应的符号定义关联起来。
  - 重定位：在链接器之前，编译器和汇编器生成的是从地址0开始的代码和数据节，链接器将每个符号定义与一个内存地址关联起来，然后修改所有其它的符号引用使得它们指向这个内存位置；

- 目标文件又三种形式：
  - 可重定位目标文件：包含二进制代码和数据，其形式可以在**编译时**与其他可重定位目标文件合并起来，创建一个可执行目标文件；
  - 可执行目标文件：包含二进制代码和数据，可以直接被复制到内存并执行；
  - 共享目标文件：一种特殊类型的可重定位目标文件，可以在**加载或者运行时**被动态加载进内存并链接；

- ELF全称Executable and Linkable Format

- ELF格式：ELF头、各个节、节头部表；（节头部表中每一项记录代表了一节的各种信息，例如节的位置、大小）

- 典型的节有：

  .text：机器代码

  .rodata：只读数据，例如printf中的格式串和开关语句的跳转表；

  .data：已初始化的全局和静态C变量；

  .bss：未初始化（或者初始化为0）的全局和静态C变量；（在目标文件中.bss并不占据任何实际的磁盘空间，运行时在内存中分配这些变量并初始化为0）

  .symtab：符号表，存放在程序中定义和引用的函数和全局变量的信息，并不存放局部变量的信息！

  ​	.symtab中又分为：

  - 被当前模块定义的全局符号
  - 由其他模块定义的全局符号
  - 被当前模块定义的、带static属性的全局符号

  .rel.text：一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。（一般来说，这些位置指向的指令都是调用外部函数或者引用了全局变量）

  .rel.data：被模块引用或者定义的所有全局变量的重定位信息；

  .debug：一个调试符号表，就是各种符号，例如局部变量、类型定义、程序中定义和引用的全局变量和C源文件（只有以debug模式，即“-g”选项调用编译器驱动程序时才会得到这张表；）

  .line：原始C源程序中的行号和.text节中机器指令之间的映射，同样地只有在调试模式下才有这张表；

  .strtab：字符串表，包括.symtab和.debug的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列（可能就是存字符串的位置，前面的所有表示字符串的地方实际就是个指针指向了.strlab中的某个位置？）

- 在.symtab中每一条记录中包含：name（从.strtab字符串表起始开始的offset），section（代表这个符号属于哪一节，其中还包含三种虚空节：ABS代表不被重定位的符号，UNDEF代表来自外部模块的变量，COMMON代表还未被分配位置的未初始化的数据目标），value（代表这个符号距离其所在的节的offset，如果是**可执行目标文件**value是一个绝对运行时地址），size（这个符号代表的元素的大小）

- 注意在**可执行目标文件**中，因为所有模块都已链接好，因此不存在ABS、UNDEF、COMMON这几种。

- COMMON中是“未初始化的全局变量”

  .bss中是“未初始化的静态变量，以及初始化为0的全局或静态变量“

- C++或Java中对重载函数通过重整的方法来生成一个唯一的名字，例如类Foo就生成3Foo（前面的数字代表类字符数），而方法的名称则是原始方法名，后面加上"__ "，加上被重整的类名，再加上每个参数的单字母编码，例如Foo::bar(int, long)被编码成bar__3Fooil；



- 链接器的输入是一组可重定位的目标模块，如果遇到多个模块定义同名的全局符号：
  - 编译时，编译器向汇编器输出每个全局符号，或者是**强**、或者是**弱**，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里；
  - 函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号；
  - **Linux链接器根据以下规则来处理多重定义的符号名**：
    - 不允许有多个同名的强符号
    - 如果有一个强符号和多个弱符号同名，那么选择强符号；
    - 如果有多个弱符号同名，那么从这些弱符号中任意选择一个；
- GCC -fno-common告诉链接器，在遇到多重定义的全局符号时，触发一个错误；
- GCC -Werror，将所有警告变成错误；

- 上面的多重定义处理规则也解释了为什么之前要强行把未初始化的全局变量划分为COMMON而非.bss，因为在遇到未初始化的全局变量时，这是一个弱符号，而所有静态变量的构造必须唯一，有初始化的全局必在.data或.bss（如果初始化为0），因此这两类都算是确定的，就编译器知道该放到.bss或.data，而未初始化的全局变量则必须划分为COMMON，把决定权交给链接器；



- 静态库，相关的库函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件(.a文件，PS：一般的目标模块文件是.o文件，而静态库文件实际算是多个.o文件组织而成)。

  静态库的好处就是，链接器将只复制库函数中被用到的函数和用户写的目标模块组装成可执行文件。减小了可执行文件在磁盘和内存中的大小；

- 链接器在处理输入行中的每个文件时，是从左到右进行扫描的，即若foo.c用到了libx.a则必须 "gcc foo.c libx.a"不能"gcc libx.a foo.c"

  如果libx.a用到了liby.a，而liby.a又用到了libx.a则 “gcc foo.c libx.a liby.a libx.a"；



- 一旦链接器完成符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来；此时链接器就知道它的输入目标模块中的代码节和数据节的确切大小；就可以开始重定位（合并输入模块，为每个符号分配地址）

- 重定位(relocation)分为两步：

  - 重定位节和符号定义：先合并所有同名节（例如各个.data节合并在一个.data），合并后每个符号就有了地址；
  - 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址；（要实现这一步要用到”重定位条目“的数据结构）

- 重定位条目：（**汇编器生成一个目标模块时，并不知道这个符号最终的位置，因此它会生成一个重定位条目，注意这一步不是链接器做的事，是汇编器在生成单个.o文件就做好了**）

  重定位条目中记录该符号距离节起始地址的偏移，以及该符号在符号表中的index等；

  **重定位条目就说ELF文件中的.rel.text和.rel.data**；

- x86-64小型代码模型：假设可执行目标文件中的代码和数据总体大小小于2GB；

  更大的有-mcmodel=medium或-mcmodel=large；

- 重定位的过程就是：

  - 先把所有.o文件合并了，这样就为每个符号找到内存位置；（此时每个符号定义有了个地址，每个符号引用有了个重定位条目）
  - 然后就是按照符号地址，以及重定位条目去把代码中的每个符号引用改为相对应的值（就是用到相对地址就算出相对地址，用到绝对地址就写上绝对地址）

  

- 可执行目标文件的ELF头中有入口点，就是代码要执行的一句语句的地址；

  可执行目标文件的ELF中在ELF头的下面多了一个“段头部表”，这个段头部表就是纯粹用来描述程序中 只读段、读写段的内存位置（以及它们在文件中的逻辑位置），只读段包含了许多连续的节（例如.init，.text，.rodata，这里的.init是可执行目标文件特有的用来初始化的代码），对于那些不需要装进内存的节，就不会被段头部表描述；

- 入口点就是_start 函数地址，该函数在系统库ctrl.o中定义， _start函数调用系统启动函数 __libc_start_main，该函数定义在系统库libc.so中，其负责初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候把控制返回给内核；

- 共享库：

  比静态库更高级，因为静态链接会把一些常用的函数例如printf反复复制到各个文件中，占用大量内存资源，而共享库就是动态链接，在Linux中是.so文件，在Windows中是.dll文件；

  动态链接并不会在创建可执行目标文件时就完成，而是在启动时有加载器去最终完成动态链接的最后一步，在生成时链接器只是复制了一些重定位和符号表信息供加载器使用。在运行时，首先可执行的文件中会有.interp节，这个节中包含的是一个动态链接器的路径，而加载器就会去加载和启动这个动态链接器，这个动态链接器再去重定位每个.so文件，以及重定位每个对.so文件定义的符号的引用，最后动态链接器将控制传递给应用程序；

- gcc -shared告诉生成一个共享库文件，-fpic告诉生成与位置无关的代码
- Linux系统中为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库，dlopen、dlsym、dlclose、dlerror函数；
- 共享库一般是用-fpic生成的与位置无关的代码(PIC），使得可以把它们加载到内存的任何位置而无需链接器修改；
  - PIC数据引用，就是构建一个全局偏移量表GOT，例如我想用其他模块定义的变量a，则假设GOT[0]是这个变量的条目，那么GOT[0]中存放的就是变量a的地址，而在实际代码中我们只需要(*GOT[0])就可以用到变量a，而GOT[0]中a的地址则是由动态链接器在链接时重定位的（填上的）；
  - PIC函数调用，采用的是延迟绑定的技术，构建一个过程链接表PLT，同样也要用到GOT，比如我想用库函数add，则在代码中用*GOT[4]来代表add函数的地址，GOT[4]中一开始存放的地址指向的指令是“跳转到动态链接器”的指令，当第一次运行add时就会去先调用动态链接器，动态链接器会找出add的真正地址，并把它写回到GOT[4]中，这样下一次调用add就可以执行add函数了
- 打桩机制：截获对共享库函数的调用，取而代之执行自己的代码；
- 编译时打桩：gcc中-I.参数告诉编译器会进行打桩，必须在搜索通常的系统目录之前，先在当前目录中查找。
- 链接时打桩：gcc中--warp add告诉编译器把add函数引用解析成__warp_add，而把 _ _real_add解析成add；
- 运行时打桩（只了解）：用LD_PRELOAD