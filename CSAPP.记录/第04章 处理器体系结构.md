- ISA在处理器行为和如何实现处理器之间提供了一层抽象。ISA提供了程序执行的一种顺序说明，也就是一条型完了下一条指令才会开始。

| CISC                                             | RISC                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| 指令数量多                                       | 指令数量少                                                   |
| 有些指令延迟很长                                 | 没有较长延迟的指令                                           |
| 编码长度可变                                     | 编码固定长度                                                 |
| 寻址方式多样                                     | 一般只有基址和偏移量寻址-                                    |
| 可对内存中的操作数进行算术或逻辑运算             | 只能对寄存器，靠load和store                                  |
| 对机器级程序来说实现细节不可见                   | 细节可见，例如有些RISC机器禁止某些特殊的指令序列             |
| 有条件码                                         | 无条件码，对条件检测来说，要用明确的测试指令，这<br />些指令会将测试结果放在一个普通的寄存器上 |
| 栈密集的过程链接，栈被用来存取过程参数和返回地址 | 寄存器密集的过程链接。寄存器被用来存取过程参数和返回地址     |

- 在当前的技术中，逻辑1用1.0伏特，逻辑0用0.0伏特；

- HCL是硬件控制语言，用来描述硬件设计的控制部分；

  HDL是硬件描述语言，用来描述硬件结构；

  HCL可以转换成Verilog，结合基本硬件单元的Verilog代码就能产生HDL描述，根据这个HDL描述就可以合成实际能够工作的微处理器。

- 很多逻辑门就组成一个网，称为组合电路；

- HCL中将所有字级信号都声明为int，不指定字的大小；

- HCL中的多路复用函数是用{select1:expr1; select2:expr2;...}表示的，且多个select可以有多个同时为1，但是排在前面的优先，例如你可以在底下弄个“ 1: expr i ”代表default；

  但翻译成硬件时多个条件必须互斥；

- bool s1 = code == 2 | code == 3; 等价于 bool s1 = code in {2, 3};

- 六大阶段：（和计组教的略微不同，一般我们老师上课讲的只有五个阶段，更新PC属于写回阶段）
  - 取指：根据PC去内存里读指令，取出icode（指令代码）和ifun（功能代码）；
  - 译码：从寄存器文件读入最多两个操作数，得到值valA和valB；
  - 执行：一些指令利用ALU执行计算（包括栈指针的增加和减少）；在此阶段也可能设置条件码；条件传送指令在此阶段检验条件码和传送条件，如果条件成立就更新目标寄存器；条件跳转指令在此阶段决定是不是应该选择分支；
  - 访存：将数据写入内存，或者从内存中读出数据；
  - 写回：写回阶段最多可以写两个结果到寄存器文件；
  - 更新PC：将PC设置成下一条指令的地址；
- 从不回读原则：处理器从不需要为了完成一条指令的执行而去读由该指令更新了的状态，意思就是说可以把中间计算出的值直接拿来用别存了又读； 



- 吞吐量 = 1条指令/1条指令执行的时间；
- 从头到尾执行一条指令所需的时间为延迟latency；
- 流水线的局限性：
  - 不一致的划分：即有些阶段耗时长，有些阶段耗时短，就必须以最大的为准；
  - 流水线过深：流水线过深导致流水线不同阶段间的寄存器过多，而数据流经这些寄存器就会有额外的耗时；
- 数据相关、控制相关；

- 电路重定时：重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为，通常用它来平衡一个流水线系统中各个阶段之间的延迟；

- 现代处理器的取指单元中可以设置一个硬件栈，用来保存函数调用的返回地址，每当遇到ret指令时就可以直接从这个硬件栈中弹出顶部的值作为预测的返回值即可；（仍然有可能预测错误）

- 数据相关，控制相关；对应的有 数据冒险、控制冒险；

  控制冒险：更新和读取程序计数器之间的冲突导致了控制冒险；当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时就会出现控制冒险；一般在跳转指令、ret指令时会出现控制冒险；

  

- 用暂停来避免数据冒险；

  暂停时，后面的指令会继续执行，而前面的所有指令则都会重复某一阶段；

- 用转发来避免数据冒险：

  最极限的情况：从执行阶段的ALU直接送给马上要进入执行阶段的指令；

  - 转发解决不了的数据冒险：load/use 冒险

    上一条指令要在最后一个写回阶段（访存阶段结束后）才有从数据存储器中读出的值，而下一条指令想在执行阶段就拿到这个值，因此这种数据冒险通过转发是解决不了的；

  - 解决办法：加载互锁：就是在转发的技术之上又使用了暂停技术；

    暂停+转发的技术可以解决任何冒险；

- 用暂停+转发来避免控制冒险：

  当我们对条件跳转指令预测失败时，就会在后面的相应阶段中插入气泡，同时取出应该执行的指令（相当于将不该执行的指令的后半部分用气泡替代了）

- nop与气泡的区别：有些时候nop就是气泡，但在书中这两者略有区别，nop算是一条指令会更新流水线间的寄存器，而气泡bubble则不会影响任何寄存器；



- 问题一：在流水线中可能同时有多条指令会引起异常，一般来说，由流水线中最深的指令引起的异常，优先级最高。因为一般来说前面的指令出现异常则后面的指令根本不该被执行；
- 问题二：有时候提前预测的指令会导致异常的发生，但是实际上后面这条指令又不该发生，这时就需要避免出现异常；
- 问题三：有时候前面的指令会出现异常，但后面的一个指令正处于执行阶段，这样后面的指令就会影响条件码，而这也是不应该的；



- 在流水线中如果发现有异常，则应禁止后面的指令更新条件码寄存器或是数据内存；（解决问题三）
- 流水线中不同阶段之间的寄存器中的状态码如果有异常，不会产生任何效果（只会禁止后面的指令更新条件码或数据内存），直到这个指令到达最后的流水线阶段时才会被处理异常（解决问题一）
- 如果一个引发异常的指令在后面被取消了，则会被气泡替代，其寄存器中存储的异常状态码也会被取消；（解决问题二）



- 在设计转发逻辑时，例如要取%rdx的值，如果发现前面的多个指令都有写%rdx，则应该取最近的一个指令的值，即先检测执行阶段的转发源，然后是访存阶段，最后是写回阶段。

- 流水线控制逻辑：
  - 加载/使用冒险：在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期；
  - 处理ret：流水线必须暂停直到ret指令到达写回阶段
  - 预测错误的分支：在分支逻辑发现不应选择分支之前，分支目标处的几条指令已经进入流水线了，必须取消这些指令，并从跳转指令后面的那条指令开始取指。
  - 异常：当一条指令导致异常，我们想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段时，停止执行整个cpu。

- 针对流水线特殊情况的处理方法设计思路：1.找出触发这些特殊情况的条件，2.写出在这种特殊情况下各个阶段流水线寄存器应该怎么做。注意：一些特殊情况可能不止持续一个周期，可能多个周期，比如“处理ret”这个特殊情况，就会持续3个周期，只要ret的icode（ret指令前4bit）在D译码、E执行、M访存阶段的寄存器中就会触发这个特殊情况，因此各个阶段流水线寄存器也会重复做3次特殊操作，例如F阶段（取指）就要暂停3个周期，而D阶段（译码）就要插3个气泡，而后面EMW三个阶段则一直是正常的，因此D阶段产生的气泡会正常地往后面走。

- 当高速缓存不命中时，如果较低层存储（例如内存）命中的话，一般流水线会暂停等一会儿就好了；而如果内存都不命中的话，则硬件就会产生一个缺页异常信号，程序被挂起，然后之后（上百万个周期后）程序会再次执行导致缺页的指令，此时估计还是会造成高速缓存不命中，但不会再去缺页异常了。

