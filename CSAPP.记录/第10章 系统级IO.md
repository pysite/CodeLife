### Unix IO

- Linux shell创建的每个进程开始时都有三个打开的文件：标准输入0、标准输出1、标准错误2；
- 对于每个打开的文件，内核保持着一个文件位置，类似cursor那种；通过seek可以改变文件当前位置k；读超过了文件大小时会触发一个称为end of file(EOF)的条件；



### 文件

- 书中涉及到的文件类型：
  - 普通文件：文本文件 or 二进制文件
  - 目录文件
  - 套接字socket



- open函数总是返回的是还没打开的最小描述符；
- read函数返回读取的字符数，如果返回-1则是出错，返回0代表EOF；
- x86-64中size_t是unsigned long而ssize_t中前面的s代表signed因此ssize_t是long；
- read(fd, buf, size)有时候返回的值比size小，原因有：
  - 读时遇到EOF
  - 从终端读文本行（每次读一行，遇到"\n"）
  - 读和写socket（受网络影响）



### RIO

- RIO库提供了两种函数：不带缓冲的输入输出函数；带缓冲的输入函数；
- 都是带缓冲的函数rio_readlinb和rio_readnb可以交叉进行，而不带缓冲的rio_readn不可；
- rio_readn（不带缓冲，循环调用read直到读完size个字节）
- rio_read（带缓冲地读，当缓冲区为空时就调用UnixIO中的read函数试图填满缓冲区）
- rio_readlineb（其中调用rio_read，循环读直到遇到'\n'）
- rio_readnb（其中调用rio_read，循环读直到读完size个字节）

- **所谓缓冲就是为了减少开销较高的Linux IO系统调用的次数**，例如我们的程序需要调用read 100次，每次读1字节，则带了缓冲的就可以在第一次调用时就把后面的所有数据取到了缓冲区中，因此后面99次read都是读取缓冲区的数据；



- stat函数以一个文件名作为输入并填写stat结构；
- fstat和stat类似，只不过fstat接收的函数参数是int fd



- opendir函数接收一个文件夹的路径，返回一个DIR结构体，俗称**目录流**，对DIR结构体调用readdir函数返回的就是一个dirent（读完最后一个dirent后返回值为NULL）



### 共享文件

内核用三个数据结构来表示打开的文件：

- **描述符表**：每个进程一个描述符表，描述符fd就是int值，每个int代表描述符表中的下标，代表一个描述符表项，每个描述符表项指向**文件表**的一项；

- **文件表**：所有进程共享这个表，每一项包括当前文件位置、引用计数、以及一个指向vnode表中的指针。关闭一个文件会减少文件表表项中的引用计数，直到计数为0，内核才会删除该文件表表项；
- **v-node表**：每个表项包含了stat结构中的大多数信息；vnode应该就类似inode；

多个描述符可以通过不同的文件表表项引用同一个文件；因为每个文件表表项都有它自己的位置，对于不同的描述符就可以在不同位置上操作；



- Linux中IO重定向是通过int dup2(int oldfd, int newfd)来完成的，先将newfd关闭，再将oldfd复制到newfd上，因此会导致oldfd所指的文件表引用计数加1；



### 标准IO

- 标准IO就是指fopen、fclose、fread、fwrite、fgets、fputs以及scanf、printf；

- 标准IO将每个打开的文件模型化为一个流，用结构体FILE表示；

  ```
  FILE *stdin;
  FILE *stdout;
  FILE *stderr;
  ```

- FILE文件流其中也有缓冲区减少IO系统调用次数；



- 注意RIO库是书中自己开发的基于标准UnixIO的一种示例，而标准IO则是C语言中基于UnixIO的一个带缓冲的替代品；

- 能用标准IO就用标准IO
- 不用scanf或readline函数读取二进制文件，因为这两个函数都是为文本文件设计的
- 对socket还是用我们之前那种RIO库函数，因为要循环读取；



标准IO流（即FILE），应该是全双工的，因为程序能在同一个流上进行输入和输出，但是由于文件流的特性会有一些限制：

- 跟在输出函数之后的输入函数，如果中间没有插入对fflush、fseek、fsetpos或rewind的调用，则一个输入函数不能跟随在一个输出函数之后
- 跟在输入函数之后的输出函数，如果中间没有插入对fseek、fsetpos或rewind调用，则一个输出函数不能跟在一个输入函数之后；

（具体原因未说）解决办法如下：

- 情况一：每次输入函数之前调用fflush

- 情况二：对socket调用lseek函数非法，因此只能对于一个socket同时调用fopen函数打开两次得到两个流FILE，一个用来写一个用来读；（但是对于这样就需要调用两次fclose，而实际上第一次fclose就会关闭一个底层的socket描述符，所以第二次fclose实际是不合适的）



```
int fflush(FILE *stream);

如果stream指向输出流或者更新流（update stream），并且这个更新流最近执行的操作不是输入，那么fflush函数将把任何未被写入的数据写入stream指向的文件（如标准输出文件stdout）。否则，fflush函数的行为是不确定的。fflush（NULL）清空所有输出流和上面提到的更新流。如果发生写错误，flush函数会给那些流打上错误标记，并且返回EOF，否则返回0。

由此可知，如果 stream 指向输入流（如 stdin），那么 fflush 函数的行为是不确定的。故而使用 fflush(stdin) 是不正确的。
```

