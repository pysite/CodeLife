- 目标代码(.o文件)是机器代码的一种形式，包含所有指令的二进制, 但还未填入全局值的地址。
- PC寄存器：%rip；
- x86-64的虚拟地址是由64位的字来表示，在目前的实现中，这些地址的高16位必须为0；
- 字一般是双字节，所以int是双字大小；



- x86-64一般有16个通用寄存器，rax、rbx、rcx、rdx、rsi、rdi、rbp、rsp、r8~r15，其中rax这种又还有eax、ax、al这种分别代表32、16、8位的部分，而r8这种的则是r8d、r8w、r8b命名。
- 操作64位寄存器的低32位，则前32位会被置为0，改变低16位、8位则前面的位不会改变。
- 立即数表示方法：$0x1F
- 访问存储器的地址的最通用的表示方法：Imm(%r1, %r2, 4)表示访问存储器中地址为Imm+R[r1]+R[r2]*4的元素



- MOV指令：MOV S,D

  movb字节，movw字，movl双字（会把高32位清0），movq四字

  movabsq专门用于将64位立即数传送到指定寄存器（不可存储器）

- MOVZ指令：MOVZ S,D

  movzbw：将做了零扩展的字节传送到字；除此之外还有movzbl、movzwl、movzbq、movzwq；

- MOVS指令：MOVS S,D

  movsbw：将做了符号扩展的字节传送到字；除此之外还有上面的一套；不过还有额外的movslq（即把双字扩展到四字），之所以movz没有movzlq是因为已经有个movl能把高32位置0了；

  **凡是生成4字节的数据并以寄存器作为目的的指令会把寄存器的高4字节也置0**；

- CLTQ指令：把eax符号扩展到rax；

- 选择opcode要根据源操作数，如果源操作数有符号，扩展时就选s，否则选z；

- 汇编指令大全：

| 指令                                                         | 效果    |
| ------------------------------------------------------------ | ------- |
| leqa S,D                                                     | D<-&S   |
| inc D<br />(类似还有dec、neg、not)                           | D<-D+1  |
| add S,D<br />(类似还有sub、imul、xor、or、and，注意sub S,D中是D作为被减数) | D<-D+S  |
| sal k,D<br />(类似还有shl、sar、shr，其中shl和sal相同，sar是算术右移，shr是逻辑右移)<br />(注意k可以是立即数也可以是%cl，x86-64中移位是由cl寄存器的低m位决定，<br />其中2^m = w, 即salb会移位7位，salw会15位) | D<-D<<K |

- 八字(128位 oct word)操作

| 指令                                                         | 效果                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| imulq S<br />mulq和imulq类似，不过有i的是有符号乘法<br />两种imulq，编译器根据操作数个数判断是哪一个 | R[%rdx]:R[%rax]<-S*R[%rax]                                   |
| cqto                                                         | R[%rdx]:R[%rax]<-符号扩展(R[%rax])                           |
| idivq S<br />divq和idivq类似，不过有i的是有符号乘法          | R[%rdx]<-R[%rdx]:R[%rax] mod S<br />R[%rax]<-R[%rdx]:R[%rax] ÷ S |

- ```c++
  //包含以下三个头文件中任意一个，就可以保证使用uint32_t类型
  <inttypes.h> 
  <stdint.h>
  <cstdint>
  ```

- CF**无符号溢出标志，**ZF零标志，SF负数标志，OF**有符号溢出标志**；
- leaq不改变任何标志，逻辑操作会将进位标志和溢出标志置为0，移位操作会把进位标志设置为最后一个被移出的位（而溢出标志被置为0），INC和DEC会设置溢出和零标志（但不会改变进位标志）

- 条件码测试指令

| 指令                         | 效果                                          |
| ---------------------------- | --------------------------------------------- |
| CMP S1,S2<br />cmpb、cmpw... | s2-s1并置相关标志位（但不影响任何寄存器的值） |
| TEST S1,S2<br />testb、testw | s2&s1并置相关标志位（但不影响任何寄存器的值） |

- 条件码访问指令

| 指令                                                         | 效果                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| sete D、setz D<br />setne D、setnz D                         | 就是看ZF                                                     |
| sets D<br />setns D                                          | 就是看SF                                                     |
| setg、setnle（有符号>）<br />setge、setnl（有符号>=）<br />setl、setnge（有符号<）<br />setle、setng（有符号<=） | g：D<- ~(SF^OF)&(~ZF)<br />ge：D<- ~(SF^OF)<br />l：D<- (SF^OF)<br />le：D<- (SF^OF)\|ZF |
| seta、setnbe（无符号>）above<br />setae、setnb（无符号>=）<br />setb、setnae（无符号<）below<br />setbe、setna（无符号<=） | a：D<- ~CF&~ZF<br />ae：D<- ~CF<br />b：D<- CF<br />be：D<- CF\|ZF |

set指令的目的操作数寄存器只能是单字节寄存器，例如al，bl。

- 跳转指令

| 指令                                                         |
| ------------------------------------------------------------ |
| jmp Label<br />jmp *operand （ *表示间接跳转，jmp *%rax，即跳转目标是从寄存器或内存位置中读出的) |
| je、jne、js、jns、jg、jge、jl、jle、ja、jae、jb、jbe         |



- 执行一条指令时pc中存的是下一条指令的地址，而jmp中的label就被翻译为单字节的补码代表offset，因此目标就是pc+offset
- rep;ret组合中rep没任何作用；（书上说是为了避免ret指令成为跳转指令目标）

- 用条件传送实现条件分支比条件控制更快，即不使用jmp指令而只是使用cmp再根据标志位进行操作的方式要快得多，因为可以满流水线；例如cmpq然后再cmovge；



- 条件传送指令（注意cmov指令不会主动比较嗷，一般在前面再用相应的cmp指令）

| 指令                                              |
| ------------------------------------------------- |
| cmove、cmovz<br />cmovne、cmovnz<br />cmovs等等等 |

不是所有条件分支都可以用条件传送来实现。条件传送就相当于把每种可能的操作都先计算一遍，最后判断条件再选择一个结果。

- while循环在gcc -og一般是jump to middle；而gcc -o1一般是guarded do；

  jump to middle就是只有末尾一个地方判断条件的while循环，而guarded do是有两个地方判断条件的while循环；



- switch通过使用跳转表这种数据结构使得实现更加高效；

- gcc中&&表示代码位置的指针，用法：&&Label



- call把call下一条指令的地址压入栈，ret则弹出到PC中；
- callq和call相同，多个q只是说明是x86-64的而非IA32的；



- x86中最多可以通过寄存器传递6个函数参数，它们依次是rdi、rsi、rdx、rcx、r8、r9；

- 当超过6个参数，从第7个参数开始就要存放到栈中，且参数7位于栈顶（因此7~n的参数是倒序压入栈内）。

  栈中的参数大小向8的倍数对齐。即在栈中一个char占的大小为8字节（64bit）；

  注意这里不是说栈中的数据大小都向8的倍数看齐，而是说用栈来传递参数时要向8的倍数看齐；

- 来到新函数中后，%rsp+8才是参数7，之所以+8是因为要跳过压入栈中的返回地址；
- 寄存器除了rsp之外分为“被调用者保护寄存器（%rbx、%rbp、%r12~%r15）”和“调用者保护寄存器”；
- (&E[i] - E) = i
- 参数中可以(int n, int a[n] [n])但n必须在a[n] [n]前面；



- 访问结构体中的某个变量，到汇编代码时就变成访问结构体首地址加上一个偏移量offset地址的数据，这个offset是由编译软件计算出来并使用的；

- 如果将一个double强制转换成unsigned long则位级表示会改变；（尽量使值不改变）

  但如果用union{double d; unsigned long u;}则d和u的位级表示相同，但值很不同；

- intel对齐原则是任何K字节的基本对象的地址必须是K的倍数；
- .align 8可以手动设定后面的数据起始地址必须是8的倍数；
- 节约结构体空间的方法之一就是将各个变量按照size的降序排列；

- 为了支持多媒体操作的SSE指令，Intel和AMD处理器malloc等任何内存分配函数生成的块的起始地址都必须是16的倍数；



对抗缓冲区溢出攻击的几种办法：

- 栈随机化：就是在每次为程序开辟stack的时候会在栈上额外随机分配0~2^n字节空间，这样来使不同机器即使运行相同的程序其程序栈地址会不同；但是这样攻击者也可以采用“空操作雪橇”的方式应对，例如假设采用2^23的随机化，攻击者的空操作雪橇的长度为2^8，则攻击者需要尝试2^(23-8)次就可以了。（雪橇就是一群空操作（类似一个捕获网），凡是落到雪橇上就会不断地执行下一条指令直到遇到攻击代码）

- 栈破坏检测：就是在为一个函数开辟栈之前在栈上先存放一个特殊的“金丝雀”值（类似guard page），凡是该函数写溢出了则金丝雀值就会改变。在函数退出到上一层时会检测这个金丝雀值是否发生改变，如果是则程序异常中止；
- 限制可执行代码区域：通过页表项PTE中的可执行标识X来限制只有特定区域的数据是可以作为指令被执行的；



- GCC为函数生成栈帧时不同的变量之间一般会有些空间因为要对齐而未被使用到；

- 变长栈帧这里就是讲要用到个rbp保存rsp就可；

  and -16就是取成16的倍数，((n+7)<<3)>>3就是向上取成8的倍数；

- **注意**函数栈帧从rbp指向的位置开始，而一般rbp+8的地方就是旧rbp，而rbp+16的地方就是返回地址；

- leave指令就是等价于movq %rbp, %rsp；popq %rbp；



- 16个浮点寄存器%ymm0~%ymm15，这些都是256位（可用于SIMD模式或AVX模式），AVX模式差不多就是向量指令那些；
- ymm寄存器的低128位是xmm寄存器，例如%xmm0~%xmm15；

| 指令    | 源   | 目的 | 描述                       |
| ------- | ---- | ---- | -------------------------- |
| vmovss  | M32  | X    | 传送单精度数               |
| vmovss  | X    | M32  | 传送单精度数               |
| vmovsd  | M64  | X    | 传送双精度数               |
| vmovsd  | X    | M64  | 传送双精度数               |
| vmovaps | X    | X    | 传送对齐的封装好的单精度数 |
| vmovapd | X    | X    | 传送对齐的封装好的双精度数 |

说明：X是代表一个xmm寄存器，M32代表32位内存范围，M64代表64位内存范围。vmovaps和vmovapd貌似没啥区别；

关于浮点数的其他操作就不用记忆，毕竟指令都很长且有些操作作者也没弄明白是为什么；



- xmm0~7可以用来传参，通过栈来传递额外的浮点参数；

  xmm0用来返回浮点值；

  所有xmm都是调用者保存，即被调用者可以随意更改；

- AVX浮点操作不能以立即数值作为操作数（相当于编译器必须为浮点立即数分配和初始化存储空间）

- 这种ss表示的，全是代表single的，而ps则代表是并行的！例如vmulps (%rdx), %ymm0, %ymm1会从(%rdx)内存处连续读8个32位值，与ymm0中8个32位值相乘后又传入到%ymm1中。