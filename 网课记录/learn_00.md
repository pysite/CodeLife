# 第一周

#### 基本

```c++
//new一个数组以及释放
int *p = new int[10];
delete[] p;
```



#### 引用

**1 引用注意事项**

+ 引用必须初始化；

+ 引用一旦初始化，不可改变；

**2 引用做函数的返回值**

```c++
int& func(){...}
int& ref = func();
```

+ 不要返回局部变量的引用

+ 函数调用可以作为左值

```c++
int& func(){
	static int a = 10;
	return a;
}
func() = 1000;	//这样是可以的
```

**3 引用的本质**

就是一个指针常量（不是常量指针）

**4 常量引用**

一般用在函数形参。

```c++
int& ref = 10; //不可以
const int& ref = 10; //可以, 相当于int temp = 10; const int& ref = temp;
```



#### 函数

**1 函数默认参数**

默认参数都是在最右；

如果函数声明有默认参数，则实现就不能再有默认参数；

**2 占位参数**

占位参数就是参数没有名称，只有个类型；

```
void func(int = 10){...} //这种写法是可以的
```

**3 重载**

函数返回值不可以作为重载的区分；

参数类型顺序不同可以作为区分；

const可以作为区分，调用的时候按照最近匹配原则；

写函数参数尽量避免设置默认参数，以防二义性；



#### 类和对象

**1 权限定义的格式**

```c++
class A{
public:
	int a;
	int b;
private:
	...
}
```

**2 struct和class区别**

唯一区别就是默认访问权限，struct是public，class是private；

**3 构造函数**

类名(){}	

构造函数可以有参数，**可重载**

构造函数按照参数分为 无参构造 和 有参构造；默认构造是无参的；

构造函数按照类型分为 普通构造 和 拷贝构造（拷贝构造的参数是就是该类的一个对象）；

```c++
//拷贝构造函数
类名(const 类名 &a){}
```

构造函数的调用分为**括号法**、**显式法**、**隐式转换法**：

```c++
//************括号法************
类名 a;		//无参构造
类名 b(10);	//有参构造
类名 c(a);	//拷贝构造

//不可以如下, 因为编译器会认为是一个函数的声明
类名 d();		//你以为是调用无参构造, 但其实不是

//************显式法************
//假设类名为Person
Person p1 = Person(10);	//有参构造
Person p2 = Person(p1);	//拷贝构造
Person(10);	//匿名对象 当前行执行完该匿名对象立即被释放

//不可拷贝构造函数初始化匿名对象
Person(p2);	//编译器会认为这是对象的声明, 因此可能会出现重定义

//************隐式转换法************
Person p3 = 10;	//有参构造 相当于Person p3 = Person(10)
Person p4 = p3; //拷贝构造
```



拷贝构造函数被调用的三种情况：

+ 使用一个已经创建完毕的对象初始化一个新对象；
+ 值传递的方式给函数参数传值；
+ 以值方式返回局部对象；



默认情况，编译器至少给一个类添加3个函数

+ 默认构造函数（无参，函数体为空）
+ 默认析构函数（无参，函数体为空）
+ 默认拷贝构造函数（对属性进行值拷贝）

如果用户定义有参构造函数，C++不再提供默认无参函数；

如果用户定义拷贝构造函数，C++不再提供其它构造函数；



浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

通过**自己实现拷贝构造函数**，解决浅拷贝带来的问题；



**4 析构函数**

~类名(){}

析构函数不可以有参数，**不可以重载**

析构函数可以负责将该类的堆区数据给释放掉；



**5 初始化列表** （有个冒号）

初始化列表可用来对类中的const值进行初始化，同时也提高了性能；

```c++
//构造函数():属性1(值1)，属性2(值2)...{}
//例如：
A(int a):m_A(a){}
```



**6 类对象作为类成员**

```c++
class B{...}
class A{
public:
    B b;
}
//创建A时会先构造B
//析构A时是先析构A再析构B
//B -> A -> A -> B
```



##### 7 静态成员

静态成员变量是在编译阶段分配内存；类内声明，类外初始化；



静态成员函数只能访问静态成员变量；

静态成员函数也有访问权限之分；

```c++
//通过对象访问
Person p;
p.func();
//通过类名访问
Person::func();
```



##### 8 对象模型

C++中，类内成员变量和成员函数分开存储

非静态成员函数也是只有一份；

只有非静态成员变量才是每个对象自己有一份

```c++
class A{
}
A a;
//sizeof(a)就等于1
//C++编译器会给每个空对象也分配一个字节空间, 是为了区分空对象占用的内存位置
class B{
    int m_B;
}
//sizeof(b)就等于4

//静态成员变量、成员函数不会增加sizof(), 都是只有一份
```

返回对象本身用*this

```c++
class A{
	A& func(){	//一定要是引用的 A&
		return *this;	//这样就可以无限连续调用func了
	}
}
A a;
a.func().func().func().func();
```

可以通过空指针访问不涉及this指针的类内函数

```c++
class A{
	int a;
	void func1(){
		;
	}
	void func2(){
		cout << a << endl;
	}
}
A* p = NULL;
p->func1();	//可以
p->func2();	//不可以, 涉及成员变量a, 而实际上是this->a, 但此时this指针为空
```

##### 9 const成员函数

**常函数**：成员函数**后**加const就称为常函数，本质上是让this指针(本身是一个指针常量，即指向方向不可变)进化为const this，即所指向的对象也不可改变；

常函数内不可修改成员属性，但如果成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象**：声明对象**前**加const称该对象为常对象，mutable依然可以发挥作用

常对象只能调用常函数



##### 10 友元

友元就是让一个函数或者类，访问另一个类中私有成员；关键字：friend

有三种类型可以做友元：全局函数、类、成员函数

```c++
class A{
    friend void func();	//1.全局函数友元 就是把函数声明复制到这里, 前面再加friend
    friend class B;		//2.类友元
    friend B::func();	//3.成员函数友元
}
```



类也可以先只写一下，然后再声明，然后再定义

```c++
class A;
```

