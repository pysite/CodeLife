# 第一周《剑指offer》

## 1.复制构造函数不可传值

```c++
class A{
	int value;
	A(A other){...}
}
```

复制构造函数A（A other）传入的参数是A的一个实例。由于是传值参数，我们把形参复制到实参会调用复制构造函数。因此如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止的递归调用从而导致栈溢出。因此C++的标准不允许复制构造函数传值参数。



## 2.考虑异常安全性

```c++
class A{
	char* str;
	A& operator=(const A& a1){
		if(this != &str1){
            A temp(a1);
            char* cTemp = temp.str;
            temp.str = str;
            str = cTemp;
        }
	}
}
```

在这个函数中，我们先创建一个临时实例temp，接着把temp.str和实例自身的str做交换。由于temp是一个局部变量，但程序运行到if的外面时也就出了该变量的作用域，就会自动调用temp的析构函数，把temp.str所指向的内存释放掉。由于temp.str指向的内存就是实例之前str的内存，这就相当于自动调用析构函数释放实例的内存。

如果是先delete原先的str，再new新空间并strcpy传入的字符串，则就有可能因为内存不足导致new失败，从而导致A类型中原先的str被破话，因此为了异常时依然安全，要么是先new，new成功后再delete；要么像上面用temp做交换。



## 3.数组与指针的大小

```c++
int getSize(int data[]){
    return sizeof(data);
}
int data1[] = {1,2,3,4,5};
int *data2 = data1;
int size1 = sizeof(data1);	//结果是20
int size2 = sizeof(data2);	//结果是4
int size3 = getSize(data1);	//结果是4，作为函数参数时会退化成为指针
```



## 4.面试题3：二维数组中的查找

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

思路：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列。



## 5.字符串地址

```c++
char str1[] = "111";
char str2[] = "111";
char* str3 = "111";
char* str4 = "111";
```

str1和str2的地址不同；str3和str4的地址相同；

> str3和str4是两个指针，我们无须为它们分配内存以存储字符串的内容，而只需要把它们指向"hello world”在内存中的地址就可以了。由于"hello world”是常量字符串，它在内存中只有一个拷贝，因此str3和str4指向的是同一个地址。所以比较str3和str4的值得到的结果是相同的。
>



## 6.面试题4：替换字符

题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。

要求：面试官让我们在原来的字符串上做替换，并且保证输入的字符串后面有足够多的空余内存。

思路：（本思路只需扫描一次，O(N)）

先计算出替换后的长度，从字符串的后面开始复制和替换。首先准备两个指针，P1和P2。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。此时字符串包含如图2.4（b）所示，灰色背景的区域是做了字符拷贝（移动）的区域。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串"%20"。由于"%20"的长度为3，同时也要把P2向前移动3格。我们接着向前复制，直到碰到第二个空格（如图2.4（d）所示）。和上一次一样，我们再把P1向前移动1格，并把P2向前移动3格插入"%20" 。



## 7.面试题5：从尾到头打印链表

要求：面试官要求这个题目不能改变链表的结构，就是只能读取不能改写。

思路：用栈就好了。



## 8.树

- 前序遍历是先根后左右;(preorder, inorder, postorder)
- 我们可以平均在O（logn）的时间内根据数值在二叉搜索树中找到一个结点。

- 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。

- 在C++的STL中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。



## 9.面试题6：重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

思路：前序遍历的第一个数字是根节点，在中序顺序中，在这个数字左边的是左子树，右边的是右子树，因此就可得到左子树leftn和右子树的节点数rightn，在前序遍历中紧跟在根节点后面leftn个节点也是左子树，剩下的是右子树。这样就得到了左右子树各自的前序遍历和中序遍历，这样就可以进一步递归下去。



## 10.面试题7：用两个栈实现队列

思路：就是两个栈。



## 11.两个队列实现栈

思路：就是两个队列，

- 在压入时将数据压入已有数据的那一个队列；
- 在弹出时，将已有数据的队列不断地弹出数据并压入到另一个队列中，直到之前这个队列只剩下一个元素，将这个元素删除即可。



## 12.快速排序

```c++
int Partition(int data[], int length, int start, int end){
    if(data == NULL || length < 0 || start < 0 || end > length - 1)
        return;
    int index = RandomInRange(start, end);
    Swap(&data[index], &data[end]);
    int small = start - 1;
    for(index = start; index < end; index++){
        if(data[index] < data[end]){
            swap(&data[++small], &data[index]);
        }
    }
    swap(&data[++small], &data[end]);
    return small;
}
void QuickSort(int data[], int length, int start, int end){
    if(start = end)
        return;
    int index = Partition(data, length, start, end);
    if(index > start){
        QuickSort(data, length, start, index - 1);
    }
    if(index < end){
        QuickSort(data, length, index + 1, end);
    }
}
```



## 13.O(N)复杂度对公司员工Age排序

先用个100大小的数组存储每个年龄的员工个数，接着再在原来的数组中依次填写这些年龄值即可。



## 14.面试题8：旋转数组的最小数字

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

思路：就是二分查找，拿两个指针先分别指向头和尾，以34512为例就是3和2，这时看中间元素是比3大还是小，例如此时中间元素是5比3大，因此最小的元素在后半部分，就将第一个指针变为指向，这么循环下去直到两个指针相邻，而第二个指针就是最小的元素......按照这个思路就可以用二分查找法了。

还要注意两种特殊情况：

- 对于本身是12345这种，需要判断发现第一个数字小于最后一个数字，因此直接返回1即可。
- 对于11101与10111这种，开头、中间、末尾数字完全相同无法判断最小的数字在哪个区间，这种只有调用顺序查找的函数来进行。



## 15.面试题9：斐波那契数列

笨蛋做法：

```c++
long long F(unsigned int n){
    if(n <= 0) return 0;
    if(n == 1) return 1;
    return F(n-1) + F(n-2);
}
```

O(N)做法：

```c++
long long F(unsigned int n){
    if(n <= 0) return 0;
    if(n == 1) return 1;
    long long a = 0;
    long long b = 1;
    long long n = 0;
    for(unsigned int i = 2; i <= n; i++){
        n = a + b;
        a = b;
        b = n;
    }
}
```

还有种O(LogN)的做法，但是涉及矩阵的乘法运算以及乘法分解。（把``A^n``看作是``A^(n/2) * A^(n/2)``）



## 16.小矩形覆盖大矩形的问题

题目：可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用8个2×1的小矩形无重叠地覆盖一个2×8的大矩形，总共有多少种方法？

思路：先把2×8的覆盖方法记为f（8）。用第一个1×2小矩形去覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2×7的区域，这种情形下的覆盖方法记为f（7）。接下来考虑横着放的情况。当1×2的小矩形横着放在左上角的时候，左下角必须和横着放一个1×2的小矩形，而在右边还还剩下2×6的区域，这种情形下的覆盖方法记为f（6），因此f（8）=f（7）＋f（6）。此时我们可以看出，这仍然是斐波那契数列。



## 17.面试题10：二进制中1的个数

题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

注意：这道题有个坑，如果是负数，则右移后左边第一位仍然是1，这样就会导致死循环。

可能死循环的解法：

```c++
int f(int n){
    int ret = 0;
    while(n){
        if(n & 1) ret++;
        n >> 1;
    }
    return ret;
}
```

O(N)的解法：（这里的N是int类型的位数）

```c++
int f(int n){	//将上面的右移改为左移即可
    int ret = 0;
    int flag = 1;
    while(flag){
        if(n & flag) ret++;
        flag << 1;
    }
    return ret;
}
```

O(C)的解法：（这里是指整数中有几个1就只需要循环几次）

```c++
int f(int n){
    int ret = 0;
    while(n){
        n = (n-1) & n;
        ret++;
    }
    return ret;
}
```

思路：我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0都变成1，而它左边所有位都保持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。还是以前面的1100为例，它减去1的结果是1011。我们再把1100和1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。
我们把上面的分析总结起来就是：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。

总结：**==把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制的问题都可以用这个思路解决==**。



## 18.优质代码

### 代码规范性

书写、布局和命名都决定着代码的规范性。

最后，规范的代码命名合理。很多初学编程的人在写代码时总是习惯用最简单的名字来命名，变量名是i、j、k，函数名是f、g、h。由于这样的名字不能告诉读者对应的变量或者函数的意义，代码一长就会变得晦涩难懂。需要传入一个二叉树的根结点作为参数，则可以把该参数命名为==BinaryTreeNode *pRoot==，不要因为这样会多写几个字母而觉得麻烦。

应聘者在写代码的时候，最好**==用完整的英文单词组合命名变量和函数==**，以便面试官能一眼读懂代码的意图。

### 代码完整性

通常我们可以从功能测试、边界测试和负面测试三方面设计测试用例，以确保代码的完整性。（负面测试是指故意输入错误的数据）

三种错误处理方法：

- return 0表示成功，返回非0则代表一种错误；
- 设置某个全局遍历来表示发生了错误；
- 直接throw exception



## 19.面试题11：数值的整数次方

题目：实现函数double Power（double base, int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

注意：

- 要考虑exponent为负数的情况；
- 考虑底数为0的情况，底数为0直接返回0就好了；

- 不能直接==判断小数是否相等

- 注意x^n这种，可以logn的复杂度，即变为(x^(n/2))^2这种，如果n是奇数，则后面再乘以个x即可。
- 判断是否是奇数用n&1 == 1，别用取余符号；



## 20.面试题12：打印1到最大的n位数

题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。

陷阱：数值可能会很大，不可以为long long就行，必须用字符串；

注意：**memset是以字节为单位**进行的；

思路：

1. 就是用字符数组就行，每次模拟加法对字符串表示的数字进行加1操作（逐步进位）。
2. 还可以用全排列的思想，用递归的思想，每次递归到底层就是一个完整的字符串。



## 21.面试题13：在O(1)时间删除链表结点

题目：给定单向链表的头指针和一个结点指针，定义一个函数在O（1）时间删除该结点。链表结点与函数的定义如下：

```c++
struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}
void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);
```

说明：传统的删除肯定从head顺着链表往下面找，因此是O(N)；

思路：

- 把下一个节点的值复制到这一节点，再让下一个节点被”删除“
- 注意链表只有一个节点、被删节点是尾部节点（通过next是否为NULL来判断）两种特殊情况；当删除的是尾部节点时，只好从头遍历到尾，但是整体上来说复杂度依然是O(1)



## 22.面试题14：调整数组顺序使奇数位于偶数前面

题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

思路：双指针，一个在头一个在尾，分别移动两头的指针靠拢，直到头指针指向了一个偶数，尾指针指向一个奇数，这时交换两个数，就这样一直循环下去。（直到头指针移动到了尾指针后面）

扩展性：传入函数指针，该函数指针用来判断一个数是否符合在前面的条件。（这样对于不同的要求，只需要传入不同的判断函数的指针即可）



## 23.面试题15：链表中倒数第k个结点

题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。

思路：两个指针，一个指针先走k-1步，这样当后面的指针到达链表尾部时，前面的指针指向的就是链表中倒数第k个节点。

注意：

- 如果传入的链表为NULL，则返回NULL；
- 如果链表长度小于k，则每次都要判断一下，如果长度小于k就返回NULL；
- 如果k为0，返回NULL；

### 相似题目：

题目1：求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个。

思路：可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在链表的中间。

题目2：判断一个单向链表是否形成了环形结构。

思路：定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；

### 重要思想：

当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。可以让其中一个指针遍历的速度快一些。



## 24.面试题16：反转链表

题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

思路：用三个指针pPrev, pNode, pNext，其中pNode是将整个链表都遍历一遍，pPrev初始为NULL，代表pNode的前一个，pNext代表pNode的后一个。



## 25.面试题17：合并两个排序的链表

题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如输入图3.7中的链表1和链表2，则合并之后的升序链表如链表3所示。

思路：就是两个弹夹打子弹的那种感觉。



## 26.面试题18：树的子结构

题目：输入两棵二叉树A和B，判断B是不是A的子结构。

思路：用递归方式，先递归找根节点值相同的，找到相同的再递归判断两个树的子树是否相同；

注意：空指针；



## 27.面试题19：二叉树的镜像

题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。

思路：前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左右子结点之后，就得到了树的镜像。



## 28.面试题20：顺时针打印矩阵

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

思路：就是从坐标(0,0)(1,1)...开始一圈一圈地输出；

注意：矩阵不一定是正方形；



## 29.面试题21：包含min函数的栈

题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O（1）。

思路：两个栈，一个正常栈，一个辅助栈（用来记录最小值），每次读写数据时都是直接操控的正常栈，不同的是每次也会同时在辅助栈上进行同样的操作，只不过如果当前数据比辅助栈的栈顶元素值更小，则辅助栈此次的元素就是该元素，否则依然是栈顶元素。这样我们想要知道栈内元素的最小值只需看辅助栈的栈顶元素。



## 30.面试题22：栈的压入、弹出序列

题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。

（题目意思是可以在压栈中突然又执行几个弹出操作的那种，不是一股脑的压栈后再一下全部弹出）

思路：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。



## 31.面试题23：从上往下打印二叉树

题目：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。

思路：用queue即可（书上用的是deque双端队列）



## 32.面试题24：二叉搜索树的后序遍历序列

题目：输入一个整数数组，**==判断该数组是不是某二叉搜索树的后序遍历的结果==**。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。

思路：后续遍历的最后一个点是根节点，有了根节点后，如果一端全小于这个值，另一端全大于这个值，就说明可能是对的，还需要进一步递归检查左右子树。

### 重要思路

如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根结点，再基于根结点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。



## 33.面试题25：二叉树中和为某一值的路径

题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

思路：前序遍历，记录路径即可。用vector<>别用stack，因为需要在合适时机打印所有元素。（stack不允许有遍历行为）



## 34.面试题26：复杂链表的复制

题目：请实现函数ComplexListNode* Clone（ComplexListNode* pHead），复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling 指向链表中的任意结点或者NULL。

```c++
struct ComplexListNode{
    int value;
    ComplexListNode* m_pNext;
    ComplexListNode* m_pSibling;
}
```

笨蛋思路：先用O(N)建立起新链表并设置好next指针，再针对每个节点的sibling域，去扫描一遍原链表，看这个节点的sibling指针指向的是第几个节点，再去新链表上走k步找到新节点的sibling该指向的节点。这样复杂度就是O(N^2)。

思路1：（空间换时间）依然是用O(N)建立起新链表并设置好next指针，在建立过程中还建立起<old_node, new_node>的一一映射关系。这样针对每个节点的sibling，从这个映射中可直接得到新链表中的该指向的节点地址。复杂度就是O(N)。

思路2：（不需要辅助空间）用O(N)时间在原始链表基础上创建出新链表，例如原来是a-b-c则新链表就是a-a1-b-b1-c-c1（即每个新节点在旧节点身后），接着这样就可以设置好新节点的sibling（就是原来sibling指针的后一个位置），最后就是将新链表同旧链表分离开来就好。

写代码的时候，我们为每一个步骤定义一个子函数，最后在复制函数中先后调用者3个函数。



## 35.面试题27：二叉搜索树与双向链表

题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

思路：之前的left相当于pPrev，right相当于pNext。从根节点开始，中序遍历（递归），过程中记录lastNode。逐步建立起双向链表。



## 36.面试题28：字符串的排列

题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。

思路：把字符串看作由一个char和后面的字符串string组成，而后面的字符串也看作是char+string组成。这样就可以递归下去，每递进一层则前面固定下来的字符就多1个，而后面的再进行排列组合。（每次就是从后面可选字符串中选择一个作为可选字符串中的第一个，注意不会变动前面固定下来的字符串）



## 37.字符串的组合（感觉有问题，不用看）

> 前面一个题是求排列，即ab和ba是不同的，而在组合中ab和ba就是相同的。

题目：如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？还是输入三个字符a、b、c，则它们的组合有a、b、c、ab、ac、bc、abc。当交换字符串中的两个字符时，虽然能得到两个不同的排列，但却是同一个组合。比如ab和ba是不同的排列，但只算一个组合。

思路：如果输入n个字符，则这n个字符能构成长度为1的组合、长度为2的组合、……、长度为n的组合。在求n个字符的长度为m（1≤m≤n）的组合的时候，我们把这n个字符分成两部分：第一个字符和其余的所有字符。如果组合里包含第一个字符，则下一步在剩余的字符里选取m－1个字符；如果组合里不包含第一个字符，则下一步在剩余的n－1个字符里选取m个字符。也就是说，我们可以把求n个字符组成长度为m的组合的问题分解成两个子问题，分别求n－1个字符串中长度为m－1的组合，以及求n－1个字符的长度为m的组合。这两个子问题都可以用递归的方式解决。

个人思路：全排列组合就是每个数字只有两种选择，出现or不出现，直接按照这个逻辑来递归感觉更简单。



## 38.正方形相对面的四个角上数字和相等

题目：输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。

思路：书上说就是全排列，然后分别判断各个情况是否满足条件。



## 39.8皇后问题

题目：在8×8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者==同一对角线==上。图4.16中的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。请问总共有多少种符合条件的摆法？

思路：由于8个皇后的任意两个不能处在同一行，那么肯定是每一个皇后占据一行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第i行的皇后的列号。先把数组ColumnIndex的8个数字分别用0～7初始化，接下来就是对数组ColumnIndex做全排列。因为我们是用不同的数字初始化数组，所以任意两个皇后肯定不同列。我们只需判断每一个排列对应的8个皇后是不是在同一对角线上，也就是对于数组的两个下标i和j，是不是i-j=ColumnIndex[i]-ColumnIndex[j]或者j-i=ColumnIndex[i]-ColumnIndex[j]。

### 重要思路

如果面试题是按照一定要求摆放若干个数字，我们可以先求出这些数字的所有排列，然后再一一判断每个排列是不是满足题目给定的要求。



## 40.面试题29：数组中出现次数超过一半的数字

题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。

思路1：复杂度O(N)，使用快速排序partition找到中位数，如果有出现次数超一半的数字，那么中位数一定就是这个数字；（需要改变原数组）

**牛比思路2**：把数字认为是战士的生命，从第一个数字开始，遇到相同的数字就认为是“加血”，遇到其它数字就“扣一滴血”，如果某个数字的血量为0，就换为那个新出现的数字。因为要找的数字出现次数大于其它数字出现次数之和，因此最后“活下来”的数字就是我们要找的数字。



## 41.面试题30：最小的k个数

题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

笨比思路：排序，然后找前k个数；

书上的笨比思路1：用快速排序的partition，找第k大的数，平均复杂度O(N)。

思路2：先创建一个大小为k的容器（可以用二叉树、最大堆、红黑树实现），当输入一个数字，如果容器未满就直接插入到容器中，如果容器已满，就查找容器中的最大值，如果最大值大于现在的数字，就将最大值替换为这个数字。最后容器中的k个数字就是最小的k个数字。（复杂度NLogN）（适合==**n很大**==，k不大的情形）

> 红黑树通过把结点分为红、黑两种颜色并根据一些规则确保树在一定程度上是平衡的，从而保证在红黑树中查找、删除和插入操作都只需要O（logk）时间。
>
> 在STL中set和multiset都是基于红黑树实现的。如果面试官不反对我们用STL中的数据容器，我们就可以直接拿过来用。
>
> 在最大堆中，根结点的值总是大于它的子树中任意结点的值。于是我们每次可以在O（1）得到已有的k个数字中的最大值，但需要O（logk）时间完成删除及插入操作。



## 42.面试题31：连续子数组的最大和

题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O（n）。

**牛逼思路1**：记录一个curSum，每来一个数就将curSum加上这个数，如果curSum小于0，立即让curSum变为下一个数。且每次curSum变化时，记录其出现的最大值。

**动态规划思路2**：dp[i]表示以第i个数结尾的数组的和最大值，这样有如下递推公式：

```c++
dp[i] = dp[i-1] + data[i];	// 当dp[i-1] >= 0
      = data[i];	//当dp[i-1] < 0
```

其实这个和思路1本质上相同。



## 43.面试题32：从1到n整数中1出现的次数

P231