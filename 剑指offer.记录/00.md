# 第一周《剑指offer》

## 1.复制构造函数不可传值

```c++
class A{
	int value;
	A(A other){...}
}
```

复制构造函数A（A other）传入的参数是A的一个实例。由于是传值参数，我们把形参复制到实参会调用复制构造函数。因此如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止的递归调用从而导致栈溢出。因此C++的标准不允许复制构造函数传值参数。



## 2.考虑异常安全性

```c++
class A{
	char* str;
	A& operator=(const A& a1){
		if(this != &str1){
            A temp(a1);
            char* cTemp = temp.str;
            temp.str = str;
            str = cTemp;
        }
	}
}
```

在这个函数中，我们先创建一个临时实例temp，接着把temp.str和实例自身的str做交换。由于temp是一个局部变量，但程序运行到if的外面时也就出了该变量的作用域，就会自动调用temp的析构函数，把temp.str所指向的内存释放掉。由于temp.str指向的内存就是实例之前str的内存，这就相当于自动调用析构函数释放实例的内存。

如果是先delete原先的str，再new新空间并strcpy传入的字符串，则就有可能因为内存不足导致new失败，从而导致A类型中原先的str被破话，因此为了异常时依然安全，要么是先new，new成功后再delete；要么像上面用temp做交换。



## 3.数组与指针的大小

```c++
int getSize(int data[]){
    return sizeof(data);
}
int data1[] = {1,2,3,4,5};
int *data2 = data1;
int size1 = sizeof(data1);	//结果是20
int size2 = sizeof(data2);	//结果是4
int size3 = getSize(data1);	//结果是4，作为函数参数时会退化成为指针
```



## 4.面试题3：二维数组中的查找

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

思路：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列。



## 5.字符串地址

```c++
char str1[] = "111";
char str2[] = "111";
char* str3 = "111";
char* str4 = "111";
```

str1和str2的地址不同；str3和str4的地址相同；

> str3和str4是两个指针，我们无须为它们分配内存以存储字符串的内容，而只需要把它们指向"hello world”在内存中的地址就可以了。由于"hello world”是常量字符串，它在内存中只有一个拷贝，因此str3和str4指向的是同一个地址。所以比较str3和str4的值得到的结果是相同的。
>



## 6.面试题4：替换字符

题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。

要求：面试官让我们在原来的字符串上做替换，并且保证输入的字符串后面有足够多的空余内存。

思路：（本思路只需扫描一次，O(N)）

先计算出替换后的长度，从字符串的后面开始复制和替换。首先准备两个指针，P1和P2。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。此时字符串包含如图2.4（b）所示，灰色背景的区域是做了字符拷贝（移动）的区域。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串"%20"。由于"%20"的长度为3，同时也要把P2向前移动3格。我们接着向前复制，直到碰到第二个空格（如图2.4（d）所示）。和上一次一样，我们再把P1向前移动1格，并把P2向前移动3格插入"%20" 。



## 7.面试题5：从尾到头打印链表

要求：面试官要求这个题目不能改变链表的结构，就是只能读取不能改写。

思路：用栈就好了。



## 8.树

- 前序遍历是先根后左右;(preorder, inorder, postorder)
- 我们可以平均在O（logn）的时间内根据数值在二叉搜索树中找到一个结点。

- 红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。

- 在C++的STL中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。



## 9.面试题6：重建二叉树

题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

思路：前序遍历的第一个数字是根节点，在中序顺序中，在这个数字左边的是左子树，右边的是右子树，因此就可得到左子树leftn和右子树的节点数rightn，在前序遍历中紧跟在根节点后面leftn个节点也是左子树，剩下的是右子树。这样就得到了左右子树各自的前序遍历和中序遍历，这样就可以进一步递归下去。



## 10.面试题7：用两个栈实现队列

思路：就是两个栈。



## 11.两个队列实现栈

思路：就是两个队列，

- 在压入时将数据压入已有数据的那一个队列；
- 在弹出时，将已有数据的队列不断地弹出数据并压入到另一个队列中，直到之前这个队列只剩下一个元素，将这个元素删除即可。



## 12.快速排序

```c++
int Partition(int data[], int length, int start, int end){
    if(data == NULL || length < 0 || start < 0 || end > length - 1)
        return;
    int index = RandomInRange(start, end);
    Swap(&data[index], &data[end]);
    int small = start - 1;
    for(index = start; index < end; index++){
        if(data[index] < data[end]){
            swap(&data[++small], &data[index]);
        }
    }
    swap(&data[++small], &data[end]);
    return small;
}
void QuickSort(int data[], int length, int start, int end){
    if(start = end)
        return;
    int index = Partition(data, length, start, end);
    if(index > start){
        QuickSort(data, length, start, index - 1);
    }
    if(index < end){
        QuickSort(data, length, index + 1, end);
    }
}
```



## 13.O(N)复杂度对公司员工Age排序

先用个100大小的数组存储每个年龄的员工个数，接着再在原来的数组中依次填写这些年龄值即可。



## 14.面试题8：旋转数组的最小数字

题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

思路：就是二分查找，拿两个指针先分别指向头和尾，以34512为例就是3和2，这时看中间元素是比3大还是小，例如此时中间元素是5比3大，因此最小的元素在后半部分，就将第一个指针变为指向，这么循环下去直到两个指针相邻，而第二个指针就是最小的元素......按照这个思路就可以用二分查找法了。

还要注意两种特殊情况：

- 对于本身是12345这种，需要判断发现第一个数字小于最后一个数字，因此直接返回1即可。
- 对于11101与10111这种，开头、中间、末尾数字完全相同无法判断最小的数字在哪个区间，这种只有调用顺序查找的函数来进行。



## 15.面试题9：斐波那契数列

笨蛋做法：

```c++
long long F(unsigned int n){
    if(n <= 0) return 0;
    if(n == 1) return 1;
    return F(n-1) + F(n-2);
}
```

O(N)做法：

```c++
long long F(unsigned int n){
    if(n <= 0) return 0;
    if(n == 1) return 1;
    long long a = 0;
    long long b = 1;
    long long n = 0;
    for(unsigned int i = 2; i <= n; i++){
        n = a + b;
        a = b;
        b = n;
    }
}
```

还有种O(LogN)的做法，但是涉及矩阵的乘法运算以及乘法分解。（把``A^n``看作是``A^(n/2) * A^(n/2)``）



## 16.小矩形覆盖大矩形的问题

题目：可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用8个2×1的小矩形无重叠地覆盖一个2×8的大矩形，总共有多少种方法？

思路：先把2×8的覆盖方法记为f（8）。用第一个1×2小矩形去覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2×7的区域，这种情形下的覆盖方法记为f（7）。接下来考虑横着放的情况。当1×2的小矩形横着放在左上角的时候，左下角必须和横着放一个1×2的小矩形，而在右边还还剩下2×6的区域，这种情形下的覆盖方法记为f（6），因此f（8）=f（7）＋f（6）。此时我们可以看出，这仍然是斐波那契数列。



## 17.面试题10：二进制中1的个数

题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

注意：这道题有个坑，如果是负数，则右移后左边第一位仍然是1，这样就会导致死循环。

可能死循环的解法：

```c++
int f(int n){
    int ret = 0;
    while(n){
        if(n & 1) ret++;
        n >> 1;
    }
    return ret;
}
```

O(N)的解法：（这里的N是int类型的位数）

```c++
int f(int n){	//将上面的右移改为左移即可
    int ret = 0;
    int flag = 1;
    while(flag){
        if(n & flag) ret++;
        flag << 1;
    }
    return ret;
}
```

O(C)的解法：（这里是指整数中有几个1就只需要循环几次）

```c++
int f(int n){
    int ret = 0;
    while(n){
        n = (n-1) & n;
        ret++;
    }
    return ret;
}
```

思路：我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0都变成1，而它左边所有位都保持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。还是以前面的1100为例，它减去1的结果是1011。我们再把1100和1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。
我们把上面的分析总结起来就是：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。

总结：**==把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制的问题都可以用这个思路解决==**。



## 18.优质代码

### 代码规范性

书写、布局和命名都决定着代码的规范性。

最后，规范的代码命名合理。很多初学编程的人在写代码时总是习惯用最简单的名字来命名，变量名是i、j、k，函数名是f、g、h。由于这样的名字不能告诉读者对应的变量或者函数的意义，代码一长就会变得晦涩难懂。需要传入一个二叉树的根结点作为参数，则可以把该参数命名为==BinaryTreeNode *pRoot==，不要因为这样会多写几个字母而觉得麻烦。

应聘者在写代码的时候，最好**==用完整的英文单词组合命名变量和函数==**，以便面试官能一眼读懂代码的意图。

### 代码完整性

通常我们可以从功能测试、边界测试和负面测试三方面设计测试用例，以确保代码的完整性。（负面测试是指故意输入错误的数据）

三种错误处理方法：

- return 0表示成功，返回非0则代表一种错误；
- 设置某个全局遍历来表示发生了错误；
- 直接throw exception



## 19.面试题11：数值的整数次方

题目：实现函数double Power（double base, int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

注意：

- 要考虑exponent为负数的情况；
- 考虑底数为0的情况，底数为0直接返回0就好了；

- 不能直接==判断小数是否相等

- 注意x^n这种，可以logn的复杂度，即变为(x^(n/2))^2这种，如果n是奇数，则后面再乘以个x即可。
- 判断是否是奇数用n&1 == 1，别用取余符号；



## 20.面试题12：打印1到最大的n位数

题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。

陷阱：数值可能会很大，不可以为long long就行，必须用字符串；

注意：**memset是以字节为单位**进行的；

思路：

1. 就是用字符数组就行，每次模拟加法对字符串表示的数字进行加1操作（逐步进位）。
2. 还可以用全排列的思想，用递归的思想，每次递归到底层就是一个完整的字符串。



## 21.面试题13：在O(1)时间删除链表结点

题目：给定单向链表的头指针和一个结点指针，定义一个函数在O（1）时间删除该结点。链表结点与函数的定义如下：

```c++
struct ListNode{
    int m_nValue;
    ListNode* m_pNext;
}
void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);
```

说明：传统的删除肯定从head顺着链表往下面找，因此是O(N)；

思路：

- 把下一个节点的值复制到这一节点，再让下一个节点被”删除“
- 注意链表只有一个节点、被删节点是尾部节点（通过next是否为NULL来判断）两种特殊情况；当删除的是尾部节点时，只好从头遍历到尾，但是整体上来说复杂度依然是O(1)



## 22.面试题14：调整数组顺序使奇数位于偶数前面

题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

思路：双指针，一个在头一个在尾，分别移动两头的指针靠拢，直到头指针指向了一个偶数，尾指针指向一个奇数，这时交换两个数，就这样一直循环下去。（直到头指针移动到了尾指针后面）

扩展性：传入函数指针，该函数指针用来判断一个数是否符合在前面的条件。（这样对于不同的要求，只需要传入不同的判断函数的指针即可）



## 23.面试题15：链表中倒数第k个结点

题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。

思路：两个指针，一个指针先走k-1步，这样当后面的指针到达链表尾部时，前面的指针指向的就是链表中倒数第k个节点。

注意：

- 如果传入的链表为NULL，则返回NULL；
- 如果链表长度小于k，则每次都要判断一下，如果长度小于k就返回NULL；
- 如果k为0，返回NULL；

### 相似题目：

题目1：求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个。

思路：可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在链表的中间。

题目2：判断一个单向链表是否形成了环形结构。

思路：定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；

### 重要思想：

当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。可以让其中一个指针遍历的速度快一些。



## 24.面试题16：反转链表

题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

思路：用三个指针pPrev, pNode, pNext，其中pNode是将整个链表都遍历一遍，pPrev初始为NULL，代表pNode的前一个，pNext代表pNode的后一个。



## 25.面试题17：合并两个排序的链表

题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如输入图3.7中的链表1和链表2，则合并之后的升序链表如链表3所示。

思路：就是两个弹夹打子弹的那种感觉。



## 26.面试题18：树的子结构

题目：输入两棵二叉树A和B，判断B是不是A的子结构。

思路：用递归方式，先递归找根节点值相同的，找到相同的再递归判断两个树的子树是否相同；

注意：空指针；



## 27.面试题19：二叉树的镜像

题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。

思路：前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左右子结点之后，就得到了树的镜像。



## 28.面试题20：顺时针打印矩阵

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

思路：就是从坐标(0,0)(1,1)...开始一圈一圈地输出；

注意：矩阵不一定是正方形；



## 29.面试题21：包含min函数的栈

题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O（1）。

思路：两个栈，一个正常栈，一个辅助栈（用来记录最小值），每次读写数据时都是直接操控的正常栈，不同的是每次也会同时在辅助栈上进行同样的操作，只不过如果当前数据比辅助栈的栈顶元素值更小，则辅助栈此次的元素就是该元素，否则依然是栈顶元素。这样我们想要知道栈内元素的最小值只需看辅助栈的栈顶元素。



## 30.面试题22：栈的压入、弹出序列

题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。

（题目意思是可以在压栈中突然又执行几个弹出操作的那种，不是一股脑的压栈后再一下全部弹出）

思路：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。



## 31.面试题23：从上往下打印二叉树

题目：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。

思路：用queue即可（书上用的是deque双端队列）



## 32.面试题24：二叉搜索树的后序遍历序列

题目：输入一个整数数组，**==判断该数组是不是某二叉搜索树的后序遍历的结果==**。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。

思路：后续遍历的最后一个点是根节点，有了根节点后，如果一端全小于这个值，另一端全大于这个值，就说明可能是对的，还需要进一步递归检查左右子树。

### 重要思路

如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根结点，再基于根结点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。



## 33.面试题25：二叉树中和为某一值的路径

题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

思路：前序遍历，记录路径即可。用vector<>别用stack，因为需要在合适时机打印所有元素。（stack不允许有遍历行为）



## 34.面试题26：复杂链表的复制

题目：请实现函数ComplexListNode* Clone（ComplexListNode* pHead），复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针指向下一个结点外，还有一个m_pSibling 指向链表中的任意结点或者NULL。

```c++
struct ComplexListNode{
    int value;
    ComplexListNode* m_pNext;
    ComplexListNode* m_pSibling;
}
```

笨蛋思路：先用O(N)建立起新链表并设置好next指针，再针对每个节点的sibling域，去扫描一遍原链表，看这个节点的sibling指针指向的是第几个节点，再去新链表上走k步找到新节点的sibling该指向的节点。这样复杂度就是O(N^2)。

思路1：（空间换时间）依然是用O(N)建立起新链表并设置好next指针，在建立过程中还建立起<old_node, new_node>的一一映射关系。这样针对每个节点的sibling，从这个映射中可直接得到新链表中的该指向的节点地址。复杂度就是O(N)。

思路2：（不需要辅助空间）用O(N)时间在原始链表基础上创建出新链表，例如原来是a-b-c则新链表就是a-a1-b-b1-c-c1（即每个新节点在旧节点身后），接着这样就可以设置好新节点的sibling（就是原来sibling指针的后一个位置），最后就是将新链表同旧链表分离开来就好。

写代码的时候，我们为每一个步骤定义一个子函数，最后在复制函数中先后调用者3个函数。



## 35.面试题27：二叉搜索树与双向链表

题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

思路：之前的left相当于pPrev，right相当于pNext。从根节点开始，中序遍历（递归），过程中记录lastNode。逐步建立起双向链表。



## 36.面试题28：字符串的排列

题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。

思路：把字符串看作由一个char和后面的字符串string组成，而后面的字符串也看作是char+string组成。这样就可以递归下去，每递进一层则前面固定下来的字符就多1个，而后面的再进行排列组合。（每次就是从后面可选字符串中选择一个作为可选字符串中的第一个，注意不会变动前面固定下来的字符串）



## 37.字符串的组合（感觉有问题，不用看）

> 前面一个题是求排列，即ab和ba是不同的，而在组合中ab和ba就是相同的。

题目：如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？还是输入三个字符a、b、c，则它们的组合有a、b、c、ab、ac、bc、abc。当交换字符串中的两个字符时，虽然能得到两个不同的排列，但却是同一个组合。比如ab和ba是不同的排列，但只算一个组合。

思路：如果输入n个字符，则这n个字符能构成长度为1的组合、长度为2的组合、……、长度为n的组合。在求n个字符的长度为m（1≤m≤n）的组合的时候，我们把这n个字符分成两部分：第一个字符和其余的所有字符。如果组合里包含第一个字符，则下一步在剩余的字符里选取m－1个字符；如果组合里不包含第一个字符，则下一步在剩余的n－1个字符里选取m个字符。也就是说，我们可以把求n个字符组成长度为m的组合的问题分解成两个子问题，分别求n－1个字符串中长度为m－1的组合，以及求n－1个字符的长度为m的组合。这两个子问题都可以用递归的方式解决。

个人思路：全排列组合就是每个数字只有两种选择，出现or不出现，直接按照这个逻辑来递归感觉更简单。



## 38.正方形相对面的四个角上数字和相等

题目：输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。

思路：书上说就是全排列，然后分别判断各个情况是否满足条件。



## 39.8皇后问题

题目：在8×8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者==同一对角线==上。图4.16中的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。请问总共有多少种符合条件的摆法？

思路：由于8个皇后的任意两个不能处在同一行，那么肯定是每一个皇后占据一行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第i行的皇后的列号。先把数组ColumnIndex的8个数字分别用0～7初始化，接下来就是对数组ColumnIndex做全排列。因为我们是用不同的数字初始化数组，所以任意两个皇后肯定不同列。我们只需判断每一个排列对应的8个皇后是不是在同一对角线上，也就是对于数组的两个下标i和j，是不是i-j=ColumnIndex[i]-ColumnIndex[j]或者j-i=ColumnIndex[i]-ColumnIndex[j]。

### 重要思路

如果面试题是按照一定要求摆放若干个数字，我们可以先求出这些数字的所有排列，然后再一一判断每个排列是不是满足题目给定的要求。



## 40.面试题29：数组中出现次数超过一半的数字

题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。

思路1：复杂度O(N)，使用快速排序partition找到中位数，如果有出现次数超一半的数字，那么中位数一定就是这个数字；（需要改变原数组）

**牛比思路2**：把数字认为是战士的生命，从第一个数字开始，遇到相同的数字就认为是“加血”，遇到其它数字就“扣一滴血”，如果某个数字的血量为0，就换为那个新出现的数字。因为要找的数字出现次数大于其它数字出现次数之和，因此最后“活下来”的数字就是我们要找的数字。



## 41.面试题30：最小的k个数

题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

笨比思路：排序，然后找前k个数；

书上的笨比思路1：用快速排序的partition，找第k大的数，平均复杂度O(N)。

思路2：先创建一个大小为k的容器（可以用二叉树、最大堆、红黑树实现），当输入一个数字，如果容器未满就直接插入到容器中，如果容器已满，就查找容器中的最大值，如果最大值大于现在的数字，就将最大值替换为这个数字。最后容器中的k个数字就是最小的k个数字。（复杂度NLogN）（适合==**n很大**==，k不大的情形）

> 红黑树通过把结点分为红、黑两种颜色并根据一些规则确保树在一定程度上是平衡的，从而保证在红黑树中查找、删除和插入操作都只需要O（logk）时间。
>
> 在STL中set和multiset都是基于红黑树实现的。如果面试官不反对我们用STL中的数据容器，我们就可以直接拿过来用。
>
> 在最大堆中，根结点的值总是大于它的子树中任意结点的值。于是我们每次可以在O（1）得到已有的k个数字中的最大值，但需要O（logk）时间完成删除及插入操作。



## 42.面试题31：连续子数组的最大和

题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O（n）。

**牛逼思路1**：记录一个curSum，每来一个数就将curSum加上这个数，如果curSum小于0，立即让curSum变为下一个数。且每次curSum变化时，记录其出现的最大值。

**动态规划思路2**：dp[i]表示以第i个数结尾的数组的和最大值，这样有如下递推公式：

```c++
dp[i] = dp[i-1] + data[i];	// 当dp[i-1] >= 0
      = data[i];	//当dp[i-1] < 0
```

其实这个和思路1本质上相同。



## 43.面试题32：从1到n整数中1出现的次数

题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1 的数字有1，10，11和12，1一共出现了5次。

笨比思路1：遍历计算每个数字的1的个数再累加；

**牛逼思路2**：每10个数字个位出现1次1，每100个数字十位出现10次1...同时剩下的，比如118，按照前面说法10位只有10次，但实际上这最后18中还有9次十位上出现了1，即``min(max(n%100-10+1,0), 10)``。



## 44.面试题33：把数组排成最小的数

题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3,32,321}，则打印出这3个数字能排成的最小数字321323。

注意：这道题不可atoi（要考虑大数的问题）

思路：(就是按照新规则对原来的数组排下序即可)

```c++
class Solution {
public:
    static bool MyCompare(int a, int b){
        //return atoi((to_string(a)+to_string(b)).c_str()) < atoi((to_string(b)+to_string(a)).c_str());
        return to_string(a) + to_string(b) < to_string(b) + to_string(a);
    }
    string minNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end(), MyCompare);

        string ret = "";
        for(auto it = nums.begin(); it != nums.end(); it++){
            ret += to_string(*it);
        }
        return ret;
    }
};
```

证明的话：就是假设存在一个最大值，但是其中有一段数字是a + b < b + a的，那么就可以把这两个数字的位置交换一下数字会更大，与已是最大值矛盾。



## 45.面试题34：丑数

题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。

**基本思路**：对1到1500这1500个数字，每个数字都：一直除以2直到不能整除，一直除以3直到不能整除，一直除以5直到不能整除，最后如果是1就是丑数否则不是。（这样的话效率不够高）

**动态规划思路**：准备长为1500的数组，初始全为1，并设置三个index即a,b,c，它们分别代表X2后超过当前最大值的数值下标，X3后超过当前最大值的数值下标，X5后超过当前最大值的数值下标。每次选择``min(v[a] * 2, v[b] * 3, v[c] * 5);``作为下一元素，同时将a,b,c中被选择的那个加1。这样一来就是各个丑数的从小到大的排序。

```c++
int nthUglyNumber(int n) {
    vector<int> v(n,1);
    int a,b,c;
    a = b = c = 0;
    int cur = 0;
    for(int i = 1; i < n; i++){
        v[++cur] = MyMin(v[a] * 2, v[b] * 3, v[c] * 5);
        if(v[cur] == v[a] * 2) a++;
        if(v[cur] == v[b] * 3) b++;
        if(v[cur] == v[c] * 5) c++;
    }
    return v[n-1];
}
```



## 46.面试题35：第一个只出现一次的字符

题目：在字符串中找出第一个只出现一次的字符。如输入"abaccdeff"，则输出'b'。

思路：创建256的数组（代表char的256个字符的ASCII码），扫描两遍字符串，第一遍统计次数，第二遍找第一个一。

### 重要思想

如果需要判断多个字符是不是在某个字符串里出现过或者统计多个字符在某个字符串中出现的次数，我们可以考虑基于数组创建一个简单的哈希表。这样可以用很小的空间消耗换来时间效率的提升。



## 47.面试题36：数组中的逆序对

题目：在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如在数组{7,5,6,4}中，一共存在5个逆序对，分别是（7,6）、（7,5）、（7,4）、（6,4）和（5,4）。

**归并排序思路1**：采用mergeSort归并。从长度为1的数字开始，不断合并相邻的，每次两个子数组在归并排序时，看作是两个弹夹，每当左边的弹夹打出子弹时，就将sum（逆序对数）增加右边弹夹已经打出的子弹数。（==因为两个弹夹都是按从小到大的顺序，每当左边的弹夹打出子弹时，本来右边不该打出子弹的，右边这些已经打出去的子弹就是可组成的逆序对数==）

**数装数组四路2**：

[只能说有点复杂，涉及树状数组](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)



## 48.树状数组

[网址1](https://www.zhihu.com/question/54404092)

[网址2](https://blog.csdn.net/bestsort/article/details/80796531)

upper_bound是>，而lower_bound是>=的元素。

lowbit(x)的含义：

- 代表着x这个数的最低的1，比如1001就是1，1000就是1000；

- ==该节点在树状数组的高度，因此x-lowbit(x)就是来到了更高的节点==。x+lowbit(x)也是来到更高的节点。

数状数组中的每个节点存储的值是代表其在图中垂直向上追溯可以达到的最高的结点。如上图，图中的圆圈对应的结点就是数组中位置所代表的结点。比如说数组中的位置 4 就代表了结点 [1, 4]，数组中位置 6 代表了结点 [5, 6]，位置 8 代表了结点 [1, 8]。（==即6节点的值就是节点5和6之和，8节点的值就是节点1到8的和==）

如何获取[1,x]区间的和：x不断减去lowbit(x)，将这些data[x]累加起来就是[1,x]区间的和；

想让节点x的值加1或减1：x不断加上lowbit(x)，将经过的节点的值加1或减1；



## 49.面试题37：两个链表的第一个公共结点

题目：输入两个链表，找出它们的第一个公共结点。

思路1：弄两个栈，将两个链表分别压入这两个栈，然后不断pop，（两个链表的后半部分一定是相同的，因此栈顶的链尾元素一定是相同的）直到第一个不同的元素。

思路2：先分别遍历两个链表一遍，这样就知道两个链表的长度，之后让长的链表先走k步，接下来两个链表长度就相当于相同了，然后依次同时走一步，第一个相同的就是第一个公共结点。



## 50.面试题38：数字在排序数组中出现的次数

题目：统计一个数字在排序数组中出现的次数。例如输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4。

思路：二分法找数字的开头和末尾；



## 51.面试题39：二叉树的深度

题目1：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

思路：一个树的深度就是左右子树深度较大的一个。递归就行。



题目2：输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

简单思路：和上面一样，先计算左右子树的深度，如果超过1直接return false，否则再递归判断左右子树是否是平衡二叉树。（这样会重复计算某一子树的深度）

**进阶思路**：（后序遍历），先递归判断左右子树是否是平衡二叉树，判断完后记得还返回该子树的深度，这样就能一遍搞定此问题。



## 52.面试题40：数组中只出现一次的数字

题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O（n），空间复杂度是O（1）。

思路：先顺序依次异或一遍，最后的结果就是那两个出现两次的数字的异或结果，这个结果一定有一位是1，以这一位为标准，将这位为1和这位不为1的分为两个子数组，再在这两个子数组中进行异或，最后各自结果就是那两个数字。



## 52.面试题41：和为s的两个数字VS和为s的连续正数序列

题目1：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。

思路：因为是递增排序的，所以就是一前一后的两个数字，如果sum大于了s，较后的数字就向前移动；同样的，如果sum小于了s，较前的数字就向后移动。



题目2：输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1＋2＋3＋4＋5＝4＋5＋6＝7＋8＝15，所以结果打印出3个连续序列1～5、4～6和7～8。

思路：一开始{1,2}，如果sum小于s，就多加一个数进来，如果大于了s，就从前面剔除一个数。



## 53.面试题42：翻转单词顺序 VS左旋转字符串

题目1：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

思路：以空格作为分界符，先整体翻转，得到".tneduts a ma I"；接着再依次翻转每个单词，得到"student. a am I"。



题目2：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串"abcdefg"和数字2，该函数将返回左旋转2位得到的结果"cdefgab"。

思路：想像一根筷子，现在我们想把筷子的前端移接到筷子的后端，只需要把筷子从中间砍断，再把前面部分翻转，再把后面部分翻转，最后再整体翻转即可。



## 54.面试题43：n个骰子的点数

题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

思路：动态规划，题目有限制最大筛子数，例如11个筛子就代表最大可能的数为66，即6到66，可以提前开数组，每个数组的含义就是该数出现的可能次数，而计算方法就是初始前6个位置初始为1（代表1个骰子的情况），然后对于下一个骰子，可能出现的点数就是2到12，从大数12到2开始，例如计算12的时候就是6的个数，因此是1，而11就是5和6的之和，就是2（代表第二次投出6和5的情况才可能是11）...



## 55.面试题44：扑克牌的顺子

题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字

思路：（注意大小王不止2个，题目没说是一副牌）将大小王看作是0，只要这5张牌中 max - min < 5 就可，且必须没有重复的非0数字。所以思路有两种，先排序，再判断。或者开个set容器在遍历时判断是否已有重复。



## 56.面试题45：圆圈中最后剩下的数字

题目：0,1,…,n－1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

思路1：用链表（stl中的list）模拟环形链表（每次到达末尾时就移动到首部），然后你懂的。复杂度O(MN)

思路2：n个数，每次数m个，这种情况下第一个出去的肯定是 `` m-1%n `` 下标的元素，之后下一个元素就还得继续往前数x个，这个x就是n-1个数，每次数m个的情况下的元素下标。因此这题可以用动态规划：

```c++
/*
f(n,m)=[(m-1)%n+x+1]%n
      =[(m-1)%n%n+(x+1)%n]%n
      =[(m-1)%n+(x+1)%n]%n
      =(m-1+x+1)%n
      =(m+x)%n
*/
int lastRemaining(int n, int m) {
    int f = 0;
    for (int i = 2; i != n + 1; ++i) {
        f = (m + f) % i;	//当1个数的时候，结果是0
    }
    return f;
}
```



## 57.面试题46：求1＋2＋…＋n

题目：求1＋2＋…＋n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

思路1：利用构造函数，就是创建一个类，类里面有静态变量，每创建一个该类对象就静态变量加1，然后直接``new A[100]``

思路2：利用``!!n``，``!!n``会把所有非0的n变为1，0仍然是0，这样可以用类似数组的东西，比如虚函数或函数指针，每当n非0时调用的就是个递归函数，只有当递归到0时，就可以调用另一个函数，而这个函数就会停止下来（直接return 0）。

思路3：利用函数模板的重载，

```c++
template<unsigned int n>
struct A{
    enum Value{N = A<n-1>::N + n};
}
template<>
struct A<1>{
    enum Value{N = 1};
}
```



## 58.面试题47：不用加减乘除做加法

题目：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷四则运算符号。

思路：想一想位运算，A+B变成了(A^B + A&B<<1)里面的加法又递归变，直到右边这个代表进位的A&B<<1为0。



## 59.交换两个数的值

```c++
//基于加减法
a = a + b;
b = a - b;
a = a - b;
//基于异或
a = a ^ b;
b = a ^ b;
a = a ^ b;
```



## 60.面试题48：不能被继承的类

说明：在C#中定义了关键字sealed，被sealed修饰的类不能被继承。在Java中同样也有关键字final表示一个类型不能被继承。在C++中没有类似于sealed和final的关键字，我们只有自己来实现。

题目：用C++设计一个不能被继承的类。

思路1：子类的构造函数会自动调用父类的构造函数，子类的析构函数也会自动调用父类的析构函数。将构造函数和析构函数设置为private，再设置两个类似get和delete的公共静态函数作为接口即可。

思路2：利用模板参数作为友元函数

```c++
template<class T>
class A{
    friend T;
private:
    A(){}
    ~A(){}
}

class B:virtual public A<B>{
public:
    B(){}
    ~B(){}
}
```

由于B是A的友元，因此可以用A的构造和析构函数。但是如果有个类C继承B，就不再是A的友元，因此C不能用A的构造函数和析构函数，也就无法继承。



## 61.后记

在C++中，成员变量的初始化顺序只与它们在类中声明的顺序有关，而与在初始化列表中的顺序无关。



总结：树中最低公共祖先的问题

**问题1**：如果是二叉搜索树

思路：递归，比如找a和b的最低祖先，从root开始，如果root的值大于a和b，就递归搜索root的左子树，如果root的值小于a和b，就递归搜索root的右子树，直到遇到的第一个root结点的值在a和b之间。

**问题2**：如果是普通树，但是有指向父结点的指针

思路：就变成找两个链表第一个公共结点的问题

**问题3**：如果就只是个普通树

思路：遍历找到从root到两个结点的路径path1和path2，再找这两个路径的最后一个相同的结点。



2021-03-05 阅读结束