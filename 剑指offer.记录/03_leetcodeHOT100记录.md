## 1.两数之和

题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

思路1：暴力搜索

思路2：用哈希表，遍历数组中每个元素x，每次在哈希表中查询target-x是否存在；



## 2.两数相加

题目：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

思路：就是你懂的，一个一个来就行；



## 3.无重复字符的最长子串

题目：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

思路：就是左右指针，先移动右指针，再移动左指针...记录最大长度；



## 4.寻找两个正序数组的中位数

题目：给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数。

思路1：O(N)，就是类似两个弹夹打子弹；

思路2：O(LogN)，将较短的数组设置为m，较长的数组设置为n，二分法在[0, m]中找切分点，找将两个数组分成两个部分的点。



## 5.最长回文子串

题目：给你一个字符串 `s`，找到 `s` 中最长的回文子串，s = “babad”，输出“bab”；

**思路1**：动态规划，dp[i, j]表示下标i到j是否是回文子串(bool值)，则dp[i, j] = dp[i+1, j-1] && (s[i] == s[j])；在这过程中记录最长的回文子串(用substr)；O(N^2)

**思路2**：中心扩展，先选出预备中心（初始从长度为1和长度为2的中心），然后向两边扩展。O(N^2)

**思路3**：Manuter方法（略）



## 6.正则表达式匹配

题目：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符

- '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。注意".*"相当于是任意个"."因此可以匹配任意字符串。

**思路**：用动态规划。先创建规则match，就是两个小写字母相同或者其中一个是"."就认为是match的。dp[i, j]代表着s中前i个和p中前j个是否匹配。显然dp[0, 0]为true。

- 首先，如果p[j - 1]不是'*'则必须要求s[i-1]和p[j-1]必须match。
- 如果p[j-1]是'*'，
  - 如果s[i-1]和p[j-2]match，则dp[i, j] = dp[i-1, j] 或 dp[i, j-2]，分别代表将匹配上的字符给删除，和一个也不匹配的情况。
  - 如果不match，就dp[i, j] = dp[i, j-2]。



## 7.盛最多水的容器

题目：给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

**思路**：用两个指针，一开始指向左右两端，每次移动当前数值较小的那个指针，直到两个指针相遇，记录中间过程的最大乘积。



## 8.三数之和

题目：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**思路**：先将原始数组sort了，再循环遍历每个元素，将遍历的每个元素x视为三元组的第一个数，因此剩下的任务就是从右边的数组中再选出两个数的和为-x，这就可以用之前“两数之和”中的想法，用两个指针一前一后不断靠近，将其中满足和为-x的二元组再和x组成三元组即可。（注意每次靠近的时候必须要求元素不同，即22223从2变化到3而非重复的2）



## 9.电话号码的字母组合

题目：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。（就是九宫格按键的那种手机打字，问按了几个数字的字母组合而已）

**思路**：就是递归函数，每次遍历当前按钮对应的所有字母，将每个字母都加到待选字符串末尾，然后递归调用下一层函数，调用完后，再pop调末尾刚加入的字母，再换当前按钮的下一个字幕再来一遍。



## 10.删除链表倒数第N个

题目：给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**思路1**：经典思路就是两个指针，一个指针先走n-1步。

**思路2**：递归函数，函数返回节点指针。每层递归逐步进入链表的后面结点，当递归完后再将一个全局变量加1，这样当全局变量加到n时就代表是倒数第n个结点了，这时再直接返回当前结点的next指针即可。上层函数会把递归函数返回值当作当前结点的next。（如果不是倒数第n个，就返回当前结点指针）。



