## 1.两数之和

题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

思路1：暴力搜索

思路2：用哈希表，遍历数组中每个元素x，每次在哈希表中查询target-x是否存在；



## 2.两数相加

题目：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

思路：就是你懂的，一个一个来就行；



## 3.无重复字符的最长子串

题目：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

思路：就是左右指针，先移动右指针，再移动左指针...记录最大长度；



## 4.寻找两个正序数组的中位数

题目：给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数。

思路1：O(N)，就是类似两个弹夹打子弹；

思路2：O(LogN)，将较短的数组设置为m，较长的数组设置为n，二分法在[0, m]中找切分点，找将两个数组分成两个部分的点。



## 5.最长回文子串

题目：给你一个字符串 `s`，找到 `s` 中最长的回文子串，s = “babad”，输出“bab”；

**思路1**：动态规划，dp[i, j]表示下标i到j是否是回文子串(bool值)，则dp[i, j] = dp[i+1, j-1] && (s[i] == s[j])；在这过程中记录最长的回文子串(用substr)；O(N^2)

**思路2**：中心扩展，先选出预备中心（初始从长度为1和长度为2的中心），然后向两边扩展。O(N^2)

**思路3**：Manuter方法（略）



## 6.正则表达式匹配

题目：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符

- '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。注意".*"相当于是任意个"."因此可以匹配任意字符串。

**思路**：用动态规划。先创建规则match，就是两个小写字母相同或者其中一个是"."就认为是match的。dp[i, j]代表着s中前i个和p中前j个是否匹配。显然dp[0, 0]为true。

- 首先，如果p[j - 1]不是'*'则必须要求s[i-1]和p[j-1]必须match。
- 如果p[j-1]是'*'，
  - 如果s[i-1]和p[j-2]match，则dp[i, j] = dp[i-1, j] 或 dp[i, j-2]，分别代表将匹配上的字符给删除，和一个也不匹配的情况。
  - 如果不match，就dp[i, j] = dp[i, j-2]。



## 7.盛最多水的容器

题目：给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

**思路**：用两个指针，一开始指向左右两端，每次移动当前数值较小的那个指针，直到两个指针相遇，记录中间过程的最大乘积。



## 8.三数之和

题目：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**思路**：先将原始数组sort了，再循环遍历每个元素，将遍历的每个元素x视为三元组的第一个数，因此剩下的任务就是从右边的数组中再选出两个数的和为-x，这就可以用之前“两数之和”中的想法，用两个指针一前一后不断靠近，将其中满足和为-x的二元组再和x组成三元组即可。（注意每次靠近的时候必须要求元素不同，即22223从2变化到3而非重复的2）



## 9.电话号码的字母组合

题目：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。（就是九宫格按键的那种手机打字，问按了几个数字的字母组合而已）

**思路**：就是递归函数，每次遍历当前按钮对应的所有字母，将每个字母都加到待选字符串末尾，然后递归调用下一层函数，调用完后，再pop调末尾刚加入的字母，再换当前按钮的下一个字幕再来一遍。



## 10.删除链表倒数第N个

题目：给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**思路1**：经典思路就是两个指针，一个指针先走n-1步。

**思路2**：递归函数，函数返回节点指针。每层递归逐步进入链表的后面结点，当递归完后再将一个全局变量加1，这样当全局变量加到n时就代表是倒数第n个结点了，这时再直接返回当前结点的next指针即可。上层函数会把递归函数返回值当作当前结点的next。（如果不是倒数第n个，就返回当前结点指针）。



## 11.有效的括号

**题目**：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

**有效字符串需满足**：左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。

思路：用栈即可。



## 12.合并两个有序链表

题目：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

思路：打子弹；



## 13.括号生成

题目：数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的括号组合。

```c++
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

思路：每次只要保证左括号数小于等于右括号数即可。递归。



## 14.合并K个升序链表

题目：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

**思路1**：先弄一个merge2lists函数，每次将两个链表合并；再弄一个递归函数merge，该函数接受left和right两个代表下标的值。先计算出mid下标，再递归调用merge分别将left..mid和mid..right两个数组合并，合并完再调用merge2lists。

**思路2**：用一个实现了operator<的类代表链表中的一个结点，使用priority_queue，一开始将每个链表的头结点放入queue中，接着取出queue中头结点（代表值最小），如果这个结点有next则把next点压入queue中即可。



## 15.下一个排列

题目：实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。例如：[1,2,3]的下一个就是[1,3,2]

**思路**：（两遍扫描）

- 从右到左，找到第一个不满足降序排列的位置（4321叫降序），比如4231发现的就是2<3，因此是2所在的位置。

- 知道2后，就再次从右到左找到第一个大于2的元素，因此是3所在的位置。
- 交换2和3的位置，得到4321。
- 再将3左边的数字reverse一下（即使3右边的数字升序排列），得到4312。



## 16.最长有效括号

题目：给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```c++
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

思路：（用栈扫描）

- 建立长为字符串长度的数组，初始全为0。

- 用stack<int>，每遇到一个左括号，就将其下标i压入栈中。
- 如果遇到一个右括号，此时若栈为空，则数组中下标i的元素置为1；如果不为空，就从栈中pop出栈顶元素；
- 扫描完后，将栈中所有剩余元素（下标i）弹出，将这些下标对应的数组元素置为1；
- 至此，问题就变为了找数组中连续0的最大长度即可。



## 17.搜索旋转排序数组

题目：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

要求：必须时间复杂度为O(LogN)

思路：（依然二分法）

- 二分为两个区间，如果一个区间[x, ..., y]中nums[x] < nums[y]则代表这个区间是有序的，而另一个区间肯定不是有序的。
- 如果要找的值在nums[x]与nums[y]就在有序的一般区间中去二分查找。
- 如果要找的值在另一个区间中，就递归调用本函数，继续二分区间的去找。



## 18.在排序数组中查找元素的第一个和最后一个位置

题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

要求：时间复杂度为O(LogN)

思路：就是二分法



## 19.组合总和

题目：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 

思路：（标准的**搜索回溯**）

- 每遇到一个数字都有两种选择，用或者不用（就跳到下一个数字）

- 设置一个dfs(candidates, target, vec, idx)，代表可选的数字下标为[idx, ...]，同时要拼凑出target值，当前的答案记录在数组vec中。

- 每次都可以dfs(candidates, target - candidates[idx], vec U {candidates[idx]}, idx)或dfs(candidates, target, vec, idx + 1)；

  递归下去即可。



## 20.接雨水

题目：给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**暴力思路**：每一列能存储的最大雨水量就是其两边最大高度值取较小值减去本列的柱子高度。O(N^2)

**思路1**：用两个数组left和right，分别代表从左到右的最大高度值以及从右到左的最大高度值，比如柱子高为[0,1,0,2,1,0]则left是[0,1,1,2,2,2]而right是[2,2,2,2,1,0]

在left和right中取min则是[0,1,1,2,1,0]再减去柱子高后得到[0,0,1,0,0]因此只能存储1雨水；

**思路2**：（用单调栈）

比如是[0,2,1,0,3]则stack = {}，

- 遇到0，压入栈{0}
- 遇到2，发现2>height[stack.top]=0,则pop出0，发现栈空遂停止，将2压入栈{2}
- 遇到1，压入栈{2,1}
- 遇到0，压入栈{2,1,0}
- 遇到3，发现3>0，则pop出0，此时top=1，取min(3,1)=1，可以积水=(min(3,1)-0)*(下标4-下标2-1) = 1
- 继续pop出1，此时top=2，可以积水=(min(3,2)-1)*(下标4-下标1-1)=2
- 继续pop出2，此时栈空停止，因此最后总积水为2+1=3



## 21.全排列

题目：给定一个没有重复数字的序列，返回其所有可能的全排列。

思路：（回溯）

- 递归函数backtrack(... int first, vector<int> nums)

- first代表当前排列到的数字下标；

- 做法就是遍历first及其之后的各个数字，将各个数字与下标first的数字swap之后递归到下一层。递归完后再swap换回来后尝试下一个数字。



## 22.旋转图像

题目：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

思路：纯数学题



## 23.字母异位分组

题目：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。如['abc','cba','acc','cca']就分为['abc','cba']与['acc','cca']两组。

大神思路：用不同的质数表示26个字母，这样就可以保证不同组的字母异位词的相乘的积不同。但可能会导致乘积溢出。

正常思路：用map<string, vector<string>>或<string, list<string>>其中的key值必须保证同组字母异位分词的key相同，不同组的不同。比如可以将'abc'和'cba'都映射成'a1b1c1'或者都排序成为'abc'。



## 24.最大子序和

题目：给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

思路：面试腾讯做过。

```c++
for (int num : nums) {
    if (sum > 0)
        sum += num;
    else
        sum = num;
    res = max(res, sum);
}
```



## 25.跳跃游戏

题目：给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

思路：就是维护一个能跳到的最远举例maxLen，每扫描到一个下标i，maxLen=max(i+nums[i], maxLen)；如果扫描的下标超过了maxLen就代表不存在一种可能。



## 26.合并区间

题目：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

思路：

- 将所有区间按照左端点升序排列。
- 如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；
- 否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。



## 27.不同路径

题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

思路：就是m+n-2步中选出m-1步，就是个组合数学

**动态规划思路**：dp[i, j]表示从左上角走到[i, j]的路径数

dp[i, j] = dp[i-1, j] + dp[i, j-1]

**数学计算思路**：就是ans = ans * [(m+n-2) / (m-1)] * [(m+n-3) / (m-2)] * ... * [n / 1] 



## 28.最小路径和

题目：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或向右一步。

思路：动态规划即可。dp[i, j] = min(dp[i-1, j] + dp[i, j-1]) + grid[i, j]



## 29.爬楼梯

题目：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

思路：面试腾讯做过。



## 30.编辑距离

题目：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：插入一个字符；删除一个字符；替换一个字符；

思路：（动态规划）

- 插入A和删除B等效，修改A和修改B等效，因此实际上就三种操作：插入A、插入B、修改A；

- dp[i] [j]表示word1前i个字符和word2前j个字符的编辑距离

- 因此有如下转移方程：

  ```c++
  /*
  如果第i个字符和第j个字符相同，则
  dp[i][j] = min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1])
  如果不同则
  dp[i][j] = min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1]+1)
  */
  ```

  

## 31.颜色分类

题目：（荷兰国旗问题）给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

思路1：（单指针）

- 遍历两遍，第一遍，small指针一开始为-1，每遇到一个0，就将这个0与vec[++small]的元素交换，这样第一遍扫描将使所有的0在最前面；
- 第二遍扫描，small指针减1，即small指向最后一个0，每次遇到一个1，就将1与vec[++small]进行交换，这样第二遍扫描便使所有的1在最中间；

思路2：（双指针）

- 扫描一遍，用两个指针small, big，一开始small=0, big=vec.length，每遇到一个0，就将这个0与vec[++small]的元素交换；每遇到一个2，就将这个1与vec[--big]进行交换，直到当前遍历的指针超过big。



## 32.最小覆盖子串

题目：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：比如"abc"就算是覆盖了"ac"，注意该题目的意思"abc"不算覆盖"abcabc"，一个字母覆盖一个；如果 s 中存在这样的子串，我们保证它是唯一的答案。

思路：（滑动窗口）

- 用两个map<char,int>，先用一个map名叫origin将t中各个字符及其对应字符数统计出来；
- 再创建一个子函数，用来当前范围的s能否覆盖t；其实就是用第二个map名叫count将当前范围的字符串及其个数数出来，统计一个字符时必须先判断其有没有在origin中充当key值；
- l、r分别代表范围的左右边界，l初值为0，r从0开始到最后，每次判断当前是否满足覆盖条件，如果是则尝试不断将l加1（同时将map count中的s[l]减1）
- 记录r-l+1最小的一个情况作为最后求出的答案范围；



## 33.子集

题目：给你一个整数数组 `nums` ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。（空集以及自身也都要返回）

思路1：比如有3个数，则遍历0到7八个数字，每位1代表有这个数字，0代表不存在，依据这个数构造一个vector再push到ans中。

思路2：dfs，每次有个start代表现在遍历到的下标，每次尝试push后再递归下一层，然后pop出再递归下一层（分别代表有这个数字和没有这个数字）



## 34.单词搜索

题目：给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。（意思就是给你一张地图每个格子对应一个字母，从图中判断是否有组成这个单词的路径即可）

思路：就是遍历，dfs(map, visited, i, j ,k, nums)，该函数中判断map[i] [j]是否是nums[k]，如果不是就返回false，是就再遍历四个方向上的格子去判断nums[k+1]，注意如果map[i] [j]等于nums[k]，还需要把visited[k]置为true避免重复走一个格子。

主函数中要试着从所有格子处开始调用dfs(map, visited, i, j ,0, nums)，复杂度非常高（但是这就是答案的做法）



## 35.柱状图中最大的矩形

题目：给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

思路1：（暴力）

遍历每个柱子，选取当前柱子的高度就为矩形的高度，然后向两边延展直到碰到一个柱子的高度低于当前柱子高度，以此来计算出一个可能的矩形面积。

思路2：(单调栈)

- 用一个栈，扫描两遍，得到两个数组left和right分别代表以下标i的柱子为矩形高，其最左和最右能到达的下标；
- 第一遍，从左到右，每次遍历到下标i，如果nums[i] 大于栈顶对应的元素，直接将i入栈，否则不断pop直到大于栈顶元素，此时栈顶元素就是left[i]应设置的值，接着再将i入栈；
- 第二遍，从右到左，情况和第一遍一样；
- 有了left和right之后，就可以ans = max(ans, right[i] - left[i] -1)，注意在扫描过程中如果栈pop为空，则left[i] = -1，right[i] = n；

思路3：

- 思路2中，可以只需一遍扫描。在第一次扫描时遇到的pop情况时，本身每pop出一个下标x，right[x] = i。（只不过right数组中的元素初始化应初始为n）