## 1.判定字符是否唯一

题目：实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

思路1：如果是小范围的字符，就直接hash或位运算也行；

思路2：如果是unicode等大范围的字符，就先对所有字符进行排序就行；



## 2.判定是否为字符重排

题目：给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

思路1：用C++的sort(s1.begin(), s1.end())将s1和s2进行排序后再调用s1.compare(s2)，比较两个字符串；

思路2：直接数出s1和s2中各个字符的个数，如果相同就可以变为另一个字符串，如果不同就不行；



## 3.无重复字符的最长子串

题目：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

思路：滑动窗口，就是两个指针代表子串开始和结束，不断尝试移动右边指针，如果右边走不动了（有重复字串），就移动左边的，移动一步左边的指针后再次尝试移动左边的指针。



## 4.URL化

题目：URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）

思路：倒着来就行；要先resize成合适大小嗷；



## 5.回文排列

题目：给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。

思路：map<char, int>记录每个字符出现的次数即可；



## 6.一次编辑

题目：字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

思路：先定位到发生不同的字符位置，再接着判断后面的字符串是否相同即可。（如果长度相同，则跳过该不同的字符，取后面的字符串再比较）（如果长度不同，则长度较长的跳过一个字符再取后面的字符串进行比较）



## 7.字符串压缩

题目：字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

思路：就是遍历扫描；注意一定是要压缩后的长度小于原字符串才可输出新字符串；



## 8.旋转矩阵

题目：给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间。

思路：旋转就对了，只需要用一个temp，每次同时旋转4个元素，而非一个一个的来。



## 9.零矩阵

题目：编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

思路：就还是得遍历找0的位置再来弄。



## 10.字符串轮转

题目：字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。只调用一次检查子串。

**思路**：AB字符串，如果旋转得到BA，那么BABA中间一定有个AB。因此思路就是先判断s1和s2的长度是否相同，如果相同，再判断s2+s2的字符串find(s1) != string::npos即可。



## 11.移除重复节点

题目：编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

**思路**：就是用set记录每次经过的点的值，如果发现节点的值已在set中就是应该删除的，在遍历时保存一个前序节点prev，这样就可以直接prev->next = ptr->next来删除。



## 12.分割链表

题目：编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

思路：遍历一遍链表，将小于x的节点用新链表收集起来，大于等于x的用另一个链表。最后把两个链表组合起来。



## 13.链表求和

题目：给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。

思路：就是模仿手写加法进行加和计算即可。



## 14.环路检测

题目：给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

**简单思路**：用哈希表记录已出现过的节点地址，找第一个重复过的地址即可。

**复杂思路**：用快慢指针，涉及数学公式的推导。



## 15.堆盘子

题目：堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。

当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.

**思路**：就是vector+stack即可。



## 16.栈排序

题目：栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。

思路：就是两个栈，其中一个是辅助栈，每当加入一个元素时，就把它前面的元素先“腾”到另一个栈中，等把这个元素在正常栈中找好了位置，就再把辅助栈中的元素一一弹出并放回正常栈中。



## 17.节点间通路

题目：节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

思路：就是DFS或BFS，只不过要学会用C++去写（递归或循环）



## 18.特定深度节点链表

题目：给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。（就是将同一深度的链表切分为同一个新链表）

思路：用BFS，队列存储每一层的子节点（通过队列的size来判断该层有多少个子节点）



## 19.合法二叉树

题目：实现一个函数，检查一棵二叉树是否为二叉搜索树。

**思路**：就是中序遍历，然后**记录一个最大值**，每次遍历完节点左子树后，该节点的值必须大于max即可，然后再去遍历右子树。



## 20.找二叉搜索树的下一个节点

题目：设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。如果指定节点没有对应的“下一个”节点，则返回`null`。

**思路**：递归就行（从上往下）：

如果当前遍历节点的值小于等于要找的值，就说明要找的肯定在右子树；

如果大于该节点的值，则要么是该节点，要么在左子树；



## 21.普通二叉树中的首个共同节点

题目：设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

**思路**：DFS遍历即可，DFS函数返回的是以某个节点的树中是否含有要找的两个节点中的任意一个（bool值），而我们要找的最低公共节点就是：

1. 一个点在该点的左子树中，另一个点在该点的右子树中；
2. 该点就是其中一点，同时另一个点是在该点的左子树或右子树中；



## 22.二叉搜索树序列

题目：从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。

**思路**：**每次选择了一个节点后，其子节点以及包括该点父节点们未选择的子节点就是下一次可以选择的节点**。

要用双端队列deque（deque中的元素就代表路径的下一个节点可以选择的选项们）和DFS，每次DFS函数，首先获取到deque的size，接着循环size次，每次从deque头部取出节点代表下一次选择，接着将该节点的子节点压入deque的尾部，该节点也加入到path中，然后调用下一层DFS去遍历该deque，遍历完后就要**回溯**（恢复状态），就是将deque新加的子节点们pop_back掉，然后将本次节点重新添加到deque的尾部（注意不再是头部），接着也将本节点从path中取掉。



