## POINT1

INT函数要写return，不然会报段错误；



## 001_大数进制转换

思路：略



## 002_成绩排序

思路：略



## 003_一个数的因数个数

思路：

- i从1到根号n，如果n%i == 0，则ans += 2
- 如果最后i*i == n，则ans += 1;



## 004_手机键盘

关键点在于设置一个数组int tag[26] = {1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};

如何判断两个字母是否属于同一个按键？答案：if(tag[a] - tag[b] == a - b)



## 005_质因数的个数

求质因数个数，只需要从0到根号n，不断除即可。最后如果除的结果不是1则ans还需要额外加1；



## 006_整数拆分

一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6.

思路：i是奇数，则dp[i] = dp[i-1]；i是偶数，则dp[i] = 带1的幂和dp[i-1] + 不带1的幂和dp[i/2];



## 007_球的半径和体积

球体积公式4/3Πr3

Pi是acos(-1)或M_PI宏；

保留三位小数用Printf或<iomanip> cout<<setiosflags(ios::fixed)<<setprecision(3);



## 008_最小邮票数

有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。   如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。

思路：dp[i, j]表示前i个物品填满j的最小个数，如果前i个不能凑成j，则dp[i, j] = MAX；

```
对于dp[i][j]来说，
（1）如果放入第i个物品可以填满j容量的背包，那么使用前i-1个物品可以填满j-w[i]容量的背包，于是dp[i][j]=dp[i-1][j-w[i]]+1；
（2）如果不放入第i个物品也可以填满j容量的背包,意味着只使用前i-1个物品仍然可以填满j容量的背包，dp[i][j]=dp[i-1][j]。
总结以上两种情况：dp[i][j]取其中较小的。
```

边界条件dp[i, 0] = 0, dp[0, j] = MAX;

```
memset(dp, 0, sizeof(dp));
for(int i=1; i<101; i++){
	dp[0][i] = MAX;
}
for(int i=1; i<=v.size(); i++){
	for(int j=1; j<=target; j++){
		if(j-v[i-1]>=0){
			dp[i][j] = min(dp[i-1][j], dp[i-1][j-v[i-1]]+1);
		}else{
			dp[i][j] = dp[i-1][j];
		}
	}
}
if(dp[v.size()][target] == MAX) return 0;
return dp[v.size()][target];
```

