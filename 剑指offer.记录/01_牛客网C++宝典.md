- weak_ptr要用的时候必须先lock获取到它所指向的shared_ptr再去调用对象的函数。

- 编译器在执行时会先调用自定义的析构函数再调用合成的析构函数，然后是基类的析构函数

- 用const int &a = b，则b可以不是个常量；但是用constexpr int a = b，则b一定是个常量，且不能constexpr int& a；

- 顶层const不可以用于重载，底层const可以用于重载。 成员函数参数表后面的const修饰的是this指针指向的对象，所以这是一个底层const，可以用于重载；

- C++函数栈空间的最大值是1MB，但是可以调整；

- 函数调用时参数入栈: 将参数按照调用约定(C 是从右向左)依次压入系统栈中;

- ==请你说一说select==

- STL配接器就是bind1st，bind2nd，not1，not2；

  ```c++
  bind1st(op , value )   //op(value , param)
  bind2nd(op , value )   //op(value, param)
  not1(op)               //! op(param)
  not2(op)               //! op(param1, param2)
  ```

- 即使是红黑树实现的map，它的iterator依然可以++或--；

- ==请你说一说epoll原理==

- n个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为O(N)

  ```c++
  vector<int>  FindMax(vector<int> &num)
  {
      int len=num.size();
      if(len==0) return {};    //空数组，返回空
      vector<int> res(len,-1);    //返回结果：初始化-1，表示未找到
      stack<int> notFind; //栈：num中还未找到符合条件的元素索引
  
      int i=0;
      while(i<len)    //遍历数组
      {
           //如果栈空或者当前num元素不大于栈顶，将当前元素压栈，索引后移
          if(notFind.empty() || num[notFind.top()]>=num[i])
          {
              notFind.push(i++);
          }
         //有待处理元素，且num当前元素大于栈顶索引元素，符合条件，更新结果数组中该索引的值，栈顶出栈。
          else
          {
              res[notFind.top()]=num[i];
              notFind.pop();
          } 
      }
   return res;
  }
  ```

- C++类内可以定义引用数据成员，必须通过成员函数初始化列表初始化。

- **对于使用双引号包含的头文件，查找头文件路径的顺序为**：

  当前头文件目录

  编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

  系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

  **对于使用尖括号包含的头文件，查找头文件的路径顺序为**：

  编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

  系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

- bss段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小。

  data段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中。

- 在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

  代码段:包括只读存储区和文本区，其中只读存储区存储**字符串常量**，文本区存储程序的**机器代码**。

  数据段：存储程序中已初始化的全局变量和静态变量

  bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

  堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

  映射区:存储动态链接库以及调用mmap函数进行的文件映射

  栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

- 发生段错误的时机：

  使用野指针，试图修改字符串常量的内容

- ==请你来说一下reactor模型组成==

- ==请自己设计一下如何采用单线程的方式处理高并发==

- ==请你说说select，epoll的区别，原理，性能，限制都说一说==

- C++内存池：

  1. 使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。
  1. 如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。
        a. 如果链表不为空，返回第一个node，链表头改为第二个node。
        b. 如果链表为空，使用blockAlloc请求分配node。
          x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。
          y. 如果内存池只有一个node的空间，直接返回给用户。
          z. 若果如果连一个node都没有，再次向操作系统请求分配内存。
            ①分配成功，再次进行b过程。
            ②分配失败，循环各个自由链表，寻找空间。
              I. 找到空间，再次进行过程b。
              II. 找不到空间，抛出异常。
  3. 用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。
  4. 否则按照其大小找到合适的自由链表，并将其插入。

- 请你说一下多线程和多进程的不同