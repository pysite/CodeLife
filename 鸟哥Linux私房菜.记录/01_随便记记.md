> 以知识点为单位进行记录

### 1.磁盘连接方式和设备文件名关系

> 例题：如果你的PC上面有两个SATA磁盘以及一个USB磁盘，而主板上面有六个SATA的插槽。这两个SATA磁盘分别安插在主板上的SATA1, SATA5插槽上， 请问这三个磁盘在Linux中的设备文件名为何？答：由于是使用侦测到的顺序来决定设备文件名，并非与实际插槽代号有关，因此设备的文件名如下：
>
> 1. SATA1插槽上的文件名：/dev/sda
> 2. SATA5插槽上的文件名：/dev/sdb
> 3. USB磁盘（开机完成后才被系统捉到）：/dev/sdc



柱面通常是文件系统的最小单位，也是分区的最小单位。

尽量将读写较为频繁的目录分区独立出来，这样读写较频繁的磁盘分区有问题时至少不会影响根目录的系统数据。



#### 磁盘分区——MBR方式

MBR是比较老的分区方式，通常旧的磁盘扇区大小为512字节，磁盘的第一个扇区存放有开机记录区MBR(Master Boot Record)和**分区表**。开机记录区MBR存放有**446字节**的开机管理程序，而剩下的分区表就装有**64字节**的分区表。

分区表存放的就是一条条记录，每条记录存放有一个分区的开始和结束**磁道号码**，而按照书中的意思一条记录要16字节（不止存放磁道号码，还有些相关信息），因此MBR的分区表**最多存4个(主要)分区的记录**。



> 假设上面的硬盘设备文件名为/dev/sda时，那么这四个分区在Linux系统中的设备文件名如下
> 所示， 重点在于文件名后面会再接一个数字，这个数字与该分区所在的位置有关喔！
> P1:/dev/sda1
> P2:/dev/sda2
> P3:/dev/sda3
> P4:/dev/sda4



**分区的好处**：

1. 数据分开，不会互相影响。例如，重装系统只会影响C盘不会影响D盘；
2. 性能考虑，例如，C盘的文件只会在第一个分区对应的柱面范围内查找；



**延伸分区**：

因为64字节的限制，MBR第一个扇区内最多4个记录，因此最多4个**主要分区**。**延伸分区**就是指用额外的扇区来记录更多的分区信息，延伸分区会在自己的最前面几个扇区记录自己的分区信息。

> 举个例子就明白到底是怎么回事：
>
> 假设有400个柱面，那么在那64字节中我们可以就分为两个主要分区P1和P2，其中P1用1~100的柱面，P2用101~400的柱面。
>
> 之后在P2的前面几个扇区中我们又可以存放分区记录（来将这个P2进一步细分为5个更小的分区），于是乎P2就被叫做延伸分区，而它细分出来的5个分区被叫做逻辑分区L1~L5。
>
> 同样的，上述的分区在Linux系统中的设备文件名分别如下：
> P1:/dev/sda1
> P2:/dev/sda2	// 3和4直接没有
> L1:/dev/sda5
> L2:/dev/sda6
> L3:/dev/sda7
> L4:/dev/sda8
> L5:/dev/sda9
>
> 设备文件名没有/dev/sda3与/dev/sda4呢？因为前面四个号码都是保留给Primary或Extended用的！所以逻辑分区的设备名称号码就由5号开始了

MBR最多只能有一个延伸分区（操作系统的限制）。主要分区Primary(P)，延伸分区Extended(E)。

MBR的缺点很多，例如：操作系统无法抓取到2.2T以上的磁盘容量，MBR只有一个区块破坏了就会GG，MBR的开机管理程序最多446字节很难受。因此会有下面的GPT分区格式。



#### 磁盘分区——GPT方式

GPT中512KB的扇区被称为逻辑区块位址**LBA**。GPT使用了34个LBA记录分区信息，同时在**末尾33个LBA作为LBA1~34的备份**（防止GG）。

LBA0和MBR类似，存放446字节的第一阶段开机程序，剩下的64字节存放GPT标志，传统MBR识别不了这64字节。

LBA1记录分区表本身位置和大小，也记录备份用的分区表的位置与大小。同时存放分区表的CRC32校验码，验证失败就会启动备份分区表恢复正常运行。

LBA2~34中每个LBA存放4条分区记录，因此每条记录就有128字节，比MBR的16字节大很多，其中用8字节记录磁道号，因此GPT能管理很大的范围。

要使用GPT方式对磁盘进行分区，最好需要单独分出一个**BIOS boot**分区（没讲为什么）。

BIOS boot查了下就是存放一个比较大的**第二阶段开机程序**，因为传统的MBR的第一个扇区后面的扇区没有特殊用处，因此就可以拿来存放stage2的boot loader，而GPT的第一个LBA的后面的LBA还要存放真正的分区表，因此就没地方存放stage2的boot loader，因此需要个BIO boot分区。



### 2.BIOS与UEFI开机检测程序

**CMOS**是记录各项硬件参数且嵌入在主板上面的存储器，**BIOS**则是写入到主板的一个固件（固件就是硬件中的软件），BIOS就是开机时会主动执行的第一个程序。

**BIOS**会依据使用者的设置去取得能够开机的硬盘， 并且到该硬盘里面去读取第一个扇区的MBR位置。 MBR这个仅有446 Bytes的硬盘容量里面会放置最基本的开机管理程序Boot loader。

**开机管理程序**会去磁盘中读取**核心文件**，由于开机管理程序是操作系统在安装的时候所提供的，所以他会认识硬盘内的文件系统格式。之后的工作就是操作系统了。（开机管理程序是操作系统的亲戚）

PS：BIOS载入的是第一阶段的开机管理程序，还有可能有更进一步阶段的开机管理程序。



开机管理程序Boot loader不止可以安装在446字节的MBR中，还可以安装在每个分区的**开机扇区**Boot Sector中。

> 例如第一阶段boot loader开始运行后，就会弹出菜单让用户选择启动Windows还是Linux，选择哪个系统，则此loader就会转而去执行不同的第二阶段的loader从而将相应的操作系统加载进内存。

loader只会认识自己系统盘内的可开机**核心文件**和其它loader。

> Windows在安装的时候，他的安装程序会主动的覆盖掉MBR以及自己所在分区的开机扇区，你没有选择的机会， 而且他没有让我们自己选择菜单的功能。如果先安装Linux再安装Windows话，那MBR的开机管理程序就只会有Windows的项目，而不会有Linux的项目。



#### UEFI BIOS

传统的BIOS固件，采用汇编语言编写，16位，十分弱。而UEFI BIOS则是一个采用C语言编写，更厉害的BIOS程序。

UEFI就是类似的一个低阶操作系统，没有中断方式（采用轮询），没有缓存机制。UEFI比固件BIOS的开机速度**更快**！

UEFI有安全启动模式，这个模式下开机的操作系统必须被UEFI所验证，否则无法顺利开机。（可能会导致你自己电脑的Linux无法启动）

UEFI最好能拥有一个**单独的分区**，来提供其他第三方厂商所使用的UEFI应用程序储存的空间。

> 因此使用了UEFI和GPT的电脑，一般会有BIOS boot 以及 UEFI 支持的分区，基本上你的 /boot 目录几乎都是 /dev/sda3 之后的号码了。



### 3.常见文件系统类型

1. ext2/ext3/ext4：Linux早期适用的文件系统类型。由于ext3/ext4文件系统多了日志的记录， 对于系统的复原比较快速。不过由于磁盘容量越来越大，ext 家族似乎有点挡不住了～所以除非你有特殊的设置需求，否则近来比较少使用 ext4 项目了！
2. swap：就是磁盘仿真成为内存，由于swap并不会使用到目录树的挂载，所以用**swap就****不需要指定挂载点**喔。
3. BIOS Boot：就是 GPT 分区表可能会使用到的项目，若你使用 MBR 分区，那就不需要这个项目了！
4. xfs：这个是目前 CentOS 默认的文件系统，最早是由大型服务器所开发出来的！ 他对于大容量的磁盘管理非常好，而且格式化的时候速度相当快，很适合当今动不动就是好几个 TB 的磁盘的环境喔！因此我们主要用这玩意儿！
5. vfat：同时被Linux与Windows所支持的文件系统类型。如果你的主机硬盘内同时存在Windows与Linux操作系统，为了数据的交换， 确实可以创建一个vfat的文件系统喔！



### 4.首次登陆与线上求助

Linux使用非同步的磁盘/内存数据传输模式，同时又是个多用户多任务的环境，因此不能随便地不正常关机。

Linux默认的情况下会提供六个Terminal来让使用者登陆， 切换的方式为使用：[Ctrl] + [Alt] + [F1]~[F6]的组合按钮。系统会将[F1] ~ [F6]命名为tty1 ~ tty6的操作接口环境。(PS：F1是GUI界面)



#### X-Window与GNOME的关系

通俗地讲，X-Window就代指Linux系统中的图形界面，它是一种标准/协议，GNOME是X-Window的一种具体实现。

> Linux中启动图形界面的指令：``startx``



startx生效至少需要下面这几件事情的配合：

1. 并没有其他的 X window 被启用；
2. 你必须要已经安装了X Window system，并且X server是能够顺利启动的；
3. 你最好要有窗口管理员，例如GNOME/KDE或者是阳春的TWM等；



X-Window是一种C/S架构， X Window System本身是一个非常复杂的图形化作业环境，我们可以将其分成3个部分，分别是X Server、X Client和X Protocol。X Server主要是处理输入输出的信息，X Client执行大部分应用程序的运算功能，X Protocol则是建立X Server和X Client的沟通管道。

> X Server就是类似画家，而X Client（各种应用程序）就类似委托人，这些委托人请求画家画出自己程序的界面给用户看。





Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同。



Ctrl+C 停止正在运行的指令；

Ctrl+D 代表End Of File，EOF的意思，在shell中相当于输入exit；

Shift+PageUP / PageDown 在Shell中向上翻页或向下翻页；



#### Linux中数据后面的数字

| 代号 | 代表内容                                                     |
| ---- | ------------------------------------------------------------ |
| 1    | 使用者在shell环境中可以操作的指令或可可执行文件              |
| 2    | 系统核心可调用的函数与工具等                                 |
| 3    | 一些常用的函数（function）与函数库（library），大部分为C的函数库（libc） |
| 4    | 设备文件的说明，通常在/dev下的文件                           |
| 5    | 配置文件或者是某些文件的格式                                 |
| 6    | 游戏（games）                                                |
| 7    | 惯例与协定等，例如Linux文件系统、网络协定、ASCII code等等的说明 |
| 8    | 系统管理员可用的管理指令                                     |
| 9    | 跟kernel有关的文件                                           |



#### man page

man+指令 可以查看指令的详细信息，man的文件存放在``/usr/share/man``这个目录里面；

查找某个指令相关的所有man page：``man -f 指令``

如果不止一个man page 可以加选项打开特定man page：``man 选项 指令``

查看某个关键字相关的所有man page：``man -k 关键字``

在shell中输入``whatis``就相当于``man -f``，``apropos``就相当于``man -k``



#### info page

info和man类似，都是用来查询指令用法的。info page是类似网页的那种，还有超链接在里面。

info page数据存放于``/usr/share/info/``中，``info info``查看最基础的info介绍。

在info page中按h(help)键是查看info reader的快捷键；



``/usr/share/doc``目录下存放的是一些其他非常有用的文档，例如软件的说明文档、未来计划、安装须知等。



#### 超简单文书编辑器：nano

指数符号（^）代表的是键盘的[Ctrl]按键。

M代表的是[Alt]按键。





### 5.正确的关机方法

Windows是单人假多任务，Linux是多人多任务，因此你关机可能会中断其他人的程序or数据。

观察系统的状态：``netstat -a``查看网线的连接状态，``ps -aux``查看背景正在执行的程序。



#### 数据同步写入磁盘：sync

在命令行下输入``sync``，那么在内存中尚未被更新的数据，就会被写入硬盘中！所以，这个指令在系统关机或重新开机之前， 很重要，最好多执行几次。

目前的 shutdown/reboot/halt 等等指令均已经在关机前进行了 sync 这个工具的调用。

事实上sync也可以被一般帐号使用，只不过一般帐号使用者所更新的硬盘数据就仅有自己的数据，不像root可以更新整个系统中的数据。



#### 惯用的关机指令：shutdown

``shutdown --help``

``man shutdown``

例子：

``shutdown -p +0`` 立即关机（PS：-p和-h都是关机的意思）

``shutdown -r +30 "The system will reboot" ``再过30分钟重启，后面的消息会发送给所有在线上的使用者。



#### 重启，关机：reboot, halt, poweroff

``man reboot``



#### 实际使用管理工具 systemctl 关机

上面谈到的 halt, poweroff, reboot, shutdown 等等，其实都是调用这个 systemctl 指令

格式：``systemctl [指令]``

例子：

``systemctl reboot``

``systemctl poweroff``



P254
