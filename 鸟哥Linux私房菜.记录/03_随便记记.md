> 所有实体磁盘的文件名都已经被仿真成 /dev/sd[a-p] 的格式，第一颗磁盘文件名为 /dev/sda。 而分区的文件名若以第一颗磁盘为例，则为 /dev/sda[1-128] 。除了实体磁盘之外，虚拟机的磁盘通常为 /dev/vd[a-p] 的格式。 若有使用到软件磁盘阵列的话，那还有 /dev/md[0-128] 的磁盘文件名。使用的是 LVM 时，文件名则为/dev/VGNAME/LVNAME 等格式。

- ``/dev/sd[a-p][1-128]``：为实体磁盘的磁盘文件名；

- ``/dev/vd[a-d][1-128]``：为虚拟磁盘的磁盘文件名



### 12.认识Linux文件系统

传统来说，一个分区只能有一个文件系统，由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列（software raid）， 这些技术可以将一个分区格式化为多个文件系统（例如LVM），也能够将多个分区合成一个文件系统（LVM, RAID）。

#### EXT2

EXT2 = BootSector + 多个BlockGroup.

**其中**：

BlockGroup = SuperBlock + FS描述 + Block BitMap + Inode BitMap + InodeTable + DataBlocks



- BootSector

  存放开机管理程序，如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，从而既装Winodws又装Linux。

- DataBlock

  Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种。在格式化时 block 的大小就固定了，每个block都有编号。

- InodeTable

  （略，你懂的）

- SuperBlock

  实上除了第一个 block group 内会含有 superblock之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock主要是做为第一个 block group 内 superblock 的备份。

- FS描述

  描述每个 block group 的开始与结束的 block 号码，以及说明每个区段（superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。

- Block BitMap

  表明哪些Block是空的。

- Inode BitMap

  表明哪些Inode是空的。



``dumpe2fs``：查询 Ext 家族 superblock 信息的指令。

``blkid`` 查看目前系统中所有被格式化的设备



#### 日志式文件系统

> 这个日志式不是追加写的那种

1. 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信
   息；
2. 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；
3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。

Ext3/Ext4是Ext2的升级版，有Journal Inode专门负责存储日志。



不同文件系统的Inode编号是自己管理的，因此可能在Linux中可能出现不同挂载点下的文件的Inode号相同的情况。

XFS filesystem 最顶层的目录之 inode 一般为 128 号，因此CentOS7中``/``, ``/boot``, ``/home``三个目录的inode号都是128.



查看当前Linux支持的文件系统：

```shell
ls -l /lib/modules/$（uname -r）/kernel/fs
```

查看目前Linux已经载入到内存中支持的文件系统：

```shell
cat /proc/filesystems
```



Linux用VFS统一管理各种不同的文件系统。



#### XFS

传统的EXT文件系统格式化（划分各种inode和block等区域）太慢（随着当今磁盘的容量越来越大）

XFS是被开发来用于大容量磁盘以及高性能文件系统之用，因此适合现在的系统环境。xfs也几乎具有EXT4的所有功能。

XFS = DataSection + LogSection + RealtimeSection

- 数据区DataSection

跟之前谈到的EXT家族类似，包括inode/data block/superblock等数据，都放置在这个区块。

实际上，DataSection分为多个储存区群组AllocationGroup(AG)，每个储存区群组都包含了：（1）整个文件系统的 superblock、 （2）剩余空间的管理机制、 （3）inode的分配与追踪。

inode与 block 都是系统需要用到时才动态配置产生，所以格式化很快。

XFS的Block和Inode的大小都是可变化，不过一般还是为了配合Linux，将Block设置为4KB，将Inode设置为256B。

- 日志区LogSection（文件系统活动登录区）

文件的变化会在这里纪录下来，直到该变化完整的写入到数据区后，该笔纪录才会被终结。

XFS可以指派外部的磁盘来作为XFS的LogSection，例如用一个固态硬盘，因为日志区改动非常频繁。

- 实时运行区RealtimeSection

文件要被创建时，xfs 会在这个区段里面找一个到数个的 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到 data section 的 inode 与 block 去。



``xfs_info``查看XFS的相关信息。和EXT的``dumpe2fs``类似。



### 13.文件系统的简单操作

#### 磁盘与目录的容量

``df``查看当前系统中的文件系统的信息

``du``评估某个路径里文件与目录的磁盘使用量

相当于``df``是去各个文件系统的superblock中查看信息，而``du``是去各个文件的inode查看信息。

``ln``不加任何参数就是创建硬链接，``-s``是创建软链接。



创建一个目录``/tmp/test``会新创建出三个路径：

```shell
/tmp/testing
/tmp/testing/.
/tmp/testing/..
```

因此/tmp/test的link数会加2，而上层的/tmp的link数会加1.



#### 看磁盘

``lsblk``看所有的存储设备。

``blkid``查看所有设备的UUID和文件系统类型。同一磁盘的不同分区被看做是不同的设备。

``parted``查看某个设备的分区信息。

总的来说，``lsblk``查看系统上的所有设备，``blkid``查看所有文件系统，``parted``查看设备的分区信息。



#### 亲自来进行磁盘分区

GPT分区使用``gdisk``，MBR分区使用``fdisk``。

只要离开gdisk时按下“q”，那么所有的动作都不会生效，相反 按下“w”就是动作生效的意思。

``gdisk -n``增加分区，按照提示来输入各种参数即可。

``partprobe -s``更新分区表。

``gdisk -d``删除分区。



#### 分区格式化（加载文件系统）

``mkfs.xfs``加载XFS文件系统。

xfs 可以使用多个数据流来读写系统，以增加速度，因此那个 agcount 可以跟 CPU 的核心数来做搭配！举例来说，如果我的服务器仅有一颗 4 核心，但是有启动 Intel 超线程功能，则系统会仿真出 8 颗 CPU 时，那个 agcount 就可以设置为 8 喔。

``grep 'processor' /proc/cpuinfo``查看自己电脑的cpu数目。



> ``mkfs.xfs ``中``su``参数是RAID中stripe的大小，``sw``是RAID中用于储存数据的磁盘数量（须扣除备份碟与备用碟）。
>
> 磁盘阵列是多颗磁盘组成一颗大磁盘的意思， 利用同步写入到这些磁盘的技术，不但可以加快读写速度，还可以让某一颗磁盘坏掉时，整个文件系统还是可以持续运行的状态。
>
> 磁盘阵列 （RAID） 就是通过将文件先细分为数个小型的分区区块 （stripe） 之后，然后将众多的 stripes 分别放到磁盘阵列里面的所有磁盘， 所以一个文件是被同时写入到多个磁盘去。
>
> 在这些磁盘里面，会保留数个（与磁盘阵列的规划有关） 备份磁盘 （parity disk）， 以及可能会保留一个以上的备用磁盘（spare disk）。
>
> （后面会细讲RAID）



其他文件系统格式化：查看系统其他格式化指令

```shell
[root@study ~]# mkfs[tab][tab]
mkfs mkfs.btrfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.ext4
mkfs.fat mkfs.minix mkfs.msdos mkfs.vfat mkfs.xfs
```



#### 文件系统的检查与恢复

``xfs_repair``指令修复一个被格式化为XFS文件系统的分区，需要先umount文件系统（先卸载）。

> 在扫瞄磁盘的时候，可能会造成部分 filesystem 的修订，所以“执行 xfs_repair/fsck.ext4 时，被检查的 partition 不可挂载到系统上.

``xfs_repair``是通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作。



``fsck``指令和``mkfs``指令一样是个综合指令。

``fsck.ext4``检查EXT4文件系统。

```shell
# 获取某个EXT4文件系统分区中Blocks per group的信息
[root@study ~]# dumpe2fs -h /dev/vda5; grep 'Blocks per group'
Blocks per group: 32768

# 知道一个group的大小后，就可以知道第二个Superblock(备份)的位置，注意block号从0开始
[root@study ~]# fsck.ext4 -b 32768 /dev/vda5
```



#### 文件系统的挂载与卸载

文件系统的挂载点理论应该是空目录，但实际上不是空的则会让原来的文件被隐藏而已，等这个文件系统被卸载后原来的文件就又会显示出来。

注意文件系统在挂载时应该是一个设备已经被格式化好了，机器直接可以去按照某个文件系统的格式读取磁盘中的数据才可。

Linux支持的文件系统的驱动程序目录：``/lib/modules/$（uname -r）/kernel/fs/``



使用UUID进行挂载：

```shell
[root@study ~]# blkid /dev/vda4
/dev/vda4: UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" TYPE="xfs"
[root@study ~]# mount UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" /data/xfs
```



``mount --bind``可以进行硬链接，将一个目录挂载到另一个目录去。

``umount``进行文件系统的卸载。



#### Linux设备主次设备号

Linux内核认识的设备数据就是通过主、次设备号码，major、minor。

主设备号是决定设备类型的，次设备号则是表明当前系统中这是同类型的第几个设备。



#### 磁盘/文件系统参数修订

- mknod

``mknod``可以创建设备文件，但在Linux2.6之后就不需要我们手动创建了。

- xfs_admin

``xfs_admin``修改一个设备的 label 或者 UUID。（必须在设备尚未挂载的时候）

PS：在mount时即可指定设备名，也可指定设备的label或者设备的UUID来进行挂载。

- tune2fs

这个和上面的xfs_admin一样，用于修改一个EXT4的 label 或者 UUID。



### 14.开机自动挂载

要求：mount point一定是已创建的目录；根目录一定是必须要最先挂载的。

- /etc/fstab

这个文件中就是存储有开机的自动挂载顺序，通过修改这个文件我们可以添加要自动挂载的文件系统。

```shell
[root@study ~]# cat /etc/fstab
# Device Mount point filesystem parameters dump fsck
/dev/mapper/centos-root / xfs defaults 0 0
UUID=94ac5f77-cb8a-495e-a65b-2ef7442b837c /boot xfs defaults 0 0
/dev/mapper/centos-home /home xfs defaults 0 0
/dev/mapper/centos-swap swap swap defaults 0 0
#Device一栏可以是设备文件名、UUID、Label
```

/etc/fstab 是开机时的配置文件，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个文件。



#### 镜像文件的挂载

> 从网上下载了DVD的镜像，此时并不需要真的用光盘驱动才能读取其中的数据。
>
> 用loop设备即可。

```shell
# 举例
mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd
```

``/dev/zero`` 是会一直输出 0 的设备。



#### swap

swap 主要的功能是当实体内存不够时，则某些在内存当中所占的程序会暂时被移动到swap 当中，让实体内存可以被需要的程序来使用。另外，如果你的主机支持电源管理模式，也就是说，你的 Linux 主机系统可以进入“休眠”模式的话，那么， 运行当中的程序状态则会被纪录到 swap 去，以作为“唤醒”主机的状态依据。



``parted``指令是gdisk或fdisk的GNU版本。既可以MBR分区也可以GPT分区。

分区表格式显示``msdos``就是MBR分区表。

``mklabel``的意思就是make分区表。重新格式化。

``mkpart``的意思是在当前分区表的基础上，添加一个分区。



如果磁盘已无未分区的容量，可以考虑使用大型文件取代磁盘设备的处理方式，通过 dd
与格式化功能。

开机自动挂载可参考/etc/fstab之设置，设置完毕务必使用 mount -a 测试语法正确否；（mount -a就是按照/etc/fstab中的指令进行自动挂载一遍）



### 15.压缩文件

P420