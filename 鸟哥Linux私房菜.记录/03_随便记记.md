> 所有实体磁盘的文件名都已经被仿真成 /dev/sd[a-p] 的格式，第一颗磁盘文件名为 /dev/sda。 而分区的文件名若以第一颗磁盘为例，则为 /dev/sda[1-128] 。除了实体磁盘之外，虚拟机的磁盘通常为 /dev/vd[a-p] 的格式。 若有使用到软件磁盘阵列的话，那还有 /dev/md[0-128] 的磁盘文件名。使用的是 LVM 时，文件名则为/dev/VGNAME/LVNAME 等格式。

- ``/dev/sd[a-p][1-128]``：为实体磁盘的磁盘文件名；

- ``/dev/vd[a-d][1-128]``：为虚拟磁盘的磁盘文件名



### 12.认识Linux文件系统

传统来说，一个分区只能有一个文件系统，由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列（software raid）， 这些技术可以将一个分区格式化为多个文件系统（例如LVM），也能够将多个分区合成一个文件系统（LVM, RAID）。

#### EXT2

EXT2 = BootSector + 多个BlockGroup.

**其中**：

BlockGroup = SuperBlock + FS描述 + Block BitMap + Inode BitMap + InodeTable + DataBlocks



- BootSector

  存放开机管理程序，如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，从而既装Winodws又装Linux。

- DataBlock

  Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种。在格式化时 block 的大小就固定了，每个block都有编号。

- InodeTable

  （略，你懂的）

- SuperBlock

  实上除了第一个 block group 内会含有 superblock之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock主要是做为第一个 block group 内 superblock 的备份。

- FS描述

  描述每个 block group 的开始与结束的 block 号码，以及说明每个区段（superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。

- Block BitMap

  表明哪些Block是空的。

- Inode BitMap

  表明哪些Inode是空的。



``dumpe2fs``：查询 Ext 家族 superblock 信息的指令。

``blkid`` 查看目前系统中所有被格式化的设备



#### 日志式文件系统

> 这个日志式不是追加写的那种

1. 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信
   息；
2. 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；
3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。

Ext3/Ext4是Ext2的升级版，有Journal Inode专门负责存储日志。



不同文件系统的Inode编号是自己管理的，因此可能在Linux中可能出现不同挂载点下的文件的Inode号相同的情况。

XFS filesystem 最顶层的目录之 inode 一般为 128 号，因此CentOS7中``/``, ``/boot``, ``/home``三个目录的inode号都是128.



查看当前Linux支持的文件系统：

```shell
ls -l /lib/modules/$（uname -r）/kernel/fs
```

查看目前Linux已经载入到内存中支持的文件系统：

```shell
cat /proc/filesystems
```



Linux用VFS统一管理各种不同的文件系统。



#### XFS

传统的EXT文件系统格式化（划分各种inode和block等区域）太慢（随着当今磁盘的容量越来越大）

XFS是被开发来用于大容量磁盘以及高性能文件系统之用，因此适合现在的系统环境。xfs也几乎具有EXT4的所有功能。

XFS = DataSection + LogSection + RealtimeSection

- 数据区DataSection

跟之前谈到的EXT家族类似，包括inode/data block/superblock等数据，都放置在这个区块。

实际上，DataSection分为多个储存区群组AllocationGroup(AG)，每个储存区群组都包含了：（1）整个文件系统的 superblock、 （2）剩余空间的管理机制、 （3）inode的分配与追踪。

inode与 block 都是系统需要用到时才动态配置产生，所以格式化很快。

XFS的Block和Inode的大小都是可变化，不过一般还是为了配合Linux，将Block设置为4KB，将Inode设置为256B。

- 日志区LogSection（文件系统活动登录区）

文件的变化会在这里纪录下来，直到该变化完整的写入到数据区后，该笔纪录才会被终结。

XFS可以指派外部的磁盘来作为XFS的LogSection，例如用一个固态硬盘，因为日志区改动非常频繁。

- 实时运行区RealtimeSection

文件要被创建时，xfs 会在这个区段里面找一个到数个的 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到 data section 的 inode 与 block 去。



``xfs_info``查看XFS的相关信息。和EXT的``dumpe2fs``类似。



### 13.文件系统的简单操作

#### 磁盘与目录的容量

``df``查看当前系统中的文件系统的信息

``du``评估某个路径里文件与目录的磁盘使用量

相当于``df``是去各个文件系统的superblock中查看信息，而``du``是去各个文件的inode查看信息。

``ln``不加任何参数就是创建硬链接，``-s``是创建软链接。



创建一个目录``/tmp/test``会新创建出三个路径：

```shell
/tmp/testing
/tmp/testing/.
/tmp/testing/..
```

因此/tmp/test的link数会加2，而上层的/tmp的link数会加1.



#### 看磁盘

``lsblk``看所有的存储设备。

``blkid``查看所有设备的UUID和文件系统类型。同一磁盘的不同分区被看做是不同的设备。

``parted``查看某个设备的分区信息。

总的来说，``lsblk``查看系统上的所有设备，``blkid``查看所有文件系统，``parted``查看设备的分区信息。



#### 亲自来进行磁盘分区

GPT分区使用``gdisk``，MBR分区使用``fdisk``。

只要离开gdisk时按下“q”，那么所有的动作都不会生效，相反 按下“w”就是动作生效的意思。

``gdisk -n``增加分区，按照提示来输入各种参数即可。

``partprobe -s``更新分区表。

``gdisk -d``删除分区。



#### 分区格式化（加载文件系统）

``mkfs.xfs``加载XFS文件系统。

xfs 可以使用多个数据流来读写系统，以增加速度，因此那个 agcount 可以跟 CPU 的核心数来做搭配！举例来说，如果我的服务器仅有一颗 4 核心，但是有启动 Intel 超线程功能，则系统会仿真出 8 颗 CPU 时，那个 agcount 就可以设置为 8 喔。

``grep 'processor' /proc/cpuinfo``查看自己电脑的cpu数目。



> ``mkfs.xfs ``中``su``参数是RAID中stripe的大小，``sw``是RAID中用于储存数据的磁盘数量（须扣除备份碟与备用碟）。
>
> 磁盘阵列是多颗磁盘组成一颗大磁盘的意思， 利用同步写入到这些磁盘的技术，不但可以加快读写速度，还可以让某一颗磁盘坏掉时，整个文件系统还是可以持续运行的状态。
>
> 磁盘阵列 （RAID） 就是通过将文件先细分为数个小型的分区区块 （stripe） 之后，然后将众多的 stripes 分别放到磁盘阵列里面的所有磁盘， 所以一个文件是被同时写入到多个磁盘去。
>
> 在这些磁盘里面，会保留数个（与磁盘阵列的规划有关） 备份磁盘 （parity disk）， 以及可能会保留一个以上的备用磁盘（spare disk）。
>
> （后面会细讲RAID）



其他文件系统格式化：查看系统其他格式化指令

```shell
[root@study ~]# mkfs[tab][tab]
mkfs mkfs.btrfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.ext4
mkfs.fat mkfs.minix mkfs.msdos mkfs.vfat mkfs.xfs
```



#### 文件系统的检查与恢复

``xfs_repair``指令修复一个被格式化为XFS文件系统的分区，需要先umount文件系统（先卸载）。

> 在扫瞄磁盘的时候，可能会造成部分 filesystem 的修订，所以“执行 xfs_repair/fsck.ext4 时，被检查的 partition 不可挂载到系统上.

``xfs_repair``是通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作。



``fsck``指令和``mkfs``指令一样是个综合指令。

``fsck.ext4``检查EXT4文件系统。

```shell
# 获取某个EXT4文件系统分区中Blocks per group的信息
[root@study ~]# dumpe2fs -h /dev/vda5; grep 'Blocks per group'
Blocks per group: 32768

# 知道一个group的大小后，就可以知道第二个Superblock(备份)的位置，注意block号从0开始
[root@study ~]# fsck.ext4 -b 32768 /dev/vda5
```



#### 文件系统的挂载与卸载

文件系统的挂载点理论应该是空目录，但实际上不是空的则会让原来的文件被隐藏而已，等这个文件系统被卸载后原来的文件就又会显示出来。

注意文件系统在挂载时应该是一个设备已经被格式化好了，机器直接可以去按照某个文件系统的格式读取磁盘中的数据才可。

Linux支持的文件系统的驱动程序目录：``/lib/modules/$（uname -r）/kernel/fs/``



使用UUID进行挂载：

```shell
[root@study ~]# blkid /dev/vda4
/dev/vda4: UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" TYPE="xfs"
[root@study ~]# mount UUID="e0a6af55-26e7-4cb7-a515-826a8bd29e90" /data/xfs
```



``mount --bind``可以进行硬链接，将一个目录挂载到另一个目录去。

``umount``进行文件系统的卸载。



#### Linux设备主次设备号

Linux内核认识的设备数据就是通过主、次设备号码，major、minor。

主设备号是决定设备类型的，次设备号则是表明当前系统中这是同类型的第几个设备。



#### 磁盘/文件系统参数修订

- mknod

``mknod``可以创建设备文件，但在Linux2.6之后就不需要我们手动创建了。

- xfs_admin

``xfs_admin``修改一个设备的 label 或者 UUID。（必须在设备尚未挂载的时候）

PS：在mount时即可指定设备名，也可指定设备的label或者设备的UUID来进行挂载。

- tune2fs

这个和上面的xfs_admin一样，用于修改一个EXT4的 label 或者 UUID。



### 14.开机自动挂载

要求：mount point一定是已创建的目录；根目录一定是必须要最先挂载的。

- /etc/fstab

这个文件中就是存储有开机的自动挂载顺序，通过修改这个文件我们可以添加要自动挂载的文件系统。

```shell
[root@study ~]# cat /etc/fstab
# Device Mount point filesystem parameters dump fsck
/dev/mapper/centos-root / xfs defaults 0 0
UUID=94ac5f77-cb8a-495e-a65b-2ef7442b837c /boot xfs defaults 0 0
/dev/mapper/centos-home /home xfs defaults 0 0
/dev/mapper/centos-swap swap swap defaults 0 0
#Device一栏可以是设备文件名、UUID、Label
```

/etc/fstab 是开机时的配置文件，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个文件。



#### 镜像文件的挂载

> 从网上下载了DVD的镜像，此时并不需要真的用光盘驱动才能读取其中的数据。
>
> 用loop设备即可。

```shell
# 举例
mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd
```

``/dev/zero`` 是会一直输出 0 的设备。



#### swap

swap 主要的功能是当实体内存不够时，则某些在内存当中所占的程序会暂时被移动到swap 当中，让实体内存可以被需要的程序来使用。另外，如果你的主机支持电源管理模式，也就是说，你的 Linux 主机系统可以进入“休眠”模式的话，那么， 运行当中的程序状态则会被纪录到 swap 去，以作为“唤醒”主机的状态依据。



``parted``指令是gdisk或fdisk的GNU版本。既可以MBR分区也可以GPT分区。

分区表格式显示``msdos``就是MBR分区表。

``mklabel``的意思就是make分区表。重新格式化。

``mkpart``的意思是在当前分区表的基础上，添加一个分区。



如果磁盘已无未分区的容量，可以考虑使用大型文件取代磁盘设备的处理方式，通过 dd
与格式化功能。

开机自动挂载可参考/etc/fstab之设置，设置完毕务必使用 mount -a 测试语法正确否；（mount -a就是按照/etc/fstab中的指令进行自动挂载一遍）



### 15.压缩文件

```shell
*.Z 	# compress 程序压缩的文件；
*.zip 	# zip 程序压缩的文件；
*.gz 	# gzip 程序压缩的文件；
*.bz2 	# bzip2 程序压缩的文件；
*.xz 	# xz 程序压缩的文件；
*.tar 	# tar 程序打包的数据，并没有压缩过；
*.tar.gz 	# tar 程序打包的文件，其中并且经过 gzip 的压缩
*.tar.bz2 	# tar 程序打包的文件，其中并且经过 bzip2 的压缩
*.tar.xz 	# tar 程序打包的文件，其中并且经过 xz 的压缩
```

tar 可以将很多文件“打包”成为一个文件！甚至是目录也可以这么玩。不过，单纯的 tar功能仅是“打包”而已，并没有提供压缩的功能，后来GNU 计划中将整个 tar 与压缩的功能结合在一起。



#### gzip

目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。

``gzip``是压缩，``gzip -d``是解压缩。

使用 gzip 压缩的文件在 Windows 系统中，可以被 WinRAR/7zip 软件解压缩。

``gzip -9``以最高的压缩等级去压缩文件，压缩等级是1~9，越高则越慢。

zcat/zmore/zless 可以对应于cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件。

可以通过 zgrep 在 纯文本文件被压缩后的压缩文件 中搜寻关键字。

``compress``已经被淘汰了，可以通过``znew``将compress创建的``*.z``文件转为gzip格式。



#### bzip2

gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代gzip 并提供更佳的压缩比而来的。

bzip2和gzip差不多的用法。

zcat/zmore/zless等变成了bz***之类的指令，例如bzcat。



#### xz

xz是比bzip2压缩比更高的软件，用法也和``bzip2/gzip``一样。

zcat等指令变成类似xcat之类的指令。



#### tar

> 虽然 gzip, bzip2, xz 也能够针对目录来进行压缩，不过， 这两个指令对目录的压缩指的是“将目录内的所有文件 "分别" 进行压缩”的动作。
>
> Windows 的 WinRAR 也支持 .tar.gz文件名的解压缩。

```shell
# 压缩
tar -jcv -f 目的文件名.tar.bz2 源目录名
# 查询
tar -jtv -f 目的文件名.tar.bz2
# 解压缩
tar -jxv -f 目的文件名.tar.bz2 -C 要解压到的目录名
# PS: -z是gzip, -j是bzip2, -J是xz
```

``-p``是保留数据的原本权限与属性，``-P``是保留路径的根目录符号`/`，这样解压出的文件就会去固定的位置而非在当前压缩文件所在的目录下（可能会覆盖一些系统关键文件，这招慎用）

-  解压某个压缩文件中单独一个文件``xxx/yyy``

  ``tar -jxv -f 目的文件名.tar.bz2 xxx/yyy``

- 打包某目录，但不含该目录下的某些文件之作法

  用``--exclude=``参数，例如不想要以``/root/etc*``开头的文件：

  ```shell
  tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* /root
  ```

- 仅备份比某个时刻更新的文件

  用``--newer``（看mtime和ctime）或``--newer-mtime``（只看mtime）

  ```shell
  tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 --newer-mtime="2015/06/17" /etc/*
  ```

- tarfile, tarball

  仅是打包而已，就是“ tar -cv -f file.tar ”而已，这个文件我们称呼为 tarfile。

  还有进行压缩的支持，例如“ tar -jcv -f file.tar.bz2 ”时，我们就称呼为 tarball。

- 命令行中的 -

  输出文件变成 - 而输入文件也变成 -，就是在代表standard output, standard input。

  

### 16.XFS文件系统的备份和恢复

#### 文件系统备份xfsdump

- xfsdump进行备份的数据只能被xfsrestore解析
- xfsdump只能对正在挂载的文件系统进行备份
- xfsdump通过文件系统的UUID分辨各个备份文件，因此不能备份两个具有相同UUID的文件系统



xfsdump支持差分备份，例如第一次备份是level0，第二次备份是level1（这个level1就只会备份当前文件系统与第一次文件系统level0的有差异的文件）

``xfsdump -l <level>`` 中``-l``后面跟的就是level。



#### 文件系统还原xfsrestore

差分备份的文件系统还原时也需要按照level 0 -> level 1 -> level 2..顺序进行还原。

- 还原单个文件用``-s``（``-f``后面跟xfsdump产生的文件，``-L``是xfsdump时写的session label）

  ``xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2``

- 还原level0

  ``xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot``

- 再还原level1

  ``xfsrestore -f /srv/boot.dump1 /tmp/boot``

  

### 17.光盘写入

#### 创建镜像文件mkisofs

想要把数据烧录到光盘DVD中，必须先把数据包装成iso文件后才可。

要把多个目录里面的数据烧到DVD中时，默认是不会包含外面的这些目录的，例如烧录/root, /home，结果是只把这两个目录中的数据拿了出来都放置在一起，而没有/root和/home这两个文件夹。要想/root 和 /home这两个东西都在，则需要``-graft-point``参数。

当然以上也可以将/root, /home 先全部复制到 /srv/cdrom 当中，然后跑到 /srv/cdrom 当
中， 再使用类似“ mkisofs -r -v -o /tmp/system.img . ”的方式来处理。（和-grafit-point的效果相同，因为此时/root和/home变成了目录里面的文件）



``rsync -a 目录A 目录B`` rsync 可以完整的复制所有的权限属性等数据，也能够进行镜像处理。

> 如何让这片光盘的内容被修改之后， 还可以烧录成为可开机的模样呢？
>
> 答：先将DVD中数据利用rsync指令复制到一个新文件夹，然后再用mkisofs指令创建新的iso。



#### 光盘烧录工具cdrecord

新版的 CentOS 7 使用的是 ``wodim`` 这个文字界面指令来进行烧录的行为。

wodim中参数``blank=``是指定光盘是否先擦除，以及擦除多少。



查看系统中的DVD设备：``wodim --devices dev=/dev/sr0``

> 一定要有dev=/dev/xxx 那一段，不然系统会告诉你找不到光盘！ 这真的是很奇怪！不过，反正我们知道光驱的文件名为 /dev/sr0 之类的，直接带入即可。



擦除光盘：``wodim -v dev=/dev/sr0 blank=fast``

开始烧录：``wodim -v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img``



### 18.其他常见的压缩与备份工具

#### dd

dd 可以读取磁盘设备的内容（几乎是直接读取扇区"sector"），然后将整个设备备份成一个文件。

> 默认 dd 是一个一个扇区去读/写的，即使没有用到的扇区也会倍写入备份文件中。因此这个文件会变得跟原本的磁盘一模一样大，不像使用 xfsdump 只备份文件系统中有使用到的部份。

``dd if="input_file" of="output_file" bs="block_size" count="number"``



因为 XFS 文件系统主要使用 UUID 来分辨文件系统，使用 dd 复制，连 UUID也都复制成为相同。需要使用之前的 xfs_repair 及 xfs_admin 来修订。（这也说明UUID是会写会到设备中存储起来？）



#### cpio

cpio = ``cp指令`` + io

- cpio知道以下指令即可：

  ``cpio -ovcB > [file | device]`` 备份到右边的文件中

  ``cpio -ivcdu < [file | device]`` 从右边的文件中提取数据到当前目录

  ``cpio -ivct < [file | device]`` 查看右边的文件

> 而由于 cpio 必需要配合其他的程序，例如 find 来创建文件名，所以 cpio 与管线命令及数据流重导向的相关性就相当的重要

> 额我发现还是看cpio --help的例子比较清晰。
>
> - 归档 name-list 中的文件到 archive
>     ``cpio -o < name-list [> archive]``
> - 从 archive 中提取文件
>     ``cpio -i [< archive]``
> - 拷贝 name-list 中的文件到目标目录(destination-directory)
>     ``cpio -p destination-directory < name-list``