### 19.Vim

为什么学Vim：

1. 所有的 Unix Like 系统都会内置 vi 文书编辑器，其他的文书编辑器则不一定会存在；
2. 很多个别软件的编辑接口都会主动调用 vi （例如未来会谈到的 crontab, visudo, edquota
   等指令）；
3. vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；
4. 因为程序简单，编辑速度相当快速。

#### Vim三种模式

1. 一般指令模式（command mode）

使用vim进入一个文件时就是"一般指令模式"，此模式下可以：

使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据。

2. 编辑模式（insert mode）

按下"i, I, o, O, a, A, r, R"任一字母即可进入编辑模式。按"Esc"键即可退出。此模式下可以：

编辑文件内容。

3. 命令行模式（command-line mode）

输入“ : / ? ”三个中的任何一个按钮，就可以将光标移动到最下面那一列。此模式下可以：

搜寻数据，读取、存盘、大量取代字符、离开 vi 、显示行号等等。



如果你的文件权限不对，例如为 -r--r--r-- 时，那么可能会无法写入，此时可以使用“强制写入”的方式，使用“ :wq! ” 多加一个惊叹号即可。



#### 一般指令模式

> 指令也会区分大小写！

1. 输入一个数字后按方向键即可朝那个方向一下移动多格。
2. ctrl+f 向下移动一页；+b 向上移动一页；+d 向下移动半页；+u 向上移动半页。
3. -+也可以上下移动光标。
4. 输入数字后按空格可以使光标向后移动n格。会自动换行。
5. 0调到这一行最前面，$跳到这行最后面。
6. ``数字+回车`` 光标向下移动n行
7. ``数字+G`` 移动到第n行
8. ``/xxx``光标之下查找xxx字符串，``?xxx``光标之上查找xxx字符串。此时按下``n``会查询下一个or上一个。按下``N``效果与``n``相反。
9. ``:n1,n2s/xxx/yyy/g``将第n1到n2行之间所有的xxx换为yyy。如果n2是$就代表一直到文件末尾。如果最后是``gc``则代表还需要confirm即替换之前询问一下。
10. ``x``向后删（删除光标所在的字母），``X``往前删（删除光标前一个字母）。``nx``向后删除n个字符。
11. ``dd``删除一整行。``ndd``向下删除n行。
12. ``yy``复制一整行。``nyy``复制光标所在的向下n行。
13. ``p``粘贴到当前光标的下一行，``P``粘贴到光标的上一行。
14. ``J``将光标所在列与下一列的数据结合成一列。
15. ``u``撤回前一个操作。
16. ``ctrl+r``重做上一个动作。例如重复删除、重复粘贴。
17. ``.``也是重做上一个动作。

剩下的自己去看书或者文档吧，操作太多，需要实际使用来积累。



#### 编辑模式

> 以下并不是在编辑模式时的按键，仍然是在一般指令模式下的按键。

1. ``rx``用x取代光标所在的字母
2. ``R``进入编辑模式的``替代``模式
3. 除了``R``之外的进入编辑模式的按键效果都是进入``插入``模式。



#### 命令行模式

1. ``:w``
2. ``:w!``
3. ``:q``
4. ``:q!``若曾修改过文件，又不想储存，使用 ! 强制离开。

5. ``ZZ``若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开。
6. ``:w [file]``将数据存储成另一个文件
7. ``:r [file]``读入另一个文件的数据
8. ``:n1,n2 w [file]``把部分内容存储成另一个文件
9. ``:! command`` 在不关闭vim的条件下执行shell指令，执行完了立马回到vim中。

10. ``:set nu`` 让vim显示行号，``:set nonu``让vim不显示行号。



#### vim的救援(swp文件)

```shell
Swap file "xxx.swp" already exists! 下面说明你可进行的动作
[O]pen Read-Only, （E）dit anyway, （R）ecover, （D）elete it, （Q）uit, （A）bort:
```

- 如果多用户在操控这个文件

  - 找到另外那个程序或人员，请他将该 vim 的工作结束，然后你再继续处理。
  - 如果只是读取，那么按o即可。

- 前一个vim被未知原因中断

  - 如果你之前的 vim 处理动作尚未储存，此时你应该要按下“R”，亦即使用 （R）ecover 的项目， 此时 vim 会载入 xxx.swp 的内容，让你自己来决定要不要储存。

    不过那个 xxx.swp 并不会在你结束 vim 后自动删除，所以你离开 vim 后还得要自行删除xxx.swp 才能避免每次打开这个文件都会出现这样的警告。

  - 如果你确定这个暂存盘是没有用的，那么你可以直接按下“D”删除掉这个暂存盘，亦
    即 （D）elete it 这个项目即可。



#### vim的区块操作

按下ctrl+v或ctrl+V进入选择界面（再次操作即可退出），之后按y复制，按d删除，按p粘贴。



#### 多文件操作

> 通过``vim 文件1 文件2..``来同时编辑多个文件

1. ``:files``查看当前vim打开的文件。
2. ``:n``编辑下一个文件。
3. ``:N``编辑上一个文件。



#### 多窗口功能

1. ``:sp`` 新窗口打开同一个文件
2. ``:sp file1`` 新窗口打开另一个文件
3. ``ctrl+w``按了之后，松开ctrl和w，再按上下方向键(或jk)，即可换到另一个窗口。
4. 关闭一个窗口只需要转到那个窗口后``:q``即可。



#### 补全功能

1. ``[ctrl]+x -> [ctrl]+n`` 

   通过目前正在编辑的这个“文件的内容文字”作为关键字，予以补齐

2. ``[ctrl]+x -> [ctrl]+f``

   以当前目录内的“文件名”作为关键字，予以补齐

3. ``[ctrl]+x -> [ctrl]+o``

   根据你文件的扩展名进行相应扩展（例如.cpp则进行C++相关补全，非常有用）



#### vim的记录文件

例如记录每个文件上次光标位置，vim的记录用户动作的文件在``~/.viminfo``中。



你可以修改 ~/.vimrc 这个文件 （默认不存在，请你自行手动创建！），将你所希望的设置值写入！

举例来说，可以是这样的一个文件：

```shell
[dmtsai@study ~]$ vim ~/.vimrc
"这个文件的双引号 （"） 是注解
set hlsearch "高亮度反白
set backspace=2 "可随时用倒退键删除
set autoindent "自动缩排
set ruler "可显示最后一列的状态
set showmode "左下角那一列的状态
set nu "可以在每一列的最前面显示行号啦！
set bg=dark "显示不同的底色色调
syntax on "进行语法检验，颜色显示。
```



#### Windows和Linux的换行符

Windows(DOS)系统中换行是CR+LF，而Linux中只有LF，因此会有问题。

可通过``unix2dos``或``dos2unix``两个软件来进行格式转换。



#### 编码转换

``iconv -f 原本编码 -t 新编码 filename [-o newfile]``

``iconv --list`` 查看iconv支持的语系数据。



### 20.BASH

BASH是指Linux 使用的这一种版本就称为“ Bourne Again SHell （简称 bash）

``/etc/shells``文件中记录的就是这台系统中有哪几种可用的shell。Linux中默认就是bash。



当用户登陆的时候，系统就会给我一个 shell 让我来工作了。 而这个登陆取得的 shell 就记录在 /etc/passwd 这个文件内：

```shell
[dmtsai@study ~]$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
# root用户就用/bin/bash
# 系统账号bin就用/sbin/nologin
```



#### bash的功能

1. history

   按上下箭头即可查看以前执行过的命令，这些记录保存在``~/.bash_history``文件中。

   而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 .bash_history 当中。

2. 命令与文件补全功能

   [tab]不多说，好用得1。

3. 命令别名alias

   ``alias lm = 'ls-al'``这样下次在bash中输入``lm``就是``ls -al``。

4. 工作控制、前景背景控制

   （略，在后面会细讲，主要就是前后台工作使得可以多任务之类的）

5. 程序化脚本shell scripts

   .sh文件

6. 万用字符*

   bash 支持许多的万用字符来帮助使用者查询与指令下达，例如想知道 /usr/bin 下面有多少以 X 为开头的文件，就使用：`` ls -l /usr/bin/X*``



``type``可用来查一个指令是否是bash的内置指令。

``ctrl + u`` 从光标处向前删除指令串，``ctrl + k`` 向后删除。

``ctrl + a``让光标移动到整个指令串的最前面，``ctrl + e``让光标移动到最后面。



#### 变量取用与设置

- 变量的取用echo

  ``echo $PATH``或者``echo ${PATH}``

- 设置变量

  ``PATH=123``	等号两边不能直接接空白字符；变量开头不能是数字；

变量内容若有空白字符可使用双引号或单引号将变量内容结合起来，但
- 双引号内的特殊字符如 ``$`` 等，可以保有原本的特性，如下所示： ``var="lang is
$LANG"``则``echo $var``可得``lang is zh_TW.UTF-8``
- 单引号内的特殊字符则仅为一般字符 （纯文本），如下所示： ``var='lang is
$LANG'``则``echo $var``可得``lang is $LANG``

可用转义字符“ \ ”将特殊符号（如 [Enter], $, \, 空白字符, '等）变成一般字符，如：``myname=VBird\ Tsai``

在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用``$(指令)``，如：``version=$(uname -r)``

在变量的原有值末尾添加值可用`` "$变量名称" 或 ${变量}``，如：``PATH=${PATH}:/home/bin``

若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量：``export
PATH``

> 在一般的状态下，父程序的自定义变量是无法在子程序内使用的。但是通过 export 将变量变成环境变量后，就能够在子程序下面应用

取消变量的方法为使用 unset ：``unset 变量名称``



#### 特殊符号的意义

\d ：可显示出“星期 月 日”的日期格式，如："Mon Feb 2"
\H ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”
\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略
\t ：显示时间，为 24 小时格式的“HH:MM:SS”
\T ：显示时间，为 12 小时格式的“HH:MM:SS”
\A ：显示时间，为 24 小时格式的“HH:MM”
\@ ：显示时间，为 12 小时格式的“am/pm”样式
\u ：目前使用者的帐号名称，如“dmtsai”；
\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示
\w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；
\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
``#`` ：下达的第几个指令。
``$`` ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～



#### 环境变量

``env`` 列出目前shell环境下的所有环境变量与其内容。

``set`` 除了环境变量之外， 还会将其他在 bash 内的变量显示出来。

- 命令提示字符PS1

  内容为``[\u@\h \W]$``，根据上面特殊符号的意义就知道了。例如``[hzs@study tmp]$``

- $

  ```shell
  [hzs@study tmp]$ echo $$
  22144
  ```

  钱字号本身也是个变量，代表shell的进程ID。

- ?

  上个执行指令的回传值。



#### 自定义变量转为环境变量

子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量。

``export 变量名称`` 将自定变量转为环境变量。



#### 影响显示结果的语言变量

``locale -a``查看当前系统支持的语系编码。

``locale``查看与语言有关的环境变量。``/etc/locale.conf``中存储的是系统默认的语系定义。

> 如果其他的语系变量都未设置， 且你有设置 LANG 或者是 LC_ALL 时，则其他的语系变量就会被这两个变量所取代。这也是为什么我们在 Linux 当中，通常说明仅设置 LANG 或 LC_ALL 这两个变量。



当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子程序取用；

若在父程序利用 export 功能，可以让自订变量的内容写到上述的记忆区块当中（环境变量）；

当载入另一个 shell 时 （亦即启动子程序，而离开原本的父程序了），子 shell 可以将父shell 的环境变量所在的记忆区块导入自己的环境变量区块当中；



#### 键盘设置变量

- read

``-p``后面跟提示字符串，``-t``后面跟最长限时。

```shell
[dmtsai@study ~]$ read -p "Please keyin your name: " -t 30 named
Please keyin your name: VBird Tsai # 注意看，会有提示字符
```

- declare

``declare`` 不加任何参数则会显示所有变量和内容。

``declare`` 用来定义变量的类型，变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。

``-x`` 变为环境变量，``-a``变为数组类型，``-i``变为整型数字类型，``-r``变为readonly类型（不可改动，也不可unset！）。如果是``+``则代表和``-``相反的意思，即取消的意思。

```shell
# declare -a的作用，定义数组变量
[dmtsai@study ~]$ var[1]="small min"
[dmtsai@study ~]$ var[2]="big min"
[dmtsai@study ~]$ var[3]="nice min"
[dmtsai@study ~]$ echo "${var[1]}, ${var[2]}, ${var[3]}"
```



#### 与文件系统及程序的限制关系

``ulimit -a``查看当前限制参数。

``ulimit -f 10240``限制使用者仅能创建10MB以下容量的文件。

想要复原 ulimit 的设置最简单的方法就是登出再登陆。

一般身份使用者如果以 ulimit 设置了 -f 的文件大小， 那么他只能继续减小文件大小，不能增加文件大小。



#### 变量内容的删除、取代与替换

- 删除


1. 从前向后匹配删除：
#: 符合取代文字的最短的那一个
``echo ${path#/*user/ker/bin:}``
##: 符合取代文字的最长的那个一个
``echo ${path##/*:}``
2. 从后向前匹配删除
    %: 符合取代文字的最短的那一个
    ``echo ${path%:*bin}``
    %%: 符合取代文字的最长的那个一个
    ``echo ${path%%:*bin}``

> 例题：假设你是 dmtsai ，那你的 MAIL 变量应该是 /var/spool/mail/dmtsai 。假设你只想要保留最后面那个文件名 （dmtsai）， 前面的目录名称都不要了，如何利用 MAIL 变量来达成？
> 答：题意其实是这样“/var/spool/mail/dmtsai”，亦即删除掉两条斜线间的所有数据（最长符合）。 这个时候你就可以这样做即可：
>
> ```shell
> [dmtsai@study ~]$ echo ${MAIL##/*/}
> ```



- 取代

```shell
# 范例六：将 path 的变量内容内的 sbin 取代成大写 SBIN：
[dmtsai@study ~]$ echo ${path/sbin/SBIN}
/usr/local/bin:/usr/bin:/usr/local/SBIN:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
# 这个部分就容易理解的多了！关键字在于那两个斜线，两斜线中间的是旧字串
# 后面的是新字串，所以结果就会出现如上述的特殊字体部分啰！
[dmtsai@study ~]$ echo ${path//sbin/SBIN}
/usr/local/bin:/usr/bin:/usr/local/SBIN:/usr/SBIN:/home/dmtsai/.local/bin:/home/dmtsai/bin
# 如果是两条斜线，那么就变成所有符合的内容都会被取代喔！
```



- 测试变量，并设置变量

``var2=${var1-content}`` 测试var1是否存在，否则var2设置为content

``var2=${var1:-content}`` 测试var1是否存在或为空字符串，否则var2设置为content

总结：

1. 不带``:``的表示触发条件为var1没有设置，带``:``的表示触发条件为var1没有设置 or var为空字符串。

2. ``-``表示当条件触发时，var2会被设置为content，否则var2会被设置为var1的值。
3. ``+``表示当条件触发时，var2会为空，否则var2会变为content。
4. ``=``表示当条件触发时，var1和var2都变为content，否则还是像``-``那样

5. ``?``表示当条件触发时，content会被输出到stderr，否则还是像``-``那样

> 上面这个语法真的有点奇怪，建议要用时还是先看下书P518



#### 命令别名和历史命令

- 命令别名alias

``alias`` 查看目前所有的别名指令

``alias lm='ls -al'`` 创建别名

``unalias lm`` 取消别名lm

- 历史命令history

``history`` 查看系统中目前保存的所有命令历史

``history 10``查看最近10条记录

``history -c`` 清除记录

``history -w`` 将内存中的新历史刷新到``~/.bash_history``中，如果后面有另外的文件名则是写到这个文件中。



``~/.bash_history``中固定保存有HISTFILESIZE 个记录。



``!!``执行上一条指令

``!n``执行history中第n条指令

``!xx``执行history中最近的以xx开头的指令



- 同一帐号同时多次登陆的 history 写入问题

当一个用户开了多个bash窗口，则每个窗口都在内存中存有一份history，最后登出的那个 bash 才会是最后写入~/.bash_history的数据。



