### 26.Linux账号管理

/etc/passwd中存放账号和UID/GID；

/etc/shadow中存放账号对应的密码；



UID=0是系统管理员，1~999是系统账号，1000~60000是可登陆账号。



/etc/shadow中存放的密码是经过加密的。



如果root密码忘记了，重新开机进入单人维护模式（第十九章）后，系统会主动的给予 root 权限的 bash接口， 此时再以 passwd 修改密码即可。



/etc/group中存放群组名和GID，以及群组中用户名称列表；



groups查看当前账户所属的多个组，其中排在第一个的组是该账户的有效群组；

newgrp可以切换当前有效群组。（有效群组就是用当前账户新建文件时该文件所属的组）



/etc/gshadow中存放群组的密码，以及群组管理员、群组中用户名称列表；

密码栏上面是“!”或空的时，表示该群组不具有群组管理员。

群组管理员就是管理群组成员的，root可以管理每个群组，而群组管理员则管理对应的群组。



#### 添加账号

useradd 可以添加账号；

passwd 账号名， 可以为账号给予密码；

/etc/default/useradd中存放了新建账号时的一些默认设置；

其中SKEL=/etc/skel这个，就是说新建一个账户时，对应主文件夹中的初始内容就是从/etc/skel中复制的。



/etc/login.defs中存放了UID和GID的一些配置，例如``使用者能够用的最大 UID``，``使用者自订群组的最大 GID``之类的。



系统给予一个帐号 UID 时，他是 （1）先参考 UID_MIN 设置值取得最小数值； （2）由 /etc/passwd 搜寻最大的 UID 数值， 将 （1） 与 （2） 相比，找出最大的那个再加一就是新帐号的 UID。



passwd id 修改名为id的账户的密码。

passwd 改当前账户的密码。

chage id 也是可以查看账户的各种当前设置（比passwd -S更详细），以及修改一些设置。

> 使用者在第一次登陆时，强制她们一定要更改密码后才能够使用系统资源，方法就是通过chage或者passwd指令将账户的最后一次修改密码时间改为0，即1970-01-01。

usermod指令也是可以修改账户设置的。和passwd/chage差不多。

userdel 删除账户。

> 如果想要完整的将某个帐号完整的移除，最好可以在下达 userdel -r username 之前， 先以“ find / -user username ”查出整个系统内属于 username 的文件，然后再加以删除。



#### 非root指令

id 查看所有账户的UID/GID信息。



groupadd、groupmod、groupdel管理群组，不多说。

gpasswd可以给群组设置密码，为群组设置管理员。当使用管理员账号时，gpasswd可用来管理群组。



#### ACL

- setfacl

``setfacl -m`` 设置ACL参数，例如

```shell
setfacl -m u:huhu:rx file1	# user huhu对file1的权限为rx
setfacl -m g:group1:rx file1 # group group1对file1的权限为rx
setfacl -m m:rx file1 # 设置file1的mask为rx，也就是非root用户和owener用户以外的其他账户or群组最大允许的权限为rx
```

u::rx 中间一栏为空代表拥有者。



- getfacl

获取ACL参数，例如：

```shell
[root@study ~]# getfacl acl_test1
# file: acl_test1 		# 说明文档名而已！
# owner: root 			# 说明此文件的拥有者，亦即 ls -l 看到的第三使用者字段
# group: root 			# 此文件的所属群组，亦即 ls -l 看到的第四群组字段
user::rwx 				# 使用者列表栏是空的，代表文件拥有者的权限
user:vbird1:r-x 		# 针对 vbird1 的权限设置为 rx ，与拥有者并不同！
group::r-- 				# 针对文件群组的权限设置仅有 r
mask::r-x 				# 此文件默认的有效权限 （mask）
other::r-- 				# 其他人拥有的权限啰！
```



- d默认权限

使用默认权限设置目录未来文件的 ACL 权限继承“ d:[u|g]:[user|group]:权限 ”，d是default的意思。

```shell
# 在这个文件夹中再创建文件，就自动会获取default中的权限
[root@study ~]# getfacl /srv/projecta
# file: srv/projecta
# owner: root
# group: projecta
# flags: -s-
user::rwx
user:myuser1:r-x
group::rwx
mask::rwx
other::---
default:user::rwx
default:user:myuser1:r-x
default:group::rwx
default:mask::rwx
default:other::---
```

- setfacl -b

让 ACL 的属性全部消失。

让某一ACL属性消失用``setfacl -x``。

```shell
# 1.2 针对每个设置值来处理，注意，取消某个帐号的 ACL 时，不需要加上权限项目！
[root@study ~]# setfacl -x u:myuser1 /srv/projecta
[root@study ~]# setfacl -x d:u:myuser1 /srv/projecta

# 2.1 开始让 pro3 这个用户无法使用该目录啰！
[root@study ~]# setfacl -m u:pro3:- /srv/projecta
```



#### 用户切换

su 以non-login shell方式变为root，所谓non-login就是说很多原本的变量和设置依然还是原来用户的，例如PATH和MAIL之类的。

su - 则是以login shell方式变为root，所有东西都变为root。

su -l user 则是以login shell方式变为某个用户。``su - user``也是的貌似。

**注意**：每su一次就会进入一个子shell，输入exit才会退出。



- sudo

sudo 可以让你以其他用户的身份执行指令 （通常是使用 root 的身份来执行指令），因此并非所有人都能够执行 sudo ， 而是仅有规范到 /etc/sudoers 内的用户才能够执行 sudo 这个指令。

sudo -u user1 可以以用户user1的身份。

作用就是一般系统账号无法被切换到（因为系统账号的shell是/sbin/nologin），而sudo就可以不切换用户就借用其身份。

1. 当使用者执行 sudo 时，系统于 /etc/sudoers 文件中搜寻该使用者是否有执行 sudo 的权限；
2. 若使用者具有可执行 sudo 的权限后，便让使用者“输入使用者自己的密码”来确认；
3. 若密码输入成功，便开始进行 sudo 后续接的指令（但 root 执行 sudo 时，不需要输入密码）；
4. 若欲切换的身份与执行者身份相同，那也不需要输入密码。



- visudo

这个指令就是vi + /etc/sudoers，且在执行结束时顺便检查/etc/sudoers文件是否语法正确。

/etc/sudoers中的数据格式是 ``使用者账号、登陆者的来源主机名称、可切换身份、可下达指令``

```shell
root ALL=(ALL) ALL
# 意思就是root可以来自于任何一台主机，可以切换成任何一个账户，可以下达任何指令
# 因为root在此文件中，因此root可以使用sudo（不在此文件中的账户不可用sudo命令）

%wheel ALL=(ALL) ALL
# 前面有%代表是群组，也就是任何在这个群组中的账户都可

%wheel ALL=(ALL) NOPASSWD: ALL
# NOPASSWD含义是不需要密码就可sudo命令

myuser1 ALL=(root) /usr/bin/passwd
# 仅能变成root去执行passwd指令

myuser1 ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
# 不能修改root的密码，只可修改其他账户的

User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2
Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
ADMPW ALL=(root) ADMPWCOM
# 设置别名，更加方便
```



#### 特殊的shell

/sbin/nologin这个shell是给系统账户之类的不能登陆的账号用的，例如apache就只负责WWW服务。

/etc/nologin.txt中写的内容会在不可登陆的账号尝试登陆login shell时显示。



#### PAM

PAM 模块可进行某些程序的验证程序。

PAM是一个拓展模块，例如passwd指令就会去调用PAM模块来进行密码的验证，如果通过则PAM会返回OK的信息给调用它的passwd指令。

（内容太枯燥，略）



#### 主机上的使用者讯息传递

- 查询使用者

``who`` 查询目前已登录在系统上的其他使用者，以及他们所在的端口。

``lastlog`` 查询每个账号的最近登陆时间。



- 使用者对谈

``write 账号名称 账号所在端口`` 向另一个用户发松消息。输入EOF结束。

``wall`` 向所有用户发送消息。

``mesg n`` 拒绝接受消息（root发来的不可拒绝）

``mesg y`` 允许接受消息。



- 使用邮件信箱

``mail -s "邮件标题" username@localhost``

给本机用户的邮箱发送邮件不需要``@localhost``。

```shell
[root@study ~]# mail -s "nice to meet you" vbird1
Hello, D.M. Tsai
Nice to meet you in the network.
```

``mail`` 进入自己的邮箱即可查看当前邮件。



#### 大量账号管理

- pwck

pwck就是检查/etc/passwd和/etc/shadow两个文件的内容是否有问题。

- pwconv

pwconv就是将/etc/passwd中的账号密码信息移动到/etc/shadow中。

用useradd指令创建的账户的密码会自动在/etc/shadow。

- pwunconv

pwunconv 则是“将 /etc/shadow 内的密码栏数据写回 /etc/passwd 当中，并且删除 /etc/shadow 文件。（没啥作用）

- chpasswd

该指令将未加密的密码加密后写入到/etc/shadow中。格式是``username:password``。

```shell
[root@study ~]# echo "vbird3:abcdefg" | chpasswd
```

openssl rand -base64 6） &#124;&#124; usepw=${username}



### 27.quota磁盘配额

XFS自带quota，``xfs_quota``。

quota的使用受实际文件系统和内核版本的限制，使用时查清楚。



quota分配的限额分为soft和hard，超过soft则会受到提醒，如果提醒超过宽限时间（grace time，默认是7天）还不调整那么会立刻被限制住，而到达hard时就会立马被限制住。



可以对账号、群组、目录进行限额，注意群组的限额和目录的限额无法同时并存。



启用quota要首先修改/etc/fstab文件中的参数。

在quota中目录貌似就是被称为project。



不同文件系统的文件夹如何统一被限额？用软连接将其中引到另一个之中即可。再对大的文件夹进行限额。



### 28.RAID

- RAID0

就是交错存放数据（chunk）。

例如磁盘A和B，就把输入数据切成固定大小的chunk，交错存放到A和B。



- RAID1（Mirror）

就是一份数据同时存在两个磁盘上。



- RAID0+1

RAID 0+1就是要4个磁盘了。树形结构，上层是RAID0，下层是RAID1。



- RAID5

3个磁盘，每次都写两个chunk的数据到两个磁盘中，之后再把校验码写到第三个磁盘。且校验码不会固定地在一个磁盘中，而是轮流地来。

容错能力为1个磁盘，即只损坏3个中的一个时可以进行恢复，但如果2个都坏则不可恢复。



- RAID6

RAID6相比于RAID5，就是多写了一个校验码，写两个chunk，就写两个校验码chunk。

容错率为2个磁盘。



mdadm可以用来设置软件的RAID。（硬件RAID太贵了）

mdadm可以 partition 或 disk 为磁盘的单位进行设计RAID。

软件磁盘阵列的设备名是/dev/md0，/dev/md1之类的。

硬件磁盘阵列的设备名是/dev/sd[a-p]之类的。我们的磁盘大多都是自带一些RAID功能。

/proc/mdstat中存放了系统软件磁盘阵列的详细信息。

/etc/mdadm.conf中存放了软件磁盘阵列的配置信息。



### 29.LVM

- PV，实体卷轴，需要gdisk指令分区并调整系统识别码 （system ID） 成为 8e
- VG，卷轴群组，就是由多个PV组成
- PE，类似文件系统中的Block单位，LVM 默认使用 4MB 的 PE 区块
- LV，逻辑卷轴，VG可以切分成多个LV

切成LV后，就可以在单个LV上调用mkfs进行格式化并挂载。

数据写入一个LV有两种模式，线性模式，交错模式，默认是线性模式。

具体指令有pvcreate, vgcreate, lvcreate等。



- LV扩大

要扩大LV得先确保VG还有余量，并且确保LV中的文件系统是可以扩大的。

- LVM thin Volume

这个有点“虚拟磁盘”的感觉，就是本来没5G的磁盘，但是可以先申明是个5G的磁盘，实际写数据的时候是用了多少就分配多少。

实际操作过程是先产生一个thin pool LV设备，再在这个池子基础上去产生一个“巨大”的虚拟磁盘。

- LVM的磁盘快照

快照就是将当时的系统信息记录下来，就好像照相记录一般！ 未来若有任何数据更动了，则原始数据会被搬移到快照区，没有被更动的区域则由快照区与文件系统共享。

由于快照涉及共享，因此快照区必须也在原来的VG上。

> 换个角度来想想，我们将原本的 vbirdlv 当作备份数据，然后将 vbirdsnap1 当作实际在运行中的数据， 任何测试的动作都在 vbirdsnap1 这个快照区当中测试，那么当测试完毕要将测试的数据删除时，只要将快照区删去即可。
>
> 注释：意思就是从快照区更改一个文件，则这个文件也会被搬到快照区，不再共享。

- LVM的卸载

1. 先卸载系统上面的 LVM 文件系统 （包括快照与所有 LV）；

2. 使用 lvremove 移除 LV ；
3. 使用 vgchange -a n VGname 让 VGname 这个 VG 不具有 Active 的标志；
4. 使用 vgremove 移除 VG：
5. 使用 pvremove 移除 PV；
6. 使用gdisk 修改 ID 回来；



P753
