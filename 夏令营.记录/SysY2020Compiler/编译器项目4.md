- MIPS有32个通用寄存器



中简代码在很大程度上已经可以很容易地翻译成许多RISC的机器代码，不过仍存在以下问题：

- **指令选择问题**：中间代码与目标代码之间并不是严格一一对应的。有可能某条中间代码对应多条目标代码，也有可能多条中间代码对应一条目标代码。

- **寄存器分配问题**：中间代码中我们使用了数目不受限的变量和临时变量，但处理器所拥有的寄存器数量是有限的。RISC机器的一大特点就是运算指令的操作数总是从寄存器中获得。

- **栈管理问题**：中间代码中我们并没有处理有关函数调用的细节。函数调用在中间代码中被抽象为若干条ARG语句和一条CALL语句，但在目标机器上一般不会有专门的器件为我们进行参数传递，我们必须借助于寄存器或栈来完成这一点。



### MIPS32

- 数据段中常见的storage_type

| storage_type        | 描述                                      |
| ------------------- | ----------------------------------------- |
| .ascii str          | 存储str于内存中，但不以null结尾。         |
| .asciiz str         | 存储str于内存中，并以null结尾。           |
| .byte b1, b2, …, bn | 连续存储n个字节（8bits位）的值于内存中。  |
| .half h1, h2, …, hn | 连续存储n个半字（16bits位）的值于内存中。 |
| .word w1, w2, …, wn | 连续存储n个字（32bits位）的值于内存中。   |
| .space n            | 在当前段分配n个字节的空间。               |



- 非操作系统内核的汇编代码文件必须以.s或者.asm作为文件的后缀名。MIPS汇编代码由若干代码段和若干数据段组成，其中代码段以.text开头，数据段以.data开头。汇编代码中的注释以#开头。



数据段可以为汇编代码中所要用到的常量和全局变量申请空间，其格式为： ``name: storage_type value(s)``

MIPS体系结构共有32个寄存器，在汇编代码中你可以使用$0至$31来表示它们。为了便于 表示和记忆，这32个寄存器也拥有各自的别名，如下表所示。

![image-20210614131242088](.\images\image6.png)



### 指令选择

如果使用的是线形IR，则最简单的指令选择方式是逐条将中间代码对应到目标代码上。（此时生成目标代码的方式和生成IR差不多）

有时候为了得到更高效的目标代码，我们需要一次考察多条中间代码，以期可以将多条中间代码翻译为一条MIPS32代码，这个过程可以看作是一个多行的模式匹配，也可以看成用一个滑动窗口或一个窥孔滑过中间代码并查找可能的翻译方案的过程。这非常类似于我们课本上介绍的“窥孔优化”的局部代码优化技术。



### 寄存器分配

为一段包含单个基本块、只有一种数据类型、访存代价固定的中间代码生成代价最少的寄存器分配方案是可以在 多项式时间内被计算出来的。在此基础上，几乎添加任何假设（如多于一个基本块、多于一种 数据类型、使用多级存储模型等）都会使得寻找最优寄存器分配方案变成一个NP-hard问题。因此，目前编译器使用的寄存器分配算法大都是**近似最优分配方案**。

#### 朴素寄存器分配算法

将所有的变量或临时变量都放在内存里。如此一来，每翻译一条中间代码之前我们都需要把要用到的变量先加载到寄存器中，得到该代码的计算结果之后又需要将结果写回内存。

#### 局部寄存器分配算法

该方法会事先将整段代码分拆成一个个基本块，在每个基本块内部我们根据各种启发式原则为块里出现的变量分配寄存器。但在基本块结束时这种算法会与前面提到的朴素算法一样，需要将本块中所有修改过的变量都写回内存。

对基本块内部的中间代码逐条扫描，如果当前代码中有变量需要使用寄存器，就从当前空闲的寄存器中选一个分配出去；如果没有空闲的寄存器，不得不将某个寄存器中的内容写回内存（该操作称为溢出或spilling）时，则选择那个包含本基本块内将来用不到或最久以后才用到的变量的寄存器。通过这种启发式规则，该算法期望可以最大化每次溢出操作的收益，从而减少访存所需要的次数。



#### 图染色算法前篇——活跃变量分析

首先我们严格定义什么叫活跃变量：称变量x在某一特定的程序点是活跃变量当且仅当：

- 某条代码用了x的值，则在这代码之前x都是活跃的；（如何产生活跃）
- 如果x在某条代码中被赋值，且x没有被该代码用到，则x在这代码之前是不活跃的；（如何消灭活跃）
- 如果x在某条代码之后是活跃的，而这条代码并没有给x赋值，则x在这条代码运行之前也是活跃的；
- 如果x在某条代码之后是活跃的，则x在这条代码之后可能跳转到的所有的中间代码运行之前都是活跃的；



定义第i条中间代码的后继集合succ[i]为：

1) 如果第i条中间代码为无条件跳转语句GOTO，并且跳转的目标是第j条中间代码，则 succ[i] = { j }。

2) 如果第i条中间代码为条件跳转语句IF，并且跳转的目标是第j条中间代码，则succ[i] = { j, i + 1 }。 

3) 如果第i条中间代码为返回语句RETURN，则succ[i] = 空集。 

4) 如果第i条中间代码为其他类型的语句，则succ[i] = { i + 1 }。



我们再定义：

1) def[i]为被第i条中间代码赋值了的变量的集合，

2) use[i]为被第i条中间代码使用 到的变量的集合，

3) in[i]为在第i条中间代码运行之前活跃的变量的集合，

4) out[i]为在第i条中间代 码运行之后活跃的变量的集合。

活跃变量分析问题可以转化为解下述数据流方程的问题：

𝑖𝑛[𝑖] = 𝑢𝑠𝑒[𝑖] ∪ (𝑜𝑢𝑡[𝑖] − 𝑑𝑒𝑓[𝑖])和𝑜𝑢𝑡[𝑖] = ⋃<sub> 𝑗∈𝑠𝑢𝑐𝑐[𝑖]</sub> 𝑖𝑛[𝑗]  。

我们可以通过迭代的方法对这个数据流方程进行求解。算法开始时我们令所有的in[i]为空集，之后每条中间代码对应的in和out集合按照上式进行运算，直到这两个集合的运算结果收敛为止。格理论告诉我们，in和out集合的运算顺序不影响数据流方程解的收敛性，但会影响解的收敛速度。对于上述数据流方程而言，按照i从大到小的顺序来计算in和out往往要比按照i从 小到大的顺序进行计算要快得多。

（为了能更高效地对集合in和out进行计算，在实现时我们往往采用位向量（Bit Vector）来表示这两个集合）



#### 图染色算法

> 一个适用于全局的寄存器分配算法，这种全局分配算法必须要能有效地从中间代码的控制流中获取变量的活跃信息，而**活跃变量分析**（Liveliness Analysis）恰好可以为我们提供这些信息。

现在假设我们已经进行过这种分析并了解到了在每个程序点上哪些变量在将来的控制流中可能还会被使用到。

首先要定义两个变量不能分配同一个寄存器的条件，即**相互干扰**：

（就只记忆个：如果x和y都属于一条指令的out[i]就干扰）

x和y相互干扰就意味着我们应当尽可能地为二者分配不同的寄存器



如果将中间代码中出现的所有变量和临时变量都看作顶点，两个变量之间若相互干扰则在二者所对应的顶点之间连一条边，那么我们就可以得到一张干涉图（Interference Graph）。



对于固定的颜色数k，判断一张干涉图是否能被k着色是一个NP-Complete问题。因此，为了能够在多项式时间内得到寄存器分配结果，我们只能使用启发式算法来对干涉图进行着色。一个比较简单的启发式染色算法（称作Kempe算法）为：

1) 从图中删除度小于等于k-1的点，压入到栈中。

2) 重复上述操作，如果最后图中只剩下了少于k个顶点，那么此时就可以为剩下的每个顶点分配一个颜色，然后依次弹出栈中的顶点添加回干涉图中，并选择它的邻居都没有使用过的颜色对弹出的顶点进行染色。

3) 如果删除到图中剩下的点全是至少包含了k个邻居的情况，则仍然选择一个顶点删除并且将其压栈，并且标记这样的顶点为**待溢出**的顶点，之后继续删点操作。

4) 被标记为待溢出的顶点在最后被弹出栈时，如果我们足够幸运，有可能它的邻居总共被染了少于k种颜色。此时我们就可以成功地为该顶点染色并清除它的溢出标记。否则，我们无法为这个顶点分配一个颜色，它所代表的变量也就必须要被溢出到内存中了。

> 到这里，中间代码中出现的所有变量要么被分配了一个寄存器，要么被标记为溢出。现在的问题是，那些被标记为溢出的变量的值在参与运算时仍然需要临时被载入到某个寄存器中， 在运算结束后也仍然需要某个寄存器临时保存要溢出到内存里的值，这些临时使用的寄存器从哪里来呢？

最简单的解决方法是在进行前面图染色算法之前预留出专门用来临时存放溢出变量的值的寄存器。如果你觉得这样做比较浪费寄存器资源，想要追求更有效率的分配方案，你可以通过不断地引入更多的临时变量重写中间代码、重新进行活跃变量分析和图染色来不断减少需要溢出的变量的个数，直到所有的溢出变量全部被消除掉。另外，对于干涉图中那些不相邻的顶点，我们还可以通过合并顶点的操作来显式地令这些不互相干扰的变量共用同一个寄存器。(会使算法更复杂)



### MIPS寄存器

- $0永远都是0；
- $at、$k0、$k1这三个寄存器是专门预留给汇编器使用的；
- $v0和$v1这两个寄存器专门用来存放函数的返回值；
- $a0至$a3四个寄存器专门用于存放函数参数，在函数内部它们可以视作与$t0至$t9等同；
- $t0至$t9这10个寄存器可以由我们任意使用，它们属于调用者保存的寄存器；
- $s0至$s7也可以任意使用，不过它们是被调用者保存的寄存器；
- $gp固定指向64K静态数据区的中央，$sp固定指向栈的顶部；
- $ra专门用来保存函数的返回地址；
- $30这个寄存器比较特殊，有些汇编器将其作为$s8使用，也有一些汇编器将其作为栈帧指针$fp使用；

总而言之，MIPS的32个通用寄存器中能让我们随意使用的有$t0至$t9以及$s0至$s8，不能随意使用的有$at、$k0、$k1、$gp、$sp和$ra，可以使用但在某些情况下需要特殊处理的有$v0至$v1以及$a0至$a3，最后$0可用但其值无法修改。



### 栈帧管理

> 栈帧的布局没有规定，理论上来讲只要能将应该保存的内容都存下来，并且能够正确地将它们都取出来就行

MIPS32中的$sp实际上相当于x86中的%esp，而MIPS32中的$fp则相当于x86中的%ebp。如果决定使用$fp的话，为了能够使本函数返回之后能够恢复上层函数的$fp，需要在活动记录中找地方把$fp中的旧值也存起来。

MIPS32约定$t0至$t9由调用者负责保存，而$s0~$s8由被调用者负责保存。这也就启示我们，$t0至$t9应该尽量分配给那些短期使用的变量或临时变量，而$s0至$s9应当尽量分配给那些生存期比较长，尤其是生存期跨越了函数调用的变量或临时变量。

#### 函数调用对寄存器分配算法的影响：

如果采用了局部寄存器分配算法，就把CALL语句看作单独一个基本块，进入CALL之前把那些变量溢出到内存，CALL结束后再将溢出的值读取回来。

如果采用了全局寄存器分配算法（图染色），避免为那些在CALL语句处活跃的变量染上代表$t0至$t9之中任何寄存器的颜色。这样一来，我们的算法会自动地为那些生存期跨越函数调用的变量去分配$s0至$s8。如果这样的变量多于被调用者保存的寄存器个数，则算法会自动将多出来的变量溢出到内存。

（实践表明采用图染色的全局寄存器分配算法只有在可用的通用寄存器数目达到或超过16个时才能产生出令人满意的寄存器分配方案。）

