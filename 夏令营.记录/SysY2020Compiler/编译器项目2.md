本部分主要与语义分析有关。至于语法分析和语义分析之间的关系，很简单，语法分析中"int j = 0; i = j + 1"可能会是对的，但是在语义分析中就很容易看出i这个变量没有定义（undefined variable）。语义分析就是找逻辑错误的。

因为我们的语法分析阶段是按照**上下文无关文法**来进行的，所以对于一些上下文相关的错误（例如变量在使用之前是否已经被定义过，一个函数内部定义的变量在另一个函数中是否允许使用等）只有在语义分析阶段得到处理。



语义分析就是要为后面生成中间代码做好以下各种事（假设遇到了一个变量或函数x）：

- 如果x是变量，那么x中存储的是什么内容（是什么类型）

- 如果x是变量，那么变量x在内存中占用的空间多大；
- 如果x是变量，那么变量x什么时候该创建，什么时候灭亡；
- 如果x是变量，那么谁该负责为x分配存储空间，是用户显式分配，还是编译器生成专门的代码分配；
- 如果x是函数，那么函数要返回什么类型的值，要接受哪些参数；



之所以不能在语义分析中继续使用上下文无关文法，是因为识别一个输入是否符合某一上下文相关文法，这个问题本身是P-Space Complete的，也就是复杂度很高。其次是上下文无关文法很难对编译器需要的更多信息进行编码；



### 属性文法

用于语义分析的理论工具叫做属性文法，其核心思想是为上下文无关文法中的每一个终结符或非终结符赋予一个或多个属性值。

属性值分为：**综合属性**，**继承属性**。

在语法树中，一个结点的综合属性值是从其子结点的属性值计算而来的，而一个结点的继承属性值则是由该结点的父结点和兄弟结点的属性值计算而来的。

如果对于一个文法P，任何A->X1...Xn∈P都有与之相关联的若干个属性定义规则，则称P为属性文法。

如果属性文法P只包含综合属性而没有继承属性，则称P为**S属性文法**。

如果每个属性定义规则中的每个属性要么是一个综合属性，要么是Xj的一个继承属性，且该继承属性只依赖于X1...Xj-1的属性和A的继承属性，则称P为**L属性文法**。

以属性文法为基础衍生除的翻译模式就是**语法制导翻译SDT**。SDT中属性文法中属性定义规则用计算属性值的语义动作表示，并用"{}"括起来，可被插入到产生式右部的任何合适位置上。



### 符号表

符号表负责记录“名字”与“特征信息”。名字就是程序名、变量名、函数名等等。而特征信息就是上述名字的种类、维数、参数个数等等。（PS：符号表还会在生成目标指令时用到，因为符号表还可以记录变量的被分配到的寄存器名）



符号表操作有**填表**和**查表**。

符号表的组织方式各种各样，可以把所有名字组织成一张表；也可以所有变量名一张表、所有函数名一张表；还可以按照每个语句块、每个结构体都新建一张表。（如果要实现作用域的话则需要将符号表组织称层次结构）

只要觉得方便，可以向符号表里填任何内容，毕竟符号表就是为了支持编写编译器而设置的。

- 线性链表
- 平衡二叉树
- 散列表
- multiset discrimination：先统计符号数，最后申请一张与符号总数一样大的符号表；



#### 实现作用域



**第一种方法**：

维护一个符号表栈，当遇到一个{}括起来的语句块时就将当前符号表压栈，然后新建一个符号表。如果在当前符号表中找不到这个变量就顺着符号表栈向下逐个进行检查，使用第一个查找成功的。找不到就报错。当离开一个语句块时先销毁当前的符号表，然后从栈中弹一个符号表出来作为当前的符号表。



**第二种方法**：

只用一个符号表，大概思路和上面方法类似。

可以用十字链表实现：

Y轴：一个HashTable，其中每个元素指向一个符号链表，代表所有相同hash值的符号组成的链表。

X轴：一个Stack，代表符号表-表，每个元素指向一个符号链表，代表某个作用域中的所有符号组成的链表。



编程语言的类型系统分为两种：强类型系统、弱类型系统，前者在任何时候都不允许出现任何类型错误，而后者可以允许某些类型错误出现在运行时刻。C和C++就是典型的弱类型系统。



编译器尝试去发现输入程序中的类型错误的过程被称为类型检查，分为**静态类型检查**和**动态类型检查**。静态类型检查仅在编译时刻进行，而动态类型检查则会生成额外的代码在运行时刻检查操作的合法性。（因此静态类型检查的目标代码效率往往比动态类型检查的要高）



#### 实现类型检查

在引入了数组和结构体之后，可以用链表表示符号类型。同时可以根据符号类型结构体进行类型检查。

比如一个int[5] [2]类型，就可以是：

> 一个基本的结构体Type1告诉编译器该符号类型是array，然后告诉数组的大小为5和数组元素类型Type2，
>
> 然后编译器查看Type2发现数组元素的类型又是个array，数组大小为2和数组元素类型为int。



实际的编译器复杂程度会很大，因为涉及到显式/隐式类型推断，实际的编译器需要将类型转换规则生成为形式系统，并在这个形式系统上进行逻辑推理。

