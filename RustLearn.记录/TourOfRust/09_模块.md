# 模块mod

- 模块

  1. 每个Rust程序是个crate

  2. 每个crate都是由模块的层次结构组成；
  3. 每个crate有一个根模块；
  4. 模块里可以有全局变量、全局函数、全局结构体、全局Trait、全局模块；

  5. Rust中文件与模块树的层次结构并不是一对一的映射关系。必须在代码中构建模块树；

- 编写程序

  程序的根模块需要放在``main.rs``里面

- 编写库

  库的根模块需要在一个叫``lib.rs``里面

- 引用其他模块和crate

  就用``use``即可，例如``use std::f64::consts::PI``，之后在main函数中只需要写``PI``即可。

- 引用多个模块

  在同一个模块路径中可以引用多个项目，比如

  ``use std::f64::consts::{PI, TAU}``

- 创建模块

  在Rust中，有两种方式来声明一个模块，例如，模块``foo``可以表示为：

  1. 一个名为``foo.rs``的文件；
  2. 在名为``foo``的目录，里面有一个叫``mod.rs``文件；

- 模块层次结构

  模块可以互相依赖，要建立一个模块和其子模块之间的关系，你需要在父模块中这样写：

  ``mod foo;``

  上面的声明将使编译器寻找一个名为``foo.rs``或``foo/mod.rs``的文件，并将其内容插入这个作用域内名为``foo``的模块中。

- 内联模块

  一个子模块可以直接内联在一个模块的代码中。

  内联模块最常见的用途是创建单元测试。 下面我们创建一个只有在使用 Rust 进行测试时才会存在的内联模块！

  ```rust
  // 当 Rust 不在测试模式时，这个宏会删除这个内联模块。
  #[cfg(test)]
  mod tests {
      // 请注意，我们并不能立即获得对父模块的访问。我们必须显式地导入它们。
      use super::*;
  
      ... 单元测试写在这里 ...
  }
  ```

- 模块内部引用

  你可以在你的 `use` 路径中使用如下 Rust 关键字来获得你想要的模块：

  - `crate` - 你的 crate 的根模块
  - `super` - 当前模块的父模块
  - `self` - 当前模块

- 导出

  默认情况下，*模块*的成员不能从模块外部访问（甚至它的子模块也不行！）。 我们可以使用 `pub` 关键字使一个模块的成员可以从外部访问。

  默认情况下，*crate* 中的成员无法从当前 crate 之外访问。我们可以通过在**根模块**中 (`lib.rs` 或 `main.rs`)， 将成员标记为 `pub` 使它们可以访问。

- 结构体可见性

  就像函数一样，结构体可以使用 `pub` 声明它们想要在模块外暴露的东西。

- Prelude

  为什么我们在没用 `use` 导入 `Vec` 或 `Box` 的情况下却可以到处使用它们。 这是因为标准库中有一个叫 `prelude` 的模块。

  要知道，在 Rust 标准库中，以 `std::prelude::*` 导出的任何东西都会自动提供给 Rust 的各个部分。 `Vec` 和 `Box` 便是如此，并且其他东西（Option、Copy 等）也是如此。

- 你自己的 Prelude

  你看，既然标准库里面有 prelude，那么你自己的库里面最好也要有一个 prelude 模块。 这个模块可以作为其他使用你的库的用户的起点：他们可以借此导入你的库里面所有常用的数据结构 (例如 `use my_library::prelude::*`)。 当然，这个模块就不会在用了你的库的程序或别的库里面自动启用了。不过使用这个惯例的话，大家会很轻松地知道从何开始的。

